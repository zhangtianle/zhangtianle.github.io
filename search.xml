<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>论文笔记-HGT Heterogeneous graph transformer</title>
    <url>/2021/06/12/hgt-reading/</url>
    <content><![CDATA[<p>核心思想：利用异构图的元关系来参数化异构相互注意力、消息传递和传播步骤的权重矩阵，从而获取不同类型节点的表示。</p>
<a id="more"></a>
<p>Hu Z, Dong Y, Wang K, et al. Heterogeneous graph transformer[C]//Proceedings of The Web Conference 2020. 2020: 2704-2710.</p>
<h1><span id="方法介绍">方法介绍</span><a href="#方法介绍" class="header-anchor"> </a></h1>
<h2><span id="网络聚合算子">网络聚合算子</span><a href="#网络聚合算子" class="header-anchor"> </a></h2>
<h3><span id="总体结构">总体结构</span><a href="#总体结构" class="header-anchor"> </a></h3>
<p>输入一个异构网络，HGT利用所有节点对，(源节点 s，关系类型 e，目标节点 t )，其目标是汇聚目标节点t的各个源节点s的上下文表示信息，计算出t的表示。分为3个部分：Heterogeneous Mutual Attention，Heterogeneous Message Passing ， Target-Specific Aggregation
<img src="https://img.blog.tianle.me/image/20210612/1.jpg" alt></p>
<ul>
<li><strong>Attention</strong>： 计算每一个源节点s相对于目标节点t的重要性</li>
<li><strong>Message</strong>：抽取源节点s的信息</li>
<li><strong>Aggregate</strong>：聚合目标节点每一个源节点的信息</li>
</ul>
<h3><span id="步骤一heterogeneous-mutual-attention">步骤一：Heterogeneous Mutual Attention</span><a href="#步骤一heterogeneous-mutual-attention" class="header-anchor"> </a></h3>
<ul>
<li>首先，计算目标节点t 和 源节点s 的 mutual attention。</li>
</ul>
<p><img src="https://img.blog.tianle.me/image/20210612/2.jpg" alt></p>
<ul>
<li>与 Transformer 核心区别是，Transformer对所有的word都用了同一个 projections ，而HGT对每一种边类型（meta relation）都使用了不同的 projection weights.</li>
</ul>
<h3><span id="步骤二heterogeneous-message-passing">步骤二：Heterogeneous Message Passing</span><a href="#步骤二heterogeneous-message-passing" class="header-anchor"> </a></h3>
<ul>
<li>将信息从源节点传递到目标节点，同时在消息传递过程中加入边的元关系，以处理不同类型的节点和边的分布差异。</li>
</ul>
<p><img src="https://img.blog.tianle.me/image/20210612/3.jpg" alt></p>
<h3><span id="步骤三target-specific-aggregation">步骤三：Target-Specific Aggregation</span><a href="#步骤三target-specific-aggregation" class="header-anchor"> </a></h3>
<ul>
<li>这一过程将以上的异构相互注意力Attention和异构信息Message进行Product再Add，从本质来看，这个操作的目的是将异构注意力和消息从源节点聚合到目标节点。</li>
</ul>
<p><img src="https://img.blog.tianle.me/image/20210612/4.jpg" alt></p>
<ul>
<li>然后上面得到的结果经过一个激活层，再做线性变换并做一个残差连接：</li>
</ul>
<p><img src="https://img.blog.tianle.me/image/20210612/5.jpg" alt></p>
<h2><span id="mini-bach子图采样-hgsampling">mini-bach子图采样 HGSampling</span><a href="#mini-bach子图采样-hgsampling" class="header-anchor"> </a></h2>
<p>为了适应大规模网络，必须要对网络进行采样。如果不采样的话，就需要把整个图塞到GPU里面去计算，因此大规模网络是不适用的。本人尝试使用了DGL框架的HGT方法，在1080Ti的GPU上，不使用图采样，仅能够支持万级别的节点和几十万条边的网络规模，再往大，显存就不够用了。</p>
<p>此论文提出一种适用于异构图的子图采样方法HGSampling，该方法，1、保证每一种类型的节点和边都有相似的数量，2、保证采样后的子图是稠密的，从而达到最小化的信息损失和减少采样带来的偏差。</p>
<p>算法1展示了采样的主过程，其主要思想是每个节点类型τ保留一个单独的节点Budget B[τ]，使用重要性采样策略对每种类型采样相同数量的节点。当某一节点t已经被采样，我们将它的所有邻居加入预备采样集合中（算法2），使用归一化的度数去计算采样概率，类似于随机游走。</p>
<p><img src="https://img.blog.tianle.me/image/20210612/6.jpg" alt>
<img src="https://img.blog.tianle.me/image/20210612/7.jpg" alt></p>
]]></content>
      <categories>
        <category>研究</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>网络表示学习</tag>
        <tag>Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>flask_python web框架</title>
    <url>/2020/09/05/flask-python-web/</url>
    <content><![CDATA[<p>自从好久没写Java web之后，脑子只有一个印象，对于搭建一个简单站点，使用现成的SSM框架，应该很快就能搞定，但是殊不知，其中的环境配置、包依赖、数据库等配置如果不熟悉会非常麻烦。折腾了我n个小时，还没搞定。随后放弃。由于目前多用Python开发，转念一想，要不试试Python。事实证明，我的决策是正确的，从接触学习，到完成开发，总共耗时也不到3小时。</p>
<a id="more"></a>
<p>未完待续。。。。</p>
]]></content>
      <categories>
        <category>应用开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub福利HNS空投白嫖5000K</title>
    <url>/2020/03/14/hns-airdrop/</url>
    <content><![CDATA[<p>对于白嫖这件事，我一直都深表怀疑，况且还是价值几千的生意。但这一次突破了我的认知，也让我进入了币圈这个坑。</p>
<a id="more"></a>
<h2><span id="起因">起因</span><a href="#起因" class="header-anchor"> </a></h2>
<p>几天前在和同事吃饭的路上，猛然得知可以通过github白嫖比特币，回到工位上赶紧百度看看是怎么回事，原来这个在一个月前就已经有了，得到币后分享了其他几个同学，他们也都已经知道，看来我的消息太闭塞。话不多说，开始正题吧。</p>
<h2><span id="条件">条件</span><a href="#条件" class="header-anchor"> </a></h2>
<p>先放官方链接：  <a href="https://www.namebase.io/airdrop" target="_blank" rel="noopener">Handshake Airdrop</a>  ~</p>
<p>1、Github 账号在 2019-02-04 的时候超过 15 个粉丝<br>
2、Github 在 2019-02-04 之前上传过 SSH 或者 PGP keys，并且私钥还能找到<br>
如果满足这两个条件，那么恭喜你5000k+大洋在向你招手</p>
<p>另外你的电脑上需要有 Node.js &gt;= 8.0.0 环境 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p>
<p>空投认证领币需要身份认证（我在网上找了一张驾驶证照片通过了，要不要用自己的自行判断哈）。提币卖钱需要实名认证、身份证号码及银行卡，两者要保持一致（比特币交易网站要求）</p>
<p>综上，涉及隐私的有 github ssh密钥 以及 个人实名信息，才能获得最终白花花的银子。如果没问题那么往下走。</p>
<p>准备就绪后开工吧~</p>
<h2><span id="申请">申请</span><a href="#申请" class="header-anchor"> </a></h2>
<p>1、下载项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/handshake-org/hs-airdrop.git</span><br></pre></td></tr></table></figure>
<p>2、安装依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd hs-airdrop &amp;&amp; npm install</span><br></pre></td></tr></table></figure>
<p>3、找到你的github密钥 和 生成钱包地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./bin/hs-airdrop &lt;path to key&gt; &lt;address&gt; &lt;fee&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;path to key&gt;</code> 密钥地址，<code>&lt;address&gt;</code> 钱包地址，<code>&lt;fee&gt;</code>矿工费率，网站推荐设置 0.010</p>
<p>钱包地址点击页面 <a href="https://www.namebase.io/airdrop" target="_blank" rel="noopener">https://www.namebase.io/airdrop</a> ，中的<br>
<img src="/img/20200314/1.png" alt="钱包地址"></p>
<p>4、大工告成<br>
如果顺利的话会生成一大堆文字，不用管里面是什么，拉到底部，找到这个关键词<strong>Base64</strong>，把下面的内容复制到网页的框框中，点击submit。</p>
<p><img src="/img/20200314/2.png" alt="复制内容"></p>
<p>PS：如果验证通过，这一步会下载内容，受限于国内网速，大家可以先下载好。放在自己的项目个人文件夹中，（linux环境下 <code>~/.hs-tree-data</code>目录）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/handshake-org/hs-tree-data.git</span><br></pre></td></tr></table></figure>
<p>PPS：如果很不幸看到这句话，那么说明你不在名单中，没法提币，再想想你的密钥吧。
<img src="/img/20200314/err.png" alt="err"></p>
<p>5、等待
成功后，页面显示<br>
<img src="/img/20200314/3.png" alt="成功"></p>
<p>约20小时之后 <a href="https://www.namebase.io/dashboard" target="_blank" rel="noopener">dashboard</a> 网站下面信息会变成这样，同时也会收到邮件。<br>
<img src="/img/20200314/5.png" alt="成功"></p>
<p>6、选择换成比特币<br>
如图，把HNS卖成比特币。（你可以等到汇率比较好的时候卖，能换到更多比特币）这是有风险的，比如我，正赶上经济危机、石油、股票、币圈 全部暴跌。。。。
<img src="/img/20200314/6.png" alt="卖币"><br>
钱包地址可以填比特币交易所的充币地址，我用的是 OKEx ，还有很多其他的，比如 火币、币安 ，这个大家自己考虑哈。</p>
<p>交易所收到币后，在法币交易模块，把比特币卖出。具体参考交易网站的说明，会需要实名认证。</p>
<p>收钱、放币。流程结束。</p>
<h2><span id="最后">最后</span><a href="#最后" class="header-anchor"> </a></h2>
<p>好好写代码，机会是给又准备的人~~</p>
<p>经济危机。。。。我只提了一半的币、剩下的一半当纪念吧，或者等汇率好转的时候再卖。</p>
]]></content>
      <categories>
        <category>应用开发</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>福利</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习学习笔记</title>
    <url>/2020/01/28/dlnote/</url>
    <content><![CDATA[<h2><span id="基础知识">基础知识</span><a href="#基础知识" class="header-anchor"> </a></h2>
<p><strong>模型容量</strong> VC维度量二元分类器的容量。VC维定义为该分类器能够分类的训练样本的最大数目。统计学习理论中最重要的结论阐述了训练误差和泛化误差之间差异的上界随着模型容量增长而增长，但随着训练样本增多而下降。</p>
<p>机器学习研究的目标不是找一个通用学习算法或是绝对最好的学习算法，而是理解什么样的分布与人工智能获取经验的“真实世界”相关，以及什么样的学习算法在我们关注的数据生成分布上效果最好。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>这不是我的2019总结</title>
    <url>/2020/01/01/my2019/</url>
    <content><![CDATA[<p>自从开始写博客以后，在每年的这个时候都会回顾一下上一个整年的情况，记录自己的所思所想。<br>
首要要批评一下自己，不管什么原因，这一年写的文章真的是太少了。<br>
这一年，我毕业了，从此正式的步入社会大门。</p>
<a id="more"></a>
<h2><span id="工作">工作</span><a href="#工作" class="header-anchor"> </a></h2>
<p>毕业后，工作突然变成了生活中的大部分，一下子把许多时间都给挤掉了。也许是因为上班的时间太长了吧，正式入职后我比之前实习的时候更懒了，莫名的缺少了一种奋斗的力量，有时候就是不想干活，然后不知不觉的就开始摸鱼了。</p>
<p>拥抱变化果然是阿里的文化，从实习时候的天猫技术，变成了淘系技术，到现在营销平台直接没了，而我们合并到了淘系的算法中。环境在变，我们自己当然也要跟着变，同时也要有不变的地方。什么是不变的地方呢，简单的说是自己心中的梦想，这个不能变，自己所坚持的，如果这个一旦变了，很有可能会变得随波逐流了。关于拥抱变化，你要认识到它为什么变，他深层次的原因，做到“知其然知其所以然”。</p>
<p>要换主管了，在临走之前，和主管交流了一波：</p>
<p>作为一位技术人，尽快地确定自己想要的技术方向，并持续深究下去，在未来的一两年内最好不要发生变化。当决定技术方向的时候，和主管讨论，同时自己要想清楚原因，为什么要决定走这个方向。在学习中，做到宽度与深度并存，投入比例约3、7开。换一个方向，做出转变是非常痛苦的，看准了就不要再随意调整。既来之则安之，不要考虑太多的其他信息，做好自己手上的事，当达到一定境界的时候，再考虑其他，也有可能到了那个境界的时候，之前的问题也应刃而解了，否则可能会给自己带来不必要的迷茫。</p>
<p>另外，问问题要找对人，不要问他没经历过的事情。</p>
<h2><span id="学习">学习</span><a href="#学习" class="header-anchor"> </a></h2>
<p>学习不能停啊，从本科以后，很难再进行系统性的学习了，一是时间不够（也可能只是一个假象）。19年的学习量比18年更少了，一直想好好学学深度学习，但很遗憾。在年底的时候突发奇想，学习强化学习，顺便将强化学习应用到各个业务中。</p>
<h2><span id="玩">玩</span><a href="#玩" class="header-anchor"> </a></h2>
<p>这一年，依旧去了很多地方，应该是我历年之最了吧。云南（昆明、丽江、大理、香格里拉、泸沽湖），湖南（长沙、张家界、凤凰），大西北小环线，甘南，山西（平遥、壶口瀑布）。</p>
<p>在新的一年中期待去更多的地方。年假用起来~</p>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>ODPS Hive UDF UDAF UDTF 编写</title>
    <url>/2019/08/30/odpsudf/</url>
    <content><![CDATA[<p>之前一直以为udf是一个很高深很复杂的东西，但是经过实际编写后，发现它其实很简单。掌握这几个的特性，对写sql、抽样本、提特征会提升不少效率。</p>
<p>UDF为输入几个字段，返回一个值，比如<code>trim</code>，<code>length</code>等函数；UDAF为聚合函数，如<code>min</code>，<code>max</code>，而UDTF则是拆成多行的函数，例如<code>explode</code>函数。</p>
<a id="more"></a>
<h2><span id="udf">UDF</span><a href="#udf" class="header-anchor"> </a></h2>
<p>下面是阿里云官方文档提供的udf示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> odps.udf <span class="keyword">import</span> annotate</span><br><span class="line"><span class="meta">@annotate("bigint,bigint-&gt;bigint")</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPlus</span><span class="params">(object)</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span><span class="params">(self, arg0, arg1)</span>:</span></span><br><span class="line">       <span class="keyword">if</span> <span class="literal">None</span> <span class="keyword">in</span> (arg0, arg1):</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">       <span class="keyword">return</span> arg0 + arg1</span><br></pre></td></tr></table></figure>
<p>这里的<code>evaluate</code>函数可以传入多个参数（字段），返回一列。输入和输出参数的类型通过注解配置。</p>
<h2><span id="udaf">UDAF</span><a href="#udaf" class="header-anchor"> </a></h2>
<p>UDAF为聚合函数，配合<code>group by</code>使用<br>
下面展示的是求平均值函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@annotate('double-&gt;double')</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Average</span><span class="params">(BaseUDAF)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new_buffer</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iterate</span><span class="params">(self, buffer, number)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> number <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            buffer[<span class="number">0</span>] += number</span><br><span class="line">            buffer[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, buffer, pbuffer)</span>:</span></span><br><span class="line">        buffer[<span class="number">0</span>] += pbuffer[<span class="number">0</span>]</span><br><span class="line">        buffer[<span class="number">1</span>] += pbuffer[<span class="number">1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">terminate</span><span class="params">(self, buffer)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> buffer[<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">return</span> buffer[<span class="number">0</span>] / buffer[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><code>BaseUDAF.new_buffer()</code>：实现此方法返回聚合函数的中间值的<code>buffer</code>。<code>buffer</code>必须是<code>marshallableObject</code>（例如LIST、DICT），并且<code>buffer</code>的大小不应该随数据量递增。在极限情况下，<code>buffer Marshal</code>过后的大小不应该超过2MB。</p>
<p><code>BaseUDAF.iterate(buffer[, args, ...])</code>：实现此方法将<code>args</code>聚合到中间值<code>buffer</code>中。</p>
<p><code>BaseUDAF.merge(buffer, pbuffer)</code>：实现此方法将两个中间值<code>buffer</code>聚合到一起，即将<code>pbuffer</code>合并到<code>buffer</code>中。</p>
<p><code>BaseUDAF.terminate(buffer)</code>：实现此方法将中间值<code>buffer</code>转换为MaxCompute SQL的基本类型。</p>
<h2><span id="udtf">UDTF</span><a href="#udtf" class="header-anchor"> </a></h2>
<p>UDTF是用来拆成多行用的，常常和<code>LATERAL VIEW</code>一起用。<code>explode</code>就是常见的<code>UDTF</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> pageid, adid <span class="keyword">FROM</span> pageAds <span class="keyword">LATERAL</span> <span class="keyword">VIEW</span> <span class="keyword">explode</span>(adid_list) adTable <span class="keyword">AS</span> adid;</span><br></pre></td></tr></table></figure>
<p>样例代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="comment"># explode.py</span></span><br><span class="line"><span class="keyword">from</span> odps.udf <span class="keyword">import</span> annotate</span><br><span class="line"><span class="keyword">from</span> odps.udf <span class="keyword">import</span> BaseUDTF</span><br><span class="line"><span class="meta">@annotate('string -&gt; string')</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Explode</span><span class="params">(BaseUDTF)</span>:</span></span><br><span class="line">   <span class="string">"""将string按逗号分隔输出成多条记录。</span></span><br><span class="line"><span class="string">   """</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">       props = arg.split(<span class="string">','</span>)</span><br><span class="line">       <span class="keyword">for</span> p <span class="keyword">in</span> props:</span><br><span class="line">           self.forward(p)</span><br></pre></td></tr></table></figure>
<p>其中，每一条记录都会对应调用一次<code>process</code>，而每调用一次<code>self.forward()</code>就会生成一行记录。</p>
<h2><span id="感悟">感悟</span><a href="#感悟" class="header-anchor"> </a></h2>
<p>啊，最近写UDF真是写上瘾了，UDF大大扩展了SQL能力，写好一个UDF，可以减少很多复杂的SQL语句，同时还可以使代码变的更加易读。</p>
<h2><span id="参考资料">参考资料</span><a href="#参考资料" class="header-anchor"> </a></h2>
<p><a href="https://help.aliyun.com/document_detail/73359.html" target="_blank" rel="noopener">阿里云Python UDF文档</a></p>
]]></content>
      <categories>
        <category>应用开发</category>
      </categories>
      <tags>
        <tag>hive</tag>
        <tag>odps</tag>
        <tag>sql</tag>
        <tag>udf</tag>
      </tags>
  </entry>
  <entry>
    <title>西电latex模板问题（踩坑历程）</title>
    <url>/2019/05/23/xidian-latex/</url>
    <content><![CDATA[<p>众所周知，Latex编译工具可以让我们专注于写作本身，而不用在排版与格式上花费过多的时间。出于此考虑，在本次毕设中我采用了校研究生院提供的Latex模板进行毕设写作，其中遇到了不少坑，现记录如下。</p>
<a id="more"></a>
<h3><span id="前期准备">前期准备</span><a href="#前期准备" class="header-anchor"> </a></h3>
<p>学校官方模板可以在研究生院中下载，包含格式要求和word、latex模板（<a href="https://gr.xidian.edu.cn/info/1047/5086.htm" target="_blank" rel="noopener">专硕材料</a>、<a href="https://gr.xidian.edu.cn/info/1047/5087.htm" target="_blank" rel="noopener">学硕材料</a>）。</p>
<p>下载Ctex编译</p>
<h3><span id="踩坑历程">踩坑历程</span><a href="#踩坑历程" class="header-anchor"> </a></h3>
<h4><span id="subfigure冲突">subfigure冲突</span><a href="#subfigure冲突" class="header-anchor"> </a></h4>
<p>文中采用subfigure宏包进行多个子图合并时，会出现冲突，导致无法编译。解决方法为使用其他宏包替代subfigure，或者修改模板。<br>
XDUthesis.cls文件第57行修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\RequirePackage[titles,subfigure]&#123;tocloft&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="中文复制乱码">中文复制乱码</span><a href="#中文复制乱码" class="header-anchor"> </a></h4>
<p>盲审提交pdf版时，系统解析会出现乱码。可能是字符集的问题。解决办法是添加宏包ccmap<br>
templet.tex文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\usepackage&#123;ccmap&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="符号及缩略语符号对齐">符号及缩略语符号对齐</span><a href="#符号及缩略语符号对齐" class="header-anchor"> </a></h4>
<p>使用\makebox替代原来的\hspace进行快速对齐</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% \item 缩略语\hspace&#123;6em&#125;英文全称\hspace&#123;6em&#125;中文对照</span><br><span class="line">\item \makebox[8em][l]&#123;缩略语&#125; \makebox[14em][l]&#123;英文全称&#125; \makebox[14em][l]&#123;中文对照&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="参考文献引用上标">参考文献引用上标</span><a href="#参考文献引用上标" class="header-anchor"> </a></h4>
<p>模板中的引用没有上标。<br>
templet.tex文件<br>
在<code>\begin{document}</code>之前添加如下语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\newcommand&#123;\upcite&#125;[1]&#123;\textsuperscript&#123;\textsuperscript&#123;\cite&#123;#1&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="三级标题加粗与缩进">三级标题加粗与缩进</span><a href="#三级标题加粗与缩进" class="header-anchor"> </a></h4>
<p>XDUthesis.cls文件第251行subsection部分修改为<br>
format中添加\XDU@bold</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">format=&#123;\raggedright\XDU@bold\XDU@font@st\XDU@font@zihao&#123;4&#125;&#125;,</span><br></pre></td></tr></table></figure>
<p>indent从2em改为1.74636175em，或者改成24pt</p>
<p>完成修改后，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%% subsection</span><br><span class="line">\CTEXsetup[name=&#123;,&#125;,</span><br><span class="line">           number=&#123;\thesubsection&#125;,</span><br><span class="line">           format=&#123;\raggedright\XDU@bold\XDU@font@st\XDU@font@zihao&#123;4&#125;&#125;,</span><br><span class="line">           nameformat=&#123;&#125;,</span><br><span class="line">           numberformat=&#123;&#125;,</span><br><span class="line">           aftername=&#123;\quad&#125;,</span><br><span class="line">           titleformat=&#123;&#125;,</span><br><span class="line">           beforeskip=&#123;12pt plus 0pt minus 0pt&#125;,</span><br><span class="line">           afterskip=&#123;6pt&#125;,</span><br><span class="line">           indent=&#123;24pt&#125;]&#123;subsection&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="插图与表格索引间空格">插图与表格索引间空格</span><a href="#插图与表格索引间空格" class="header-anchor"> </a></h4>
<p>在\begin{document}前加上以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\newcommand*&#123;\noaddvspace&#125;&#123;\renewcommand*&#123;\addvspace&#125;[1]&#123;&#125;&#125;</span><br><span class="line">\addtocontents&#123;lof&#125;&#123;\protect\noaddvspace&#125;</span><br><span class="line">\addtocontents&#123;lot&#125;&#123;\protect\noaddvspace&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="大工告成">大工告成</span><a href="#大工告成" class="header-anchor"> </a></h3>
<p>附上完成修改后的西电模板配置文件<code>XDUthesis.cls</code>，大家可以直接下载替换。<br>
<a href="http://free.tianle.me/image/20190523/XDUthesis.cls" target="_blank" rel="noopener">点我下载XDUthesis.cls</a></p>
<h3><span id="参考">参考</span><a href="#参考" class="header-anchor"> </a></h3>
<p><a href="https://blog.csdn.net/qq_26023575/article/details/79458115" target="_blank" rel="noopener">西电硕士论文latex使用说明</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>西电</tag>
        <tag>latex</tag>
        <tag>模板</tag>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title>聚类算法中的数据预处理</title>
    <url>/2019/05/14/prepare-data-clustering/</url>
    <content><![CDATA[<p>在一般的机器学习任务中，已经有很多的数据预处理方法。本文要介绍的数据预处理方法是针对聚类算法。</p>
<p>在聚类中，通常将样本的所有特征数据组合成一个数值，然后计算两个样本之间的相似性。组合数据要求不同的特征具有相同的量纲。本文将讨论如何规范化、转换和创建分位数（normalizing, transforming, and creating quantiles），并讨论为什么分位数是转换任何数据分布的最佳默认选择。有了默认选项，就可以在不检查数据分布的情况下转换数据。</p>
<blockquote>
<p>本文主要内容翻译自<a href="https://developers.google.cn/machine-learning/clustering/prepare-data" target="_blank" rel="noopener">谷歌机器学习教程Clustering in Machine Learning-PrepareData</a></p>
</blockquote>
<a id="more"></a>
<h2><span id="规范化数据-normalizing-data">规范化数据 Normalizing Data</span><a href="#规范化数据-normalizing-data" class="header-anchor"> </a></h2>
<p>通过规范化数据，可以将多种特征转换为相同的量纲。特别是，规范化（normalizing）非常适合处理最常见的数据分布，即高斯分布。与分位数相比，规范化对数据量的要求更低。通过计算z-score对数据进行规范化，如下所示：</p>
$$\begin{array}{*{20}{c}}
  {x' = (x - \mu )/\sigma } \\ 
  {\mu  = {\text{mean}}} \\ 
  {\sigma  = {\text{standard deviation}}} 
\end{array}$$ 
<p>让我们看看数据在标准化前后相似性变化的例子。在图1中发现红色与蓝色更相似，而不是黄色。这是因为，x轴和y轴上他们数据特征的量纲不同。因此，直接观察到的相似性可能是未经缩放的。使用z-score进行规范化后，所有特征具有相同的尺度。这时你会发现红色实际上更像黄色。因此，在对数据进行规范化之后，可以更准确地计算相似性。</p>
<p><img src="//img.tianle.me/image/20190514/NormalizeData.png" alt><br>
图1:规范化前后的特征数据比较。</p>
<p>综上所述，当数据有如下之一情况时，推荐使用规范化：</p>
<ol>
<li>数据服从高斯分布</li>
<li>缺少足够的数据来创建分位数</li>
</ol>
<h2><span id="log转换">Log转换</span><a href="#log转换" class="header-anchor"> </a></h2>
<p>当数据分布表现为长尾分布时，如图所示，红点看起来与黄点更加相似。
<img src="//img.tianle.me/image/20190514/LeftSkew.png" alt><br>
图2：幂率分布</p>
<p>我们对图2幂率分布的数据应用log转换，让数据分布变得更加平滑。结果如图3所示，红色目前与蓝色更相似。</p>
<p><img src="//img.tianle.me/image/20190514/NormalDistribution.png" alt><br>
图3：变化后的正态分布</p>
<h2><span id="分位数">分位数</span><a href="#分位数" class="header-anchor"> </a></h2>
<p>规范化和log转换依赖于特定的数据分布。如果数据不符合高斯分布或幂律分布怎么办，是否有适用于任何分布的数据预处理方法。</p>
<p>尝试对如下分布进行预处理<br>
<img src="//img.tianle.me/image/20190514/Preprocess.png" alt><br>
图4：无法归类的数据分布</p>
<p>直观地说，如果两个样本之间只有少数几个样本，那么无论它们的值如何，这两个样本是相似的。相反，如果这两个样本之间有很多个其他样本，那么这两个样本就不那么相似了。因此，两个样本之间的相似性随着样本间的样本数量的增加而减少。</p>
<p>如果对数据进行规范化（normalizing）只会复制数据分布，因为规范化是一个线性变换。应用log转换也不能反映相似性的原理，如图5所示。
<img src="//img.tianle.me/image/20190514/LogTransform.png" alt><br>
图5：对数据分布进行log转换</p>
<p>将数据划分为不同的区间，每个区间包含相同数量的样本。这些区间的边界称为分位数。</p>
<p>执行以下步骤将数据转换为分位数:</p>
<ol>
<li>确定间隔的数量。</li>
<li>定义区间，使每个区间具有相同数量的样本。</li>
<li>用样本所在区间的索引替代原先的样本值。</li>
<li>将索引值缩放到[0,1]，使索引与其他特征的数据范围相同。</li>
</ol>
<p><img src="//img.tianle.me/image/20190514/Quantize.png" alt><br>
图6：使用分位数转换后的数据分布</p>
<p>将数据转换为分位数后，两个样本之间的相似性与这两个样本之间的样本数量成反比。在数学上，x是数据集中的任意一个样本：</p>
$$sim(A,B) \approx 1 - |{\text{prob}}[x > A] - {\text{prob}}[x > B]|$$ 
$$sim(A,B) \approx 1 - |{\text{quantile}}(A) - {\text{quantile}}(B)|$$ 
<p>分位数是转换数据的最佳默认选择。然而，要建立可靠的底层数据分布的分位数指标，需要大量数据支撑。以经验来说，要建立$n$个分位数指标，至少需要$10n$个样本。如果没有足够的数据，请仍旧使用标准化（normalization）。</p>
<p>注意：
对于如下数据分布，应当使用分位数处理，因为它不属于幂率分布，也不属于某个标准的数据分布形式<br>
<img src="//img.tianle.me/image/20190514/Distribution_Processing_B.png" alt></p>
<h2><span id="参考">参考</span><a href="#参考" class="header-anchor"> </a></h2>
<p>本文主要内容翻译自<a href="https://developers.google.cn/machine-learning/clustering/prepare-data" target="_blank" rel="noopener">谷歌机器学习教程Clustering in Machine Learning-PrepareData</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>聚类</tag>
        <tag>机器学习</tag>
        <tag>数据挖掘</tag>
        <tag>数据预处理</tag>
        <tag>归一化</tag>
      </tags>
  </entry>
  <entry>
    <title>使用wget下载jdk</title>
    <url>/2019/05/12/donwload-jdk/</url>
    <content><![CDATA[<p>服务器需要安装oracle jdk，但是目前找到的下载网站只有oracle的官网，下载的时候需要先点击接受协议，然后才能下载。</p>
<a id="more"></a>
<p><img src="//img.tianle.me/image/20190512/1.png" alt></p>
<p>我们尝试直接复制下载链接，然后使用 <code>wget url</code> 发现服务器报错无法开始下载。</p>
<p><img src="//img.tianle.me/image/20190512/3.png" alt></p>
<h3><span id="解决方法">解决方法</span><a href="#解决方法" class="header-anchor"> </a></h3>
<p>接受协议后，打开浏览器的调试窗口（<code>F12</code>），选择网络tab，点击要下载的jdk类型，观察浏览器调试窗口显示的信息，复制如下图所示的<code>url</code>作为<code>wget</code>命令的地址进行下载。</p>
<p><img src="//img.tianle.me/image/20190512/2.png" alt></p>
<h3><span id="参考资料">参考资料</span><a href="#参考资料" class="header-anchor"> </a></h3>
<p><a href="https://blog.51cto.com/kingstar/1750513" target="_blank" rel="noopener">解决 Linux 终端 wget 命令下载jdk的问题,jdk在linux下的配置问题</a></p>
]]></content>
      <categories>
        <category>应用开发</category>
      </categories>
      <tags>
        <tag>wget</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive小技巧及优化</title>
    <url>/2019/02/12/HiveAcrobatics/</url>
    <content><![CDATA[<p>总结一下平时遇到的SQL问题，以及对应的解决办法。</p>
<a id="more"></a>
<h2><span id="排除某几列查询">排除某几列查询</span><a href="#排除某几列查询" class="header-anchor"> </a></h2>
<p>查询除了ds 和 hr 之外的所有列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`(ds|hr)?+.+`</span> <span class="keyword">FROM</span> sales</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Select#LanguageManualSelect-REGEXColumnSpecification" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Select#LanguageManualSelect-REGEXColumnSpecification</a></p>
</blockquote>
<h2><span id="修改表生命周期odps">修改表生命周期(ODPS)</span><a href="#修改表生命周期odps" class="header-anchor"> </a></h2>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">SET</span> lifecycle <span class="keyword">days</span>;</span><br></pre></td></tr></table></figure>
<h2><span id="正则匹配">正则匹配</span><a href="#正则匹配" class="header-anchor"> </a></h2>
<p>匹配除“*n*”之外的任何单个字符。要匹配包括“*n*”在内的任何字符，请使用像“(.|\n)”的模式。</p>
<h2><span id="解析执行过程">解析执行过程</span><a href="#解析执行过程" class="header-anchor"> </a></h2>
<pre><code class="language-sql">explain  
</code></pre>
<h2><span id="效率优化">效率优化</span><a href="#效率优化" class="header-anchor"> </a></h2>
<h3><span id="数据倾斜">数据倾斜</span><a href="#数据倾斜" class="header-anchor"> </a></h3>
<p><code>count(distinct )</code> 效率低下，数据倾斜，改用 <code>group by</code> 优化</p>
<h2><span id="遇到的坑">遇到的坑</span><a href="#遇到的坑" class="header-anchor"> </a></h2>
<h3><span id="查询空值">查询空值</span><a href="#查询空值" class="header-anchor"> </a></h3>
<p>例 字段 <code>A</code> 有三种取值 <code>Y</code>, <code>N</code>, <code>null</code>（空值）<br>
我想取<code>N</code> 与 <code>null</code> ，如果查询条件为 <code>&lt;&gt; ‘Y’</code> ，是查不出<code>null</code>的<br>
应该这么写 <code>A &lt;&gt; ‘Y’ or A is null</code></p>
<h2><span id="其他">其他</span><a href="#其他" class="header-anchor"> </a></h2>
<h3><span id="快速编辑">快速编辑</span><a href="#快速编辑" class="header-anchor"> </a></h3>
<p>vscode中<br>
选择多行<br>
option + shift + 鼠标左键</p>
<p>编辑每行的末尾或者开头<br>
使用正则表达式进行替换 开头 ^ ，末尾 $</p>
]]></content>
      <categories>
        <category>应用开发</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>开发</tag>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里实习感悟</title>
    <url>/2019/02/12/tmallReview/</url>
    <content><![CDATA[<p>刚在上一家公司实习完，休息一个多月左右，呼哧呼哧的又溜出去实习了。<br>
为什么只休息了一个多月呢，一是想体验天猫双十一，二是感受氛围帮助自己决策校招offer。前者是主要原因，后者是主要目的。</p>
<a id="more"></a>
<p>阿里是我心目中的公司，也一直想进BAT去体验它的技术氛围。此次实习虽然只有三个月，但是在这里依旧收获满满，让即将毕业的我对今后工作有一个初步的认知。在此也真心感谢一起工作的同事以及主管、HR，谢谢你们！</p>
<p><img src="//img.tianle.me/image/20190212/1.jpg" alt="实习照片1"><br>
入职第一天</p>
<h2><span id="对自己的要求">对自己的要求</span><a href="#对自己的要求" class="header-anchor"> </a></h2>
<p>在阿里，不同级别的要求是不一样的。P5要求是能独立完成上面交给你的任务，把这个点给做好；P6除了完成任务外，还要基于你的任务形成一个解决方案，做成一条线；P7则在P6的要求之上，考虑这个系统的架构，各个算法、功能怎么解决，搭建出一个完整框架，做成一个面；那么P8则是要对自己的所在领域有深刻的理解。当然从P7开始也要有团队管理的能力。自己做的工作好不好，对照上面的标准，想要晋升，请自我检验，看看有没有达到要求。</p>
<h2><span id="全局观">全局观</span><a href="#全局观" class="header-anchor"> </a></h2>
<p>在工作中，仅仅了解自己做的那方面是远远不够的，要有一个全局观，首先要知道自己这个组是做什么的，这个团队、这个部门是做什么的，再大一点，这个公司、这个集团。从微观到宏观，对整个大环境至少需要有个感知。在大公司中你可能是个拧螺丝的，这个比喻一点也没错，如果只知道完成手头工作， <s>那么恭喜你，</s> 你真的是一颗螺丝钉，你应当了解你做的东西在哪一部分用，对于现有系统有何作用或者改进。因此，你应该更加了解你做的东西的前因后果。</p>
<p><img src="//img.tianle.me/image/20190212/2.jpg" alt="实习照片2"><br>
天猫双十一</p>
<h2><span id="体系化">体系化</span><a href="#体系化" class="header-anchor"> </a></h2>
<p>目前你做的可能只是其中一小块，但是从点到线到面，如何从纵向从横向拓宽你的工作是一个需要思考的问题。这个算法在这个场景下可以用了，但是能不能稍加改进在另一个类似的场景中也可以应用呢？举个例子，最开始的算法可能是为某个商家设计的，当又新来了一个类似的需求后，能不能拓展到多个商家，再往上拓展，能不能在IP上应用，在行业上应用，多个IP，多个行业，甚至整个大盘呢。其次，他们间的关系是什么样的。</p>
<p>当然，这里说的体系化是有个前提的，如果这个需求时临时性的，遇到过一次后，后面不可能再遇到，那么就事论事，把这个需求搞定即可，没必要做成一个庞大复杂完善的功能。</p>
<p><img src="//img.tianle.me/image/20190212/3.jpg" alt="实习照片3"><br>
天猫双十一</p>
<h2><span id="多思考">多思考</span><a href="#多思考" class="header-anchor"> </a></h2>
<p>因此在工作中要多加思考，不能埋头苦干。给你一个需求时，一定要了解背景和目标。有时候可能连业务方自己也不知道想要什么，因此我们要理清楚需求的深层目的，遇到不懂，不清楚的多和业务方交流。</p>
<p>老大交给你任务时，不要他说怎么做，你就怎么做，得要有自己的理解。还有哇，要理清楚你任务的前后关系，项目的背景、目标，不清楚就问。</p>
<p><img src="//img.tianle.me/image/20190212/4.jpg" alt="实习照片4"><br>
天猫双十一</p>
<h2><span id="多学习">多学习</span><a href="#多学习" class="header-anchor"> </a></h2>
<p>互联网行业、信息科技的发展是迅猛的，有可能现在很火的东西过几年就不火了，技术换代。只要我们的title上还有工程师这几个字，无论到了那个级别，都不能丢掉技术。</p>
<p>无论在之前的网易还是现在的阿里，给我的感觉是，大家都一直在努力学习，从未停下。在我们组，主要还是通过业务来驱动技术的发展，遇到一个业务时，在内网ATA、外网、论文等各种渠道找有没有相似的解法，考虑如何应用到项目中。除此之外，每天、每周抽出时间学习新知识也是必不可以少的，时刻跟进行业的最新动态。</p>
<p>我印象比较深的是组里的一个女孩子，她是从运营转过来的，而我们这边数据和算法比较多，不是很熟悉。为了能尽快上手，首先自己看书，看文章研究，看到同事有空的，就过去请教，既可以问他做过的东西，也可以问现在遇到的问题。</p>
<p>最可怕的是，比你厉害的人，还比你努力。在阿里，真的是这样。我主管特别的忙，白天开会，晚上还要写代码，做PPT，同时还得补充新知识，下班走的也比我们晚。不只是业务、工作上的，其他技能也是杠杠的，社科类的知识讲起来一套一套，从微观到宏观，从经济学谈到博弈论、哲学、系统论，把我听的愣愣的。</p>
<p><img src="//img.tianle.me/image/20190212/5.jpg" alt="实习照片5"><br>
天猫双十一</p>
<h2><span id="多问">多问</span><a href="#多问" class="header-anchor"> </a></h2>
<p>在实习生百技中，大佬和我们说：新人入职最怕的就是没有问题，有很多问题可能不是你的原因，而是由于本身内部系统造成的，外面也查不到。所以不要害怕自己的问题有多蠢，大胆地问，可以问师兄、同事以及主管。特别是师兄，他专门是给你解答问题的，这是他的职责，要是他不答，那么就是他失职了。</p>
<p>不要怕打扰到对方，总之多问。</p>
<p><img src="//img.tianle.me/image/20190212/6.jpg" alt="实习照片6"><br>
双十一快递爆仓</p>
<h2><span id="多总结">多总结</span><a href="#多总结" class="header-anchor"> </a></h2>
<p>阿里让我特别佩服的一点是这里的技术沉淀。不说每年的大促双十一结束后，都会有各种新鲜的技术沉淀下来，在每个组中，如果有好的技术或者想法，都会总结出来，供后人参考。</p>
<p><img src="//img.tianle.me/image/20190212/7.jpg" alt="实习照片7"><br>
雪景</p>
<h2><span id="关于汇报">关于汇报</span><a href="#关于汇报" class="header-anchor"> </a></h2>
<p>在实习期间，有幸经历了一次述职汇报，看了看组内成员都做了什么，了解了述职应该怎么汇报，虽然我没有讲，但是也有一个切身体会。</p>
<p>整体逻辑：总分总、结构清晰</p>
<p>别人组做过的，差不多的，先去调研，找到差异点，要有自己的特色（如果做不过别人的，还是不要做了。。。）</p>
<p>简要清楚的讲明白背景（因为别人没做过，不知道是什么样子的）、难点，有哪些现有的方法，你怎么解决的，效果</p>
<p>讲效果的时候，要体现出是你的原因导致的效果提升</p>
<p>不要讲太细节的东西、突出你的创新</p>
<p><img src="//img.tianle.me/image/20190212/8.jpg" alt="实习照片8"><br>
雪景</p>
<h2><span id="结语">结语</span><a href="#结语" class="header-anchor"> </a></h2>
<p>先写到这吧，希望今年正式入职后能够，快乐工作，认真生活~</p>
<p><img src="//img.tianle.me/image/20190212/9.jpg" alt="实习照片9"><br>
晚上下班</p>
<p><img src="//img.tianle.me/image/20190212/10.jpg" alt="实习照片10"><br>
消防演习</p>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>小结</tag>
        <tag>实习</tag>
        <tag>阿里</tag>
        <tag>天猫</tag>
      </tags>
  </entry>
  <entry>
    <title>技·算未来内部算法大赛总结</title>
    <url>/2019/01/11/algorithm-competition-review/</url>
    <content><![CDATA[<p>这一次算法总结，我要讲的不是关于比赛算法上的，而是赛前、赛中 以及 赛后的一些感受。</p>
<a id="more"></a>
<h2><span id="开篇">开篇</span><a href="#开篇" class="header-anchor"> </a></h2>
<p>来阿里实习，恰好赶上了一年一度的技算未来算法大赛，我们团队一商量就报了名。由于这次比赛组队的规则是每队至多有一名算法，至少一名工程，因此我作为外援的身份的参加。<br>
本次大赛的题目是预测2018年双十一每个sku的销量，给了2016年到2018年9月30号的数据，分别为商品维表，包括sku_id，item_id，类目，店铺等信息；商品每日销量，收藏量等信息。</p>
<h2><span id="开工">开工</span><a href="#开工" class="header-anchor"> </a></h2>
<p>在刚开始的时候，平时日常业务多，因此团队热情并不是很高。我和另外一位同学参加过天池比赛，自然而然地开始负责整个比赛的流程了。<br>
一起工作奋斗的日子很开心，平时要上班，比赛也只能抽空做。讨论了一下，发现时间很紧，我们把元旦的假期也拿来做比赛了，元旦期间我们还开了场视频会议，把要做的特征列了一下。随后，在接下来的周末，特别是第一次提交测评的前一天晚上，我们又狠狠地奋战了一番。</p>
<h2><span id="初赛测评">初赛测评</span><a href="#初赛测评" class="header-anchor"> </a></h2>
<p>匆匆忙忙的刚上了第一次测评，出来的结果大吃一惊，一共30多个队提交，结果我们排到了20，测评分数也是一塌糊涂。突然有种让我怀疑人生的感觉。当旁边的同事问到我们多少名的时候，我们都不好意思回答。。。。回头赶紧找原因。<br>
噫，由于自己的蜜汁自信，时间赶，又加上自己的懒惰，只是简单的做了交叉验证，来不及调参，也没有加上与线上一致的评测指标，还有是第一次提交也不知道对手的情况，导致了这么惨的分数。<br>
紧接着在当天晚上的第二次提交时，我加上了上述指标，进一步调参后，线上效果得到提升，但是排名还是没有变化，总的提交人数变多了，终于没有处于倒数的状态。有趣的是，在我们这个算法大团队中，共有三个队参加，没想到我们在团队中的成绩竟然是最好的，这又给了我们极大的信心，也告诉我们不能轻敌。</p>
<h2><span id="决赛">决赛</span><a href="#决赛" class="header-anchor"> </a></h2>
<p>……<br>
时间隔的比较久，有些细节已经忘了，只记得在提交决赛测评结果的前一天晚上，我们还在讨论新特征，提新特征。修改了部分逻辑，考虑到第二天的资源可能会比较紧张，这一天晚上，大家都没有怎么休息，下班回家已经是一两点了，回去之后，又是轮流起床接力干活。<br>
决赛现场进行，我们团队是最整齐的，集体穿上了双十一战袍。决赛当天，集群资源真的是紧张，按照计划的策略，在服务器上跑特征工程，简单训练模型，选取TOP特征，下载数据到本地再进行调参训练。<br>
问题来了，当我们下载了结果时，竟然发现样本数与提交样本不一致，然后又马上到截止时间了。快速检查一下，发现出现了大量重复数据，时间紧，拍脑袋，重复的数据求平均！<br>
匆匆忙忙交了结果，没想到最后测评竟然是负分！！</p>
<h2><span id="总结">总结</span><a href="#总结" class="header-anchor"> </a></h2>
<p>在这次比赛中出现了这么严重的错误，回过头来分析。<br>
敬畏线上、敬畏代码，对写的每一行代码负责。在提交、发布时做好充分的线下测试，对中间的关键环节进行验证，比如数据的行数、列数，做过的操作、运算，看看是否和想象中的一致，有没有bad case。千万不能因为时间赶，而放弃了测试环节，这是最危险的，本来时间就紧，中间匆匆忙忙，出错的概率会大很多，所以一定要做好检查，如果实在来不及，可以考虑是不是和业务方交流一下，数据还没出来，能否往后延一点呢。<br>
做好工时预估，给自己留足够的时间，正常完成时间是多少，当集群资源紧张时会不会造成延误。<br>
复制黏贴代码的时候一定要小心，一不留神，不是哪里复制错了，就是复制的东西忘记改了，小心再小心。<br>
当发现错误的时候，不能随便提交，一定要先做仔细检查。</p>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>随想</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>我的2018</title>
    <url>/2019/01/01/my2018/</url>
    <content><![CDATA[<p>先给自己打个分，7.5吧，总体过得还可以，算是完成了主要的目标。去年发生几件重要的事：第一次去互联网大厂实习，并拿到了满意的offer，秋招之路算是顺路。第二件，感情上则不是那么的顺利了。至于2019年，这可能是我最后的学生生活了（如果以后不读博的话），上半年最重要的是顺利毕业，其次，有时间多去外面玩一玩，毕竟工作后没有这么多的时间了。下半年，好好上班，平稳步入职场吧，另外生活与工作两者必不可少，提高效率少加班。</p>
<a id="more"></a>
<h2><span id="学习第一">学习第一</span><a href="#学习第一" class="header-anchor"> </a></h2>
<p>这一年学习最多，成长最快的应当属于前半年找实习的那会儿，那时候的目标非常明确，我要找一个好实习，基本上是天天刷题，看书，看博客，打比赛。嗯，有个明确的目标很重要。做项目，打比赛是我这段时间提高最快的方法，也就是说在项目中发现问题、解决问题。还有哇，要多多总结，在总结的时候相当于把知识又重新复习了一遍。在这里还要特别感谢我的老师，还有师兄，以及一起学习打比赛的兄弟<a href="https://github.com/altmanWang" target="_blank" rel="noopener">Altman</a>，一起奋斗的感觉真棒！最后收获的offer也不少，春招实习有：百度、网易、蘑菇街、携程、宇视科技、GE，秋季校招：阿里、网易、科大讯飞、华为。<br>
论文还是头大啊，那篇小论文已经被拒n次了，难受。</p>
<h2><span id="实习">实习</span><a href="#实习" class="header-anchor"> </a></h2>
<p>第一个收到满意offer的是百度，在此之前我一度怀疑自己，今年的算法火爆程度超过去年，怕是暑假实习没有着落。我还清楚的记得收offer的那天，我正在听阿里虾米的校园交流会，先是手机上收到百度的offer邮件，不过一分钟，hr的电话来了，那都是超过激动这个词来形容自己了，偷偷地溜出会议室跑去接offer call。offer的确认时间很短，在师兄的建议下，接受了offer，然后心里有了个底，接下来是不断的和hr往后拖入职时间，同时在催阿里的面试进度。有了这个offer后，信心大增，面试起来底气也足了。再后来就是网易的offer，本来让我去杭州面试，我是拒绝的，但是恰好有实验室的小伙伴一起，我们就商量了一下去杭州面试了，结局就是顺利收到offer。而我一直期待的阿里，则是在五轮面试下以失败告终，我想可能的原因是我投的部门算法岗不多，而我又不想做开发吧。话说，我找今年的实习，有不少公司都让我转开发，当我去了网易的实习的时候，我还在考虑是不是要转，有点知难而退的感觉。</p>
<h3><span id="网易人工智能">网易人工智能</span><a href="#网易人工智能" class="header-anchor"> </a></h3>
<p>在最后，我选择了网易，原因是今后大概率留在杭州，而百度大搜在北京，可能有种天生的习性不想去北京，想回家附近的原因吧。在offer选择的时候，也是纠结了好久，咨询了不少师兄师姐以及老师。<br>
在网易的时间，认识了一大波可爱的同事，还有一位同部门一起实习的妹子，正是他们才让我的实习时光变的丰富多彩。<br>
话说原本是想和我的一面面试官一起做游戏相关的算法，没想到鬼使神差的开始做考拉，同时也是这个原因，让我在校招面试天猫的时候一路顺风，在面试过程中几乎全程问考拉项目，基础题，算法题，编程题都是匆匆带过。两个部门的业务真的是太像了。<br>
考拉的加班比较多，可能电商或者互联网行业都是这样吧，我负责的是考拉黑卡会员拉新业务，具体的已经总结，在这里不展开讲了。要说的是这里的同事，以及我的主管，大家都特别好，对我也特别照顾。我实习结束的时候，带我的老大还特地请了两顿饭，后来回杭州办离职的时候，老大又特意召集了一波人吃了一顿，再后来，我入职阿里，回网易看看的时候，老大拉上了之前的小伙伴，又吃了一段。考拉那边也是，当我离职的时候，真的可以说是依依不舍，我们都是同行，希望后面有机会再一起共事吧。</p>
<h3><span id="阿里天猫技术">阿里天猫技术</span><a href="#阿里天猫技术" class="header-anchor"> </a></h3>
<p>多亏了超哥的鼎力推荐，让我顺利拿到天猫offer，梦想中的阿里。进入天猫第一个感觉就是平台大，不去不知道，一去吓一跳。真的是什么都有，而且我最崇拜的就是这里的技术积累了，之前一直听说BAT的技术积累，现在才是真正的切身体会，在内网里面，可以说要什么文档有什么文档，要什么工具有什么工具，你遇到过的问题，基本上在你之前都有人遇到了。在ATA（内网技术站）上，你可以搜到各种各样的文章，有技术讲解、论文，而更多的是和阿里本身业务相关的各种工程，算法介绍。有了它，给你今后的业务提供了不少帮助。<br>
这里的压力感觉要比网易大了不少，网易老大重视你，这里遍地都是大佬，人也多，感觉自己也就是个平均水平，受到的关照自然少了。所以接下来要继续努力呀！哦，对了，遇到问题要多问，不要怕不好意思！不要怕打扰别人！没有问题才可怕！多问！多问！有问题就问！不要捂着不说！还要多思考！</p>
<h2><span id="情感">情感</span><a href="#情感" class="header-anchor"> </a></h2>
<p>哎，写这个篇章很难受。<br>
写在其他地方，略过吧。。。。。。</p>
<h2><span id="玩">玩</span><a href="#玩" class="header-anchor"> </a></h2>
<p>上半年在找实习，下半年在实习，都没有好好玩。去的城市倒不少，杭州、上海、武汉、石家庄、成都，但都是在实习的间隙中玩了几天。一直在奔波，希望在2019年，最后的学生时代，写完论文后，多出去玩玩吧。</p>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>猪场实习小结</title>
    <url>/2018/11/23/internshipSummary/</url>
    <content><![CDATA[<p>5月23号，来到网易报道，到现在差不多一个多月了。</p>
<a id="more"></a>
<ol>
<li>
<p>不要自己一个人埋头苦干，有问题就问，不要怕对方忙（当然也要看好时机），有时候你自己要搞好久，问一下，说不定别人一两句话的事情，或者几个操作就搞定了</p>
</li>
<li>
<p>多和你的师兄、老大讨论讨论，让他们了解你的想法，可以直接走过去和他们聊</p>
</li>
<li>
<p>工作的时候一定要保持积极向上的态度，而且一定要主动</p>
</li>
<li>
<p>老大给你安排的任务一定要做，如果你觉得坑，要给其他人说明白为什么这东西坑，然后寻求解决方案</p>
</li>
<li>
<p>数据分析的工作通常比较累、很花时间，而且做了很多的分析不一定会有结果，这是一个相对仔细的活，需要不段的切分维度去看，去对比，一步一步的精细化的分析，然后才能慢慢的得到一个结果</p>
</li>
<li>
<p>细致的理解业务逻辑，对特征提取、模型等都有非常重要的帮助</p>
</li>
<li>
<p>有时候复杂模型的效果不一定会比简单的规则差，但是当我们运用规则的时候，一定要对业务有着相当深入的理解</p>
</li>
<li>
<p>在初期的时候可以使用规则或者简单的模型做一个base line，然后再细致优化，一版一版不断迭代</p>
</li>
<li>
<p>勤做笔记，把一些常用的东西记下来</p>
</li>
<li>
<p>做的时候多积累技术、看看别人是怎么写的，学着点</p>
</li>
<li>
<p>线上的资源非常宝贵，最好不要轻易的将没有进行线下验证的结果直接放到线上做AB test，先做好线下的验证</p>
</li>
</ol>
<p>1、积极主动的工作态度<br>
2、多思考、善于提问<br>
3、效率、时间紧迫感<br>
2、总结、技术积累</p>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>小结</tag>
        <tag>实习</tag>
        <tag>网易</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习算法春招实习面试</title>
    <url>/2018/09/01/interviewSharing/</url>
    <content><![CDATA[<p>记录春招实习面试</p>
<a id="more"></a>
<h4><span id="426-微软-算法-一面-二面">4.26 微软 算法 一面 二面</span><a href="#426-微软-算法-一面-二面" class="header-anchor"> </a></h4>
<p>隔离外网ip怎么做<br>
基本上全是手写代码<br>
判断某个ip是否属于这个子网<br>
多个已经排好序的链表，找到其前k个最大的值<br>
两数之和为某值，leetcode原题<br>
快排<br>
年龄排序，时间复杂度为o(n)<br>
从多个服务器中，找到前k个最大值</p>
<h4><span id="425-阿里-hr面">4.25 阿里 hr面</span><a href="#425-阿里-hr面" class="header-anchor"> </a></h4>
<p>你想做算法还是工程，你是怎么看待的<br>
我说我还是想做算法，但是给我做工程也可以，毕竟算法要落地实现的<br>
讲一个对你影响最大的项目吧<br>
你有没有帮助过别人<br>
什么时候能来实习<br>
我和你的部门老大再沟通沟通</p>
<h4><span id="424-京东-算法-二面-挂">4.24 京东 算法 二面 挂</span><a href="#424-京东-算法-二面-挂" class="header-anchor"> </a></h4>
<p>你对京东有什么看法，为什么要投京东<br>
问项目<br>
xgb的原理</p>
<h4><span id="423-网易-offer-沟通">4.23 网易 offer 沟通</span><a href="#423-网易-offer-沟通" class="header-anchor"> </a></h4>
<p>给你发offer你还要考虑一下，还是马上确认<br>
什么时候能来<br>
讲了一下待遇<br>
有问题再联系</p>
<h4><span id="420-京东-算法-一面">4.20 京东 算法 一面</span><a href="#420-京东-算法-一面" class="header-anchor"> </a></h4>
<p>自我介绍完，先两道编程题，由于电话面试，讲思路即可<br>
求二叉树，每个节点下面包含其子节点的数目<br>
投骰子，每投一次根据其点数往前走k格，如点数2，往前走2格，求在在第n格的概率是多少<br>
说一下条件概率<br>
投影矩阵<br>
了解深度学习吗，讲一下cnn<br>
样本不平衡怎么办<br>
梯度消失怎么回事<br>
怎么防止过拟合<br>
随便讲一个机器学习算法<br>
讲一个你熟悉的项目<br>
有没有什么想问我的<br>
你是哪个部门的，能不能简单介绍一下<br>
实习可以留下来吗<br>
我的表现如何</p>
<h4><span id="418-蘑菇街-算法-hr面-三面">4.18 蘑菇街 算法 hr面 三面</span><a href="#418-蘑菇街-算法-hr面-三面" class="header-anchor"> </a></h4>
<p>评价一下你之前的面试表现<br>
老师或者你周围的人是如何评价你的<br>
评价一下你自己<br>
你觉得你在哪些地方可以改进<br>
你的求职标准有哪些<br>
你是如何看待大公司和小公司的<br>
你对职业方向有什么规划<br>
你面试了哪些公司，有哪些offer<br>
有没有什么想问我的<br>
问：我问实习转正流程是怎么样的，能不能转正<br>
问：实习的住房能解决吗</p>
<h4><span id="417-阿里零售通-算法-四面">4.17 阿里零售通 算法 四面</span><a href="#417-阿里零售通-算法-四面" class="header-anchor"> </a></h4>
<p>没有自我介绍<br>
先问我怎么看待算法与工程相结合的，你讲讲你的理解，比如对于分类问题，你分别从算法角度和工程角度讲讲<br>
他说你的理解就是给算法打下手啊，那这样还有人愿意做吗？<br>
没有讲项目，直接开始问Java<br>
你知道LinkedHashMap 和 HashMap吗，他们有什么区别<br>
LinkedHashMap可以做冷热分离吗？如何可以怎么做？<br>
说一说你的优势<br>
Spring MVC的安全问题<br>
知不知道Spring Security<br>
CSRF攻击<br>
数据库索引<br>
lock synchronized 区别<br>
堆和栈的区别，里面都存了什么东西<br>
程序计数器是什么，做什么用的<br>
垃圾回收有哪些算法<br>
在浏览器中输入http://www.taobao.com会发生什么动作<br>
tcp  、ip 是哪一层的<br>
用过哪些数据库<br>
分布式数据库用过没有<br>
负载均衡<br>
说一说volatile，在jvm中是怎么样的<br>
你未来的职业规划是怎么样的</p>
<h4><span id="416-蘑菇街-算法-二面">4.16 蘑菇街 算法 二面</span><a href="#416-蘑菇街-算法-二面" class="header-anchor"> </a></h4>
<p>自我介绍<br>
讲论文<br>
讲比赛<br>
问的特别细</p>
<p>有什么要问她的<br>
你们做什么的<br>
对于新人有没有培训或者交流</p>
<h4><span id="415-腾讯-基础研究-算法-一面">4.15 腾讯 基础研究 算法 一面</span><a href="#415-腾讯-基础研究-算法-一面" class="header-anchor"> </a></h4>
<p>自我介绍<br>
讲你的三个优点<br>
讲你的一个缺点<br>
介绍一个你的项目<br>
评价指标是什么<br>
你是怎么调参的，哪些参数比较重要<br>
你常用的机器学习算法有哪些<br>
面试官在草稿纸上画了一个图，其实就是 多目标优化问题里面的 非支配解，把所有的非支配解求出来</p>
<p>机器学习里面的偏差和方差有什么区别<br>
L1和L2有什么区别<br>
为什么L1能得到稀疏解</p>
<h4><span id="413-网易-hr面">4.13 网易 hr面</span><a href="#413-网易-hr面" class="header-anchor"> </a></h4>
<p>讲一讲你的比赛<br>
你的比赛有几个人参加，你是负责哪一块的，分工<br>
这么做会不会效率比较低呢<br>
时间怎么规划的<br>
针对这个比赛，你有没有做过计划<br>
有拿到其他公司的offer吗<br>
你以后想在哪里工作<br>
说说你了解的最新的技术<br>
讲一次和老师发生过冲突的事<br>
你觉得这件事情你有没有错<br>
简历上都是你成功的事，讲一次你失败的事</p>
<h4><span id="413-网易-算法-二面">4.13 网易 算法 二面</span><a href="#413-网易-算法-二面" class="header-anchor"> </a></h4>
<p>没有自我介绍<br>
说项目（但是比较少）<br>
面试官：你了解过时序问题吗，怎么处理<br>
面试官：时间序列问题和其他问题有什么区别<br>
面试官：给你一道题，你讲下思路，或者最好写一下代码<br>
一组时序的数据集，如<br>
1.10 A<br>
1.10 B<br>
1.10 C<br>
1.11 A<br>
1.11 B<br>
。。。。<br>
第一列为时间，第二列为key 表示这条数据的类别，其余列为特征<br>
时间窗口为3，你怎么把它进行划分，把这些数据拼接在一起。给你5分钟的时间</p>
<h4><span id="413-网易-算法-一面">4.13 网易 算法 一面</span><a href="#413-网易-算法-一面" class="header-anchor"> </a></h4>
<p>自我介绍<br>
说项目<br>
几个人做的，你负责那一部分<br>
模型融合<br>
lgb和xgb有什么区别<br>
xgb没有用直方图加速吗</p>
<h4><span id="412-蘑菇街-算法-一面">4.12 蘑菇街 算法 一面</span><a href="#412-蘑菇街-算法-一面" class="header-anchor"> </a></h4>
<p>自我介绍<br>
先做一道编程题：两个数组的交集<br>
nums1 = [1 ,2, 2, 1]  nums2 = [2, 2] 返回 [2] 结果去重</p>
<h4><span id="409-阿里零售通-算法-三面">4.09 阿里零售通 算法 三面</span><a href="#409-阿里零售通-算法-三面" class="header-anchor"> </a></h4>
<p>自我介绍<br>
挑一个最能表现你自己的项目讲讲吧<br>
你Java怎么样<br>
有没有接过项目<br>
你对我们部门有什么了解吗，有没有下过我们的app</p>
<h4><span id="408-阿里零售通-算法-二面">4.08 阿里零售通 算法 二面</span><a href="#408-阿里零售通-算法-二面" class="header-anchor"> </a></h4>
<p>编程题<br>
你觉得你的研究方向，在我们部门有什么应用呢？</p>
<h4><span id="330-阿里零售通-算法-一面">3.30 阿里零售通 算法 一面</span><a href="#330-阿里零售通-算法-一面" class="header-anchor"> </a></h4>
<p>自我介绍<br>
讲一讲你研究方向，做了什么，论文，突出创新点，你的工作<br>
PageRank<br>
天池比赛<br>
GBDT  和 XGB 比较<br>
怎么调参的<br>
你知道我们做什么的吗，之前是否有了解</p>
<h4><span id="326-百度算法-二面-get-offer">3.26 百度算法 二面 get offer</span><a href="#326-百度算法-二面-get-offer" class="header-anchor"> </a></h4>
<p>了解了一下基本情况，哪个学校，现在是硕士，做的什么东西，研究方向是啥，问我本科是学什么的，上过哪些计算机的课。<br>
论文<br>
数据哪里来的<br>
深度学习和机器学习有什么区别，应用场景有哪些，什么地方用深度学习，什么地方用机器学习，为什么这些场景深度学习的效果比较好。<br>
你得到的特征怎么用<br>
贪心算法，基于网络性质的算法，启发式算法，问这些算法有什么区别，为什么在这个场景下贪心算法比较好，贪心算法在哪些地方不好<br>
python，dict和list 有什么区别<br>
list是怎么实现的<br>
list的get是怎么实现的<br>
python 底层的list是用什么语言写的。<br>
场景题，数字键盘上有各个字母，按下一个数字键如 9673，打出单词word，不用考虑很大的单词量，设计一个算法？</p>
<h4><span id="322-百度算法面试-一面-实习-通过">3.22 百度算法面试 一面 实习 通过</span><a href="#322-百度算法面试-一面-实习-通过" class="header-anchor"> </a></h4>
<p>一面主要是基础知识，分为Java 基础知识、数据结构算法、编程题<br>
自我介绍<br>
讲了一堆项目和论文，但是本轮面试主要是基础知识，基本上没问，面试官问我简历上哪个比较突出讲一讲，我说了论文，结果他不感兴趣，直接开始问Java。<br>
redis<br>
String是否为java的基本数据类型<br>
基本数据类型有哪些<br>
面向对象怎么理解，多态、继承、封装， 怎么理解继承<br>
抽象类 和 接口 有什么区别<br>
Spring有什么特性<br>
最后3道编程题<br>
判断链表有没有环<br>
两链表的公共节点<br>
无序数组第k个数是多少</p>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>网易</tag>
        <tag>面试</tag>
        <tag>百度</tag>
        <tag>阿里</tag>
        <tag>腾讯</tag>
      </tags>
  </entry>
  <entry>
    <title>网易实习总结</title>
    <url>/2018/08/31/neteaseSummarize/</url>
    <content><![CDATA[<p>飞机晚点一个半小时，趁这个时间总结总结吧。</p>
<p>今天从公司离职，没想到老大竟然亲自送我，受到这么高的规格待遇，真是受宠若惊啊。</p>
<p>这次实习可谓是收获满满，一个是技术、二是业务，还有认识了一位可爱的妹子。</p>
<a id="more"></a>
<p>说到数据智能，这里要特别感谢带我入门的JN师兄和我的队友QX，从第一个京东金融的信贷需求预测开始，到最后的阿里妈妈广告点击，让我学到了最基本的数据类问题的通用套路。而现在的网易AI实习、考拉会员拉新项目，则让我学到了真实业务上的操作方式。</p>
<p>实际项目相对于比赛，我认为主要的区别有以下几点：</p>
<ol>
<li>实施方式多样，真实业务的最终目标可能很明确，但是达成这个目标的方式会有很多种，而且他们的效果也不尽相同，所以具体的实施方案就需要自己去想去尝试；</li>
<li>训练样本构造复杂，一般的数据竞赛都会提供比较”干净“的数据集，做少量的处理就可以直接用来训练，但是真实业务的训练样本需要自己构造，可以说对于电商来说，想要什么数据就有什么数据，而且不同的构造方式对最终的结果会有非常大的差异，怎么去构造一个训练集使得更贴近目标、更符合真实业务的数据分布，是需要不断地去推敲；</li>
<li>特征抽取复杂，除了抽数据之外，提特征也是一个相当重要的工作，首先数据仓库里面有各种类型的数据，得要自己不断去理解，知道自己想要什么，有什么，还得根据具体的业务，自己去构造特征，而且在构造特征的时候，还要看看它有哪些数据，它的数据是从哪里来的，怎么来的；</li>
<li>线上测试谨慎，线上的资源非常宝贵，把算法模型放到线上测的时候一定要在线下做好充分的准备，而且要考虑各种风险因素，比如用户的体验等等。不像比赛线下测一测有提高，就扔到线上提交。</li>
</ol>
<p>至于模型上的，由于我参与的较少，这里就不多说了。</p>
<p>技术</p>
<p>这段实习体验下来，接触最多的应该是数据ETL的工作，而在算法模型上的时间非常非常少。
此外还了解了不少数据仓库的概念，比如说是什么东西，它的架构，怎么来的，怎么用等等。
考拉这边有一个相对完善的数据仓库，从最底端的ODS层，到上面的ADI接口层，里面有各种维度丰富的数据，我们在做数据分析或者算法模型的时候，可以直接拿来调用</p>
<p>业务</p>
<p>算法怎么做，样本怎么选，特征怎么构造，选什么模型等等都需要和业务相结合。</p>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>实习</tag>
        <tag>网易</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Spring Boot的登录demo</title>
    <url>/2018/05/02/springbootlogin/</url>
    <content><![CDATA[<p>本项目基于Spring Boot框架，搭建了一个简单的登录微服务。<br>
Spring Boot相对于传统的SSM(Spring MVC + Mybatis + Spring)框架用起来更加简单，不需要进行复杂的配置，方便灵活。</p>
<a id="more"></a>
<p>Spring Boot让我们的Spring应用变的更轻量化。比如：你可以仅仅依靠一个Java类来运行一个Spring应用。你也可以打包你的应用为jar并通过使用java -jar来运行你的Spring Web应用。</p>
<p>使用Spring Boot可以很方便的建立微服务。</p>
<h3><span id="效果图">效果图</span><a href="#效果图" class="header-anchor"> </a></h3>
<p><a href="http://tianle.me:8080">项目测试地址</a>：<a href="http://tianle.me:8080">http://tianle.me:8080</a></p>
<p>项目代码：<a href="https://github.com/zhangtianle/SpringBoot-Based-Login" target="_blank" rel="noopener">github</a></p>
<p><img src="//img.tianle.me/image/20180502/1.png" alt="效果图"></p>
<h3><span id="应用技术">应用技术</span><a href="#应用技术" class="header-anchor"> </a></h3>
<p>Spring Boot + bootstrap + thymeleaf</p>
<h3><span id="项目搭建">项目搭建</span><a href="#项目搭建" class="header-anchor"> </a></h3>
<p>使用Intellij中的Spring Initializr来快速构建Spring Boot</p>
<p>菜单栏中选择File=&gt;New=&gt;Project…</p>
<p>一直点下一步</p>
<p><img src="//img.tianle.me/image/20180502/p1.png" alt="p1"><br>
<img src="//img.tianle.me/image/20180502/p2.png" alt="p2"><br>
<img src="//img.tianle.me/image/20180502/p3.png" alt="p3"><br>
<img src="//img.tianle.me/image/20180502/p4.png" alt="p4"></p>
<p>最后点击Finish</p>
<p>联网自动从网站上下载Spring Boot的模板，稍作等待框架就搭好啦。</p>
<h4><span id="项目目录结构">项目目录结构</span><a href="#项目目录结构" class="header-anchor"> </a></h4>
<p>上面步骤中的项目名字和这个截图有点不一样(login)<br>
src/main/java/ 为代码文件<br>
src/main/resources/ 为资源文件</p>
<p>为了保证项目资源结构的清晰，我们把 src/main/java/ 再进一步进行划分：<br>
bean 目录存放的是要用到的实体类<br>
controller 目录存放的是控制层类</p>
<p>src/main/resources/template/ 为静态页面的模板文件，这里用了thymeleaf模板渲染引擎框架（据说Spring Boot推荐）<br>
src/main/resources/application.properties 为Spring Boot的配置文件<br>
<img src="//img.tianle.me/image/20180502/p5.png" alt="p5"></p>
<h4><span id="maven配置">maven配置</span><a href="#maven配置" class="header-anchor"> </a></h4>
<p>我们做的是Java web项目，在其默认生成的maven配置文件中添加web和thymeleaf依赖。<br>
pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4><span id="applicationproperties配置">application.properties配置</span><a href="#applicationproperties配置" class="header-anchor"> </a></h4>
<p>这里我们配置 thymeleaf模板渲染引擎</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Enable template caching.</span><br><span class="line">spring.thymeleaf.cache=true</span><br><span class="line"># Check that the templates location exists.</span><br><span class="line">spring.thymeleaf.check-template-location=true</span><br><span class="line"># Content-Type value.</span><br><span class="line">spring.thymeleaf.servlet.content-type=text/html</span><br><span class="line"># Enable MVC Thymeleaf view resolution.</span><br><span class="line">spring.thymeleaf.enabled=true</span><br><span class="line"># Template encoding.</span><br><span class="line">spring.thymeleaf.encoding=UTF-8</span><br><span class="line"># Comma-separated list of view names that should be excluded from resolution.</span><br><span class="line">spring.thymeleaf.excluded-view-names=</span><br><span class="line"># Template mode to be applied to templates. See also StandardTemplateModeHandlers.</span><br><span class="line">spring.thymeleaf.mode=HTML</span><br><span class="line"># Prefix that gets prepended to view names when building a URL.</span><br><span class="line">spring.thymeleaf.prefix=classpath:/templates/</span><br><span class="line"># Suffix that gets appended to view names when building a URL.</span><br><span class="line">spring.thymeleaf.suffix=.html</span><br></pre></td></tr></table></figure>
<p>其余的Spring Boot属性配置文件参考(本项目没有配置，使用的默认)：<br>
<a href="http://blog.didispace.com/springbootproperties/" target="_blank" rel="noopener">Spring Boot属性配置文件详解</a></p>
<h4><span id="bean">Bean</span><a href="#bean" class="header-anchor"> </a></h4>
<p>本项目为用户登录，只考虑用户这一个角色，包含用户名和密码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.tianle.login.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="controller">Controller</span><a href="#controller" class="header-anchor"> </a></h4>
<p>web项目的控制器写在这里，处理页面的请求，前后台交互</p>
<p>@Controller：修饰class，用来创建处理http请求的对象<br>
@RestController：Spring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。<br>
@RequestMapping：配置url映射</p>
<p>目前版本没有添加数据库，能否登录判断逻辑直接写死在代码中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.tianle.login.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> me.tianle.login.bean.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.ModelMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"index"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/login"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(@ModelAttribute User user)</span> </span>&#123;</span><br><span class="line">        String name = user.getName();</span><br><span class="line">        String password = user.getPassword();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"qinya"</span>) &amp;&amp; password.equals(<span class="string">"tianle"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Success"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Failed"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="项目打包运行">项目打包运行</span><a href="#项目打包运行" class="header-anchor"> </a></h4>
<p>使用maven进行打包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure>
<p>Spring Boot里面嵌入了Tomcat，直接运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar xxx.jar</span><br></pre></td></tr></table></figure>
<p><img src="//img.tianle.me/image/20180502/p6.png" alt="p6"><br>
浏览器输入: <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a><br>
账号：qinya<br>
密码：tianle</p>
<h3><span id="参考来源">参考来源</span><a href="#参考来源" class="header-anchor"> </a></h3>
<p><a href="http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">Spring Boot基础教程</a><br>
<a href="http://www.htmleaf.com/css3/ui-design/201610114094.html" target="_blank" rel="noopener">基于Bootstrap的简洁登录界面设计效果</a><br>
<a href="https://spring.io/guides/gs/spring-boot/" target="_blank" rel="noopener">Building an Application with Spring Boot</a></p>
]]></content>
      <categories>
        <category>应用开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>spring boot</tag>
        <tag>demo</tag>
        <tag>login</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中十进制转二进制转换函数</title>
    <url>/2018/04/17/int-to-bit/</url>
    <content><![CDATA[<p>原文转自：<a href="http://blog.chinaunix.net/uid-10018502-id-2972048.html" target="_blank" rel="noopener">java中十进制转二进制转换函数</a></p>
<a id="more"></a>
<p>十进制转成十六进制：<br>
Integer.toHexString(int i)<br>
十进制转成八进制<br>
Integer.toOctalString(int i)<br>
十进制转成二进制<br>
Integer.toBinaryString(int i)<br>
十六进制转成十进制<br>
Integer.valueOf(“FFFF”,16).toString()<br>
八进制转成十进制<br>
Integer.valueOf(“876”,8).toString()<br>
二进制转十进制<br>
Integer.valueOf(“0101”,2).toString()</p>
<p>有什么方法可以直接将2,8,16进制直接转换为10进制的吗?<br>
java.lang.Integer类<br>
parseInt(String s, int radix)<br>
使用第二个参数指定的基数，将字符串参数解析为有符号的整数。<br>
examples from jdk:<br>
parseInt(“0”, 10) returns 0<br>
parseInt(“473”, 10) returns 473<br>
parseInt(&quot;-0&quot;, 10) returns 0<br>
parseInt(&quot;-FF&quot;, 16) returns -255<br>
parseInt(“1100110”, 2) returns 102<br>
parseInt(“2147483647”, 10) returns 2147483647<br>
parseInt(&quot;-2147483648&quot;, 10) returns -2147483648<br>
parseInt(“2147483648”, 10) throws a NumberFormatException<br>
parseInt(“99”, throws a NumberFormatException<br>
parseInt(“Kona”, 10) throws a NumberFormatException<br>
parseInt(“Kona”, 27) returns 411787</p>
<p>进制转换如何写（二，八，十六）不用算法<br>
Integer.toBinaryString<br>
Integer.toOctalString<br>
Integer.toHexString</p>
<blockquote>
<p>例一</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">100</span>;</span><br><span class="line">    String binStr=Integer.toBinaryString(i);</span><br><span class="line">    String otcStr=Integer.toOctalString(i);</span><br><span class="line">    String hexStr=Integer.toHexString(i);</span><br><span class="line">    System.out.println(binStr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例二</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStringFormat</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">       System.out.println(<span class="string">"usage: java TestStringFormat "</span>);</span><br><span class="line">       System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Integer factor = Integer.valueOf(args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    String s;</span><br><span class="line"></span><br><span class="line">    s = String.format(<span class="string">"%d"</span>, factor);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    s = String.format(<span class="string">"%x"</span>, factor);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    s = String.format(<span class="string">"%o"</span>, factor);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其他方法：</p>
</blockquote>
<p>Integer.toHexString(你的10进制数);<br>
例如<br>
String temp = Integer.toHexString(75);<br>
输出temp就为 4b</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入一个10进制数字并把它转换成16进制</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">toHex</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> input;<span class="comment">//存放输入数据</span></span><br><span class="line"><span class="comment">//创建输入字符串的实例</span></span><br><span class="line">BufferedReader strin=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">System.out.println(<span class="string">"请输入一个的整数："</span>);</span><br><span class="line">String x=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">x=strin.readLine();</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException ex)&#123;</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">input=Integer.parseInt(x);</span><br><span class="line">System.out.println (<span class="string">"你输入的数字是："</span>+input);<span class="comment">//输出从键盘接收到的数字</span></span><br><span class="line"></span><br><span class="line">System.out.println (<span class="string">"它的16进制是："</span>+Integer.toHexString(input));<span class="comment">//用toHexString把10进制转换成16进制</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>应用开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title>Java垃圾收集器与内存分配策略</title>
    <url>/2018/04/17/java-gc/</url>
    <content><![CDATA[<p>本文是对《深入理解Java虚拟机》，第三章 垃圾收集器与内存分配策略 的总结。</p>
<a id="more"></a>
<h2><span id="对象死了吗">对象死了吗？</span><a href="#对象死了吗" class="header-anchor"> </a></h2>
<h3><span id="引用计数法">引用计数法</span><a href="#引用计数法" class="header-anchor"> </a></h3>
<p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器加一，引用失效时，计数器减一，任何时刻计数器为0的对象就是不可能再被使用的。
实现简单，判定效率高，但是很难解决对象间循环引用的问题</p>
<h3><span id="可达性分析法">可达性分析法</span><a href="#可达性分析法" class="header-anchor"> </a></h3>
<p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p>
<h3><span id="引用">引用</span><a href="#引用" class="header-anchor"> </a></h3>
<p>强引用 new，软引用 SoftReference， 弱引用 WeakReference，虚引用 PhantomReference</p>
<p>如果宣告对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Root相连接的引用链，那它将会第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。 如果这个对象被判定为有必要执行finalize()方法，那么这个对象会放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动创建的、低优先级的Finalizer线程去执行它。</p>
<h3><span id="回收方法区">回收方法区</span><a href="#回收方法区" class="header-anchor"> </a></h3>
<blockquote>
<p>满足以下3个条件：<br>
1.该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。<br>
2.加载该类的ClassLoader已经被回收。<br>
3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
</blockquote>
<h2><span id="垃圾收集算法">垃圾收集算法</span><a href="#垃圾收集算法" class="header-anchor"> </a></h2>
<p>复制算法<br>
标记-整理算法<br>
标记-清除算法</p>
<p>根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代<br>
新生代：每次垃圾收集时有大批对象死亡，少量存活， 选用 复制算法<br>
老年代：对象存活率高、没有额外空间对它进行分配担保，使用  标记-整理 或者 标记-清理</p>
<h2><span id="垃圾收集器">垃圾收集器</span><a href="#垃圾收集器" class="header-anchor"> </a></h2>
<p>垃圾收集器是内存回收的具体实现。<br>
到目前为止没有一个万能的收集器，所以选择的是对具体应用最合适的收集器。</p>
<h3><span id="serial收集器">Serial收集器</span><a href="#serial收集器" class="header-anchor"> </a></h3>
<p>单线程<br>
在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束</p>
<h3><span id="parnew收集器">ParNew收集器</span><a href="#parnew收集器" class="header-anchor"> </a></h3>
<p>Serial收集器的多线程版本</p>
<h3><span id="cms收集器">CMS收集器</span><a href="#cms收集器" class="header-anchor"> </a></h3>
<p>最短回收停顿时间<br>
并发收集、低停顿<br>
标记-清除<br>
步骤：初始标记、并发标记、重新标记、并发清除</p>
<h3><span id="g1收集器">G1收集器</span><a href="#g1收集器" class="header-anchor"> </a></h3>
<p>特点：并行与并发、分代收集、空间整合（不会产生内存空间碎片）、可预测的停顿<br>
步骤：初始标记、并发标记、最终标记、筛选回收</p>
<blockquote>
<p>注：<br>
并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态<br>
并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替进行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上</p>
</blockquote>
<h2><span id="内存分配与回收策略">内存分配与回收策略</span><a href="#内存分配与回收策略" class="header-anchor"> </a></h2>
<h3><span id="对象优先在eden分配">对象优先在Eden分配</span><a href="#对象优先在eden分配" class="header-anchor"> </a></h3>
<h3><span id="大对象直接进入老年代">大对象直接进入老年代</span><a href="#大对象直接进入老年代" class="header-anchor"> </a></h3>
<h3><span id="长期存活的对象将进入老年代">长期存活的对象将进入老年代</span><a href="#长期存活的对象将进入老年代" class="header-anchor"> </a></h3>
<p>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳，将被移动到Survivor空间中，并且对象年龄设为1,。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。</p>
<h3><span id="动态对象年龄判定">动态对象年龄判定</span><a href="#动态对象年龄判定" class="header-anchor"> </a></h3>
<p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</p>
]]></content>
      <categories>
        <category>应用开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2018/03/28/dynamic-programming/</url>
    <content><![CDATA[<p>动态规划是一种算法设计技术，是一种使多阶段决策过程最优的通用方法。</p>
<a id="more"></a>
<p>如果问题是由<strong>交叠</strong>的子问题构成的，我们就可以用动态规划技术来解决它。一般来说这样的子问题出现在对给定问题求解的递推关系中，这个递推关系中包含了相同类型的更小问题的解。<br>
动态规划法建议，与其对交叠的子问题一次又一次地求解，还不如对每个较小的子问题只求解一次并把结果记录在表中，这样就可以从表中得出原始问题的解。<br>
动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。</p>
<h2><span id="币值最大化问题">币值最大化问题</span><a href="#币值最大化问题" class="header-anchor"> </a></h2>
<p>问题：给定一排n个硬币，其面值均为整数c1, c2, …, cn, 这些整数并不一定两两不同。问如何选择硬币，使得在其原始位置互不相邻的条件下，所选硬币的总金额最大。</p>
<p>令：F(n)为最大可选金额，该题可分为两种情况，包括最后一枚硬币和不包括最后一枚硬币。第一种情况：可选硬币的最大金额为${c_n} + F\left( {n - 2} \right)$，即最后一枚硬币的面值加上之前的$n-2$枚硬币的可选最大金额。第二种情况，可选的最大金额为$F\left( {n - 1} \right)$，因此得到递推方程：</p>
$$F\left( n \right) = \max \left\{ {{c_n} + F\left( {n - 2} \right),F\left( {n - 1} \right)} \right\},n > 1$$
$$F\left( 0 \right) = 0,F\left( 1 \right) = {c_1}$$
<p>算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxCoinValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输入的值</span></span><br><span class="line">    <span class="keyword">int</span>[] coins = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[coins.length];</span><br><span class="line">    f[<span class="number">0</span>] = coins[<span class="number">0</span>];</span><br><span class="line">    f[<span class="number">1</span>] = Math.max(coins[<span class="number">0</span>], coins[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">        f[i] = Math.max(f[i - <span class="number">2</span>] + coins[i], f[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(f[f.length - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="找零问题">找零问题</span><a href="#找零问题" class="header-anchor"> </a></h2>
<p>需找零金额为$n$，最少要用面值为${d_1} &lt; {d_2} &lt;  \cdots  &lt; {d_m}$的硬币？</p>
<p>设F(n)为总金额为n的数量最小的硬币数目，为方便起见定义F(n)=0. 获得n的途径只能是：在总金额为$n - {d_j}$的一堆硬币上加入一个面值为${d_j}$的硬币，并且$n \geqslant {d_j}$。因此，我们只需要考虑所有满足上述要求的${d_j}$并选择使得$F(n - {d_j}) + 1$最小的${d_j}$即可。于是可得递归公式：</p>
$$\left\{ \begin{gathered}
  F(n) = \mathop {\min }\limits_{j:n \geqslant {d_j}} \{ F(n - {d_j})\}  + 1,n > 0 \hfill \\
  F(0) = 0 \hfill \\ 
\end{gathered}  \right.$$
<p>算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">changeMaking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输入数据</span></span><br><span class="line">    <span class="keyword">int</span>[] coins = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// f(n) 为总金额为n的数量最小的硬币数目</span></span><br><span class="line">    <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; coins.length &amp;&amp; i &gt;= coins[j]) &#123;</span><br><span class="line">            min = Math.min(f[i - coins[j]], min);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i] = min + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(f[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="硬币收集问题">硬币收集问题</span><a href="#硬币收集问题" class="header-anchor"> </a></h2>
<p>在n*m格木板中放有一些硬币，每格的硬币数目最多为一个，在木板左上方的一个机器人需要收集尽可能多的硬币并把它们带到右下方的单元格。每一步，机器人可以从当前的位置向右移动一格或向下移动一格。当机器人遇到一个有硬币的单元格时，就会将这枚硬币收集起来。设计一个算法找出机器人能找到的最大硬币数并给出相应的路径。<br>
<img src="//img.tianle.me/image/20180328/1.png" alt="硬币收集问题1"><br>
<img src="//img.tianle.me/image/20180328/2.png" alt="硬币收集问题2"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">robotCoinCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输入数据</span></span><br><span class="line">    <span class="keyword">int</span>[][] coins = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][<span class="number">6</span>];</span><br><span class="line">    coins[<span class="number">0</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">    coins[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    coins[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    coins[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    coins[<span class="number">2</span>][<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">    coins[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    coins[<span class="number">3</span>][<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">    coins[<span class="number">4</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    coins[<span class="number">4</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// f(i,j) 为机器人截止到 i, j 单元格能够收集到的最大硬币数</span></span><br><span class="line">    <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[coins.length][coins[<span class="number">0</span>].length];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = coins[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; coins[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">        f[<span class="number">0</span>][i] = f[<span class="number">0</span>][i - <span class="number">1</span>] + coins[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + coins[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; coins[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            f[i][j] = Math.max(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]) + coins[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(f[coins.length - <span class="number">1</span>][coins[<span class="number">0</span>].length - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>刷题</tag>
        <tag>硬币问题</tag>
      </tags>
  </entry>
  <entry>
    <title>从等公交概率问题引发的思考</title>
    <url>/2018/03/25/probability-problem/</url>
    <content><![CDATA[<p>先放上一道题：</p>
<blockquote>
<p>有 A 和 B 两路公交车，平均发车间隔分别为 5 分钟和 10 分钟。某乘客在站点 S 可以 任意选择两者之一乘坐，假定 A 和 B 到达 S 的时刻无法确定，那么该乘客的平均等待时间约为____。<br>
A、1 分钟 20 秒     B、3 分钟 20 秒     C、2 分钟 30 秒     D、1 分钟 40 秒</p>
</blockquote>
<a id="more"></a>
<p>这是一道阿里校招题，同时在头条面试中也问了这道题。这一题有点复杂，咋们先看看其他概率题。</p>
<h2><span id="几何概型">几何概型</span><a href="#几何概型" class="header-anchor"> </a></h2>
<p>如果每个事件发生的概率只与构成该事件区域的长度(面积或体积或度数)成比例，则称这样的概率模型为几何概率模型，简称为几何概型。<br>
比如：对于一个随机试验，我们将每个基本事件理解为从某个特定的几何区域内随机地取一点，该区域中每一个点被取到的机会都一样；而一个随机事件的发生则理解为恰好取到上述区域内的某个指定区域中的点。这里的区域可以是线段，平面图形，立体图形等。用这种方法处理随机试验，称为几何概型.</p>
<p><strong>简单来说，就是通过画图来求事件发生的概率：</strong></p>
<blockquote>
<p>取一根长度为30cm的绳子，拉直后在任意位置剪断，那么剪得两段的长度都不小于10cm的概率有多大？</p>
</blockquote>
<p>解、记事件M为“剪得两段的长度都不小于10cm，<br>
那么事件M所在区域为线段AB，长度为10cm，<br>
试验所取得所有结果所在的区域为整个绳长30cm。<br>
那么，根据几何概型概率计算公式有：<br>
$$p(M) = \frac1030 = \frac{1}{3}$$</p>
<blockquote>
<p>假设张明家订了一份报纸,送报人可能在早上6:30—7:30之间把报纸送到家,他父亲离开家去工作的时间在早上7:00—8:00之间,问他父亲在离开家前能得到报纸(称为事件A)的概率是多少?</p>
</blockquote>
<p>同理我们还是画图：
<img src="//img.tianle.me/image/20180325/1.png" alt="几何概型"><br>
解:以横坐标x表示报纸送到时间,以纵坐标y表示张明父亲离家时间建立平面直角坐标系,假设随机试验落在方形区域内任何一点是等可能的,所以符合几何概型的条件.
根据题意,只要点落到阴影部分,就表示他父亲在离开家前能得到报纸,它的约束条件是$x &lt; y$,即时间A发生,所以<br>
<img src="//img.tianle.me/image/20180325/2.png" width="40%" height="40%"></p>
<blockquote>
<p>在一个周五晚上，甲和朋友乙决定去夜店High一把。但是他们兴奋过头，忘记了约定的具体时间，只记得是在十二点到一点之间。假设他们随机地选择到达夜店的时间，并且都会在店门口等另一个人十分钟（如果在此期间对方并未出现，他就会离开）。那么，他们当晚能见面的概率是多大呢？</p>
</blockquote>
<p>如果把甲的到达的时间记在 x 轴上，把乙的到达时间记在 y 轴上，那么他们到达的时间便可以用坐标系中的点 ( x , y ) 来表示，根据设定可知这个点一定会落在图中的正方形区域中。而如果二人想见面，那么他们先后到达的时间间隔一定要小于十分钟，即 | x – y | ≤ 10。</p>
<p>解这个不等式，可得 x – 10 ≤ y ≤ x + 10 。将这两条支线在坐标系中画出来，就能发现它们围成的区域正好是上图的阴影部分。</p>
<p>换言之，如果两人要碰面，对应的到达的时间点 （x，y） 就必须要落在阴影部分内。所以阴影部分的面积与大正方形面积之比就是所要求的概率，据此我们就能很轻松地计算出答案：11／36。
<img src="//img.tianle.me/image/20180325/3.png" alt="几何概型解"></p>
<h2><span id="平均等公交时间">平均等公交时间</span><a href="#平均等公交时间" class="header-anchor"> </a></h2>
<p>回到一开始的题目。<br>
我们可以画一个图（至于图为什么是这样，我也没看明白，请大家参考<a href="http://www.cnblogs.com/jmp0xf/p/2014_Alibaba_Waiting_Bus.html" target="_blank" rel="noopener">阿里巴巴2014北京校招等车概率题分析</a><br>
<img src="//img.tianle.me/image/20180325/5.png" width="50%" height="50%"><br>
想象成一个长方体，切了两刀，图中的虚线可以理解为等高线，右边的高度为5 ($min({t_A},{t_B})$)，左边为0，底边长为10，宽为5。<br>
解法是   它的体积 / 它的底面积<br>
$$E[t] = (125/2 + 125/3)/50 = 25/12$$</p>
<h2><span id="参考资料">参考资料</span><a href="#参考资料" class="header-anchor"> </a></h2>
<p><a href="https://img.tianle.me/image/20180325/%E5%87%A0%E4%BD%95%E6%A6%82%E7%8E%87%E6%A8%A1%E5%9E%8B--%E5%85%AC%E5%BC%80%E8%AF%BE.ppt" target="_blank" rel="noopener">几何概形ppt</a><br>
<a href="http://www.cnblogs.com/jmp0xf/p/2014_Alibaba_Waiting_Bus.html" target="_blank" rel="noopener">阿里巴巴2014北京校招等车概率题分析</a><br>
<a href="https://www.guokr.com/article/61325/" target="_blank" rel="noopener">死理性派碰面法，100%遇见你</a><br>
等公交车的概率：<a href="http://www.matrix67.com/blog/archives/4349" target="_blank" rel="noopener">等待的时间比你想象的更久</a><br>
<a href="https://www.zhihu.com/question/36348471?utm_source=wechat_session&amp;utm_medium=social" target="_blank" rel="noopener">上班有A和B两班公交，A车间隔为0-15分钟，B车间隔为0-20分钟（均随机），那么我上班平均等多久？</a><br>
<a href="https://img.tianle.me/image/20180325/4.png" target="_blank" rel="noopener">阿里题网页截图</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>概率</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2018/03/08/sort/</url>
    <content><![CDATA[<p>刷完了剑指Offer，回过头再看看数据结构与算法。</p>
<a id="more"></a>
<h2><span id="选择排序">选择排序</span><a href="#选择排序" class="header-anchor"> </a></h2>
<h2><span id="插入排序">插入排序</span><a href="#插入排序" class="header-anchor"> </a></h2>
<p>把插入排序想象成，扑克牌中的洗牌，一张一张的来，把每一张未排序的牌插入到已经排好序的扑克牌中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            exch(arr, j, j-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>插入排序的哨兵</strong> 在插入排序的实现中，先找出最小的元素并将其置于数组的最左边，这样就能去掉内循环的判断条件 $j&gt;0$。<br>
这是一种常见的规避边界测试的方法，能够省略判断条件的元素通常被称为<strong>哨兵</strong>。</p>
<h2><span id="希尔排序">希尔排序</span><a href="#希尔排序" class="header-anchor"> </a></h2>
<p>他也是一种属于插入排序类的方法，但在时间效率上比其他插入排序有较大改进。<br>
直接插入排序的时间复杂度为$O({n^2})$，但是，若待排序序列为“正序”时，直接插入排序的时间复杂度为$O(n)$</p>
<blockquote>
<p>基本思想：<br>
先将整个待排序记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; arr.length / <span class="number">3</span>) &#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 将数组变成h有序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 注意 j &gt;= h</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; arr[j] &lt; arr[j - h]; j -= h) &#123;</span><br><span class="line">                exch(arr, j, j - h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="归并排序">归并排序</span><a href="#归并排序" class="header-anchor"> </a></h2>
<p>把两个有序的数组归并成一个更大的有序数组。<br>
要将一个数组排序，可以先（递归地）将它分成两半部分分别排序，然后将结果归并起来。<br>
它能保证将任意长度为N的数组排序所需时间和NlogN成正比，但是它需要额外空间和N成正比。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergingSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    aux = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    mergingSortCore(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergingSortCore</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    mergingSortCore(arr, lo, mid);</span><br><span class="line">    mergingSortCore(arr, mid + <span class="number">1</span>, hi);</span><br><span class="line">    merge(arr, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        aux[k] = arr[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">            <span class="comment">// 左半边完了，把右半边复制过来</span></span><br><span class="line">            arr[k] = aux[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) &#123;</span><br><span class="line">            <span class="comment">// 右半边完了，把左半边复制过来</span></span><br><span class="line">            arr[k] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aux[i] &gt; aux[j]) &#123;</span><br><span class="line">            <span class="comment">// 左半边大于右半边，把右半边复制过来</span></span><br><span class="line">            arr[k] = aux[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 右半边大于左半边，把左半边复制过来</span></span><br><span class="line">            arr[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="总结">总结</span><a href="#总结" class="header-anchor"> </a></h2>
<p><img src="//img.tianle.me/image/20180308/1.png" alt="sortpic"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer总结</title>
    <url>/2018/03/05/coding-interviews/</url>
    <content><![CDATA[<p>经过2个多月的零零散散的刷题，终于搞定了剑指Offer中的67道面试题，这期间又经历了一场GE的数据分析岗简单面试，立刻体会到剑指offer的强大，除了里面的经典面试题之外，书中包含的软条件，面试套路，分析、回答问题的技巧也确确实实得好用。在刷完题之际，做一个简单的总结。这是我剑指offer的<a href="https://github.com/zhangtianle/LeetCode/tree/master/src/codingInterviews" target="_blank" rel="noopener">Java代码</a>，供大家参考。</p>
<a id="more"></a>
<h2><span id="面试相关">面试相关</span><a href="#面试相关" class="header-anchor"> </a></h2>
<ol>
<li>
<p>理解题目含义<br>
首先理解题目的含义，题目有没有什么坑，没听明白的可以再问问面试官。<br>
善于学习，沟通，提问，体现出<strong>主动积极</strong>的态度。如果能够针对面试题主动提出几个<strong>高质量</strong>的问题，面试官就会觉得他有很强的<strong>沟通能力</strong>和<strong>学习能力</strong>。<br>
有些面试官故意一开始不把题目描述清楚，让题目存在一定的二义性。他期待应聘者能够一步步通过提问来弄明白题目的要求。<br>
<strong>知识迁移能力</strong>先问一个简单的问题，完成简单问题之后，问一个相关的同时难度也更大的问题。</p>
</li>
<li>
<p>想清楚后再开始写代码<br>
写代码之前先将<strong>思路</strong>，明白自己要做什么东西；可以通过<strong>举例子</strong>、<strong>画图</strong>等多种方式，解释清楚<strong>问题本身</strong>和<strong>问题解决方案</strong>。</p>
</li>
<li>
<p>良好的代码命名和缩进对齐习惯</p>
</li>
<li>
<p>能够单元测试</p>
</li>
</ol>
<h3><span id="技术面试环节">技术面试环节</span><a href="#技术面试环节" class="header-anchor"> </a></h3>
<p>自我介绍完，就开始了。</p>
<ol>
<li>扎实的基础知识</li>
<li>高质量的代码</li>
<li>清晰的思路</li>
<li>优化效率的能力</li>
<li>优秀的综合能力</li>
</ol>
<h3><span id="现场面试要注意的地方">现场面试要注意的地方</span><a href="#现场面试要注意的地方" class="header-anchor"> </a></h3>
<ol>
<li>时间、衣服得体，干净</li>
<li>注意面试邀请函里的面试流程<br>
有可能会等很长时间，所以可以带一点提升醒脑的饮品</li>
<li>准备几个问题，面试完之后，面试官会让面试者问几个问题<br>
先考虑面试官是做什么的，问的东西要他能知道的，答的上来的，也不要问和自己的职业没关系的问题，不要问薪水，不要打听面试结果。<br>
<strong>推荐的问题：</strong> 与招聘的职位或者项目相关的问题。<br>
可以事先在网上收集一些相关的信息，留意面试官说过的话。公司的主要业务、职位要求、与应聘岗位相关的项目、招聘相关的项目，可以从这里面找一两个点，然后向面试官提问。</li>
</ol>
<h2><span id="做题相关">做题相关</span><a href="#做题相关" class="header-anchor"> </a></h2>
<h3><span id="题目">题目</span><a href="#题目" class="header-anchor"> </a></h3>
<h4><span id="斐波那契数列">斐波那契数列</span><a href="#斐波那契数列" class="header-anchor"> </a></h4>
<p>求斐波那契数列的第$n$项。<br>
传统的递归算法有很多计算是重复的，时间复杂度以$n$的指数的方式递增。<br>
改进方式：把上一步的答案存下来，用到下一步即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n1;</span><br><span class="line">            n1 = n2;</span><br><span class="line">            n2 = temp + n2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="在o1时间删除链表节点">在O(1)时间删除链表节点</span><a href="#在o1时间删除链表节点" class="header-anchor"> </a></h4>
<p>分析可能，有可能被删除的节点是头节点，那么我们先建一个虚拟节点，防止头节点被删，让虚拟节点的下一个节点指向头结点。然后循环遍历，调过那个要删除的节点，直接把上一个节点指向要被删除节点的下一个节点即可。<a href="https://github.com/zhangtianle/LeetCode/blob/master/src/codingInterviews/DeleteDuplicatedListNode.java" target="_blank" rel="noopener">代码</a></p>
<h4><span id="反转链表">反转链表</span><a href="#反转链表" class="header-anchor"> </a></h4>
<p>定义三个指针，分别指向当前遍历到的节点、它的前一个节点及后一个节点。<a href="https://github.com/zhangtianle/LeetCode/blob/master/src/codingInterviews/ReverseList.java" target="_blank" rel="noopener">代码</a></p>
<h4><span id="合并两个排序的列表">合并两个排序的列表</span><a href="#合并两个排序的列表" class="header-anchor"> </a></h4>
<p>如果某一个链表为空，那么合并后就是那个不为空的链表，接下来，从头结点开始判断两个链表节点值的大小，进行合并。递归地进行此过程。MergeSortedLists</p>
<h4><span id="从上往下打印二叉树">从上往下打印二叉树</span><a href="#从上往下打印二叉树" class="header-anchor"> </a></h4>
<p>层次遍历二叉树，在纸上画一棵树，分析它的运行过程，可以发现它是一个先进先出的结构，那么我们可以用队列进行实现。每次打印一个节点，如果它存在叶子节点，那么把它的叶子节点存入队列中。接下来在队列头部取出一个节点，打印，不断循环。</p>
<h4><span id="二叉搜索树与双向链表">二叉搜索树与双向链表</span><a href="#二叉搜索树与双向链表" class="header-anchor"> </a></h4>
<p>二叉搜索树的中序遍历是从小到大的排序，那么我们把这个序列转化为双向链表即可。</p>
<h4><span id="字符串的排列">字符串的排列</span><a href="#字符串的排列" class="header-anchor"> </a></h4>
<p>把字符串分为两部分：第一部分，第一个字符的位置记为A，第二部分，除了A之外，字符串右边剩余的部分，记为B。把位置A的字符与B部分中的每一个字符进行逐一交换。递归地完成交换，直至字符串末尾。</p>
<h4><span id="数组中出现次数超过一半的数字">数组中出现次数超过一半的数字</span><a href="#数组中出现次数超过一半的数字" class="header-anchor"> </a></h4>
<ol>
<li>基于快排中Partition函数的O(n)算法<br>
使用Partition函数找到数组中的中位数即可，即让Partition的返回的index为数组的中间那个数的位置，即为所得答案。</li>
<li>利用数组特点<br>
遍历数组，遍历的时候保存两个值，一个是数组的数字，一个是次数。当遍历到下一个数字时，如果下一个数字和我们之前保存的数字相同，则次数加1；如果下一个数字和我们之前保存的数字不同，则次数减1。如果次数为0，我们需要保存下一个数字，并把次数设为1。由于我们要找的数字的出现次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设为1时对应的数字。</li>
</ol>
<h4><span id="丑数">丑数</span><a href="#丑数" class="header-anchor"> </a></h4>
<p>创建数组保存已经找到的丑数，用空间换时间的解法。<br>
每一个丑数都是前面的丑数乘以2、3或者5得到的。</p>
<h4><span id="两个链表的第一个公共节点">两个链表的第一个公共节点</span><a href="#两个链表的第一个公共节点" class="header-anchor"> </a></h4>
<ol>
<li>蛮力法(一一比较)</li>
<li>分析题目，公共节点而部分重合的，只可能从链表尾部开始往前的一部分地方重合，是个Y型的样子，而不可能是X型的，那么我们从链表尾部开始比较，但是链表是从前往后遍历的，所以我们利用栈“后进先出”的特点。遍历链表的时候把节点存到栈中，全部入栈后，然后再从栈中取出一一比较。</li>
<li>先遍历每个链表，知道哪个链表比较长，再让长的链表先遍历它们间的步数差，然后它们两个一起遍历，第一个相同的节点就是它们第一个公共节点。</li>
</ol>
<h4><span id="数字在排序数组中出现的次数">数字在排序数组中出现的次数</span><a href="#数字在排序数组中出现的次数" class="header-anchor"> </a></h4>
<p>利用二分查找的思想，找到第一次出现的位置，和最后一次出现的位置，然后相减。</p>
<h4><span id="和为s的两个数字和为s的连续正数序列">和为s的两个数字，和为s的连续正数序列</span><a href="#和为s的两个数字和为s的连续正数序列" class="header-anchor"> </a></h4>
<p>利用两个指针。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数学建模比赛心得</title>
    <url>/2018/02/14/shumo/</url>
    <content><![CDATA[<p>在接触数学建模以前，我一直认为“凡问题皆有其解”，并且必然存在一种最佳的解法，它是我们要寻找的，是我们认识这个问题的最好的选择。建模课上的思考以及亲身参与建模训练和竞赛的经历，改变了我的看法。原来一个问题可以有许多不同的解决办法。现实世界里许多问题往往不存在全局最优解，但可以有许多局部最优解，所谓“条条道路通罗马”；而且现实世界里全局最优解可能也没有多大意义，局部最优解给我们提供了极大的选择空间，并且易于实现。在数学的世界里，既有其精益求精的追求精神，也有它“知足常乐”的哲学原理。而从不同的角度审视问题，往往会带给我们意想不到的惊喜和发现，就好像万花筒，转动它，又一幅绚丽的画面诞生了。</p>
<a id="more"></a>
<p>第一次参加数学建模的训练，并利用暑期阅读了历年的建模真题及优秀论文，无论是对于个人还是对于整个团队，大家都有很多收获和心得：一定要有团队精神。数学建模不是一个人就能轻松解决的事，是团队的一项活动。三个人要互相信任，相互支持，相互鼓励。而不能只管自己（负责编程的不管其他事情，负责写论文的只搞文章）特别是建立模型，一个人根本不可能掌握全部模型，只有大家一起讨论并查阅资料才能想出解决问题的方法。合理的安排工作时间。建模是一项工程浩大，繁琐，知识面极广的活动。事先要做好一个规划，例如建模一共分十个板块（摘要，问题提出，模型假设，问题分析，模型假设，模型建立，模型求解，结果分析，模型的评价与推广，参考 文献，附录），这些要在三天内完成就要合理分配好时间。掌握写论文的基本格式。 论文属于科学性的文章， 它有严格的书写格式规范，因此一篇好的论文一定要有正确的格式，它包括摘要，主要内容，参考文献，附录。 建模论文中，摘要是最直观的，能让评委快速的了解一篇论文所包含的内容，它要包括 6 要素（问题,方法,模型,算法,结论,特色） 。 了解到用词的准确性。 一篇好的论文首先读上去要使人感到逻辑清晰，能打 动评委；其次，论文在语言上的表述也很重要，要注意用词的准确性；另外，一篇好的论文应有自己的想法和思考在里面。见识了更多的数学模型。 在历年的优秀建模论文集中，我学习了各种不同的模型，如多元二次回归模型，优化模型，线性规划模型，回归模型等。 初步使用各种建模软件。学习建模的同时，借用各种建模软件解决问题是必 不可少的。Matlab，Lingo，Excel，spass 等都是可以运用的。运用 Matlab可以通过编写相关程序，运行后得到数据结果和图表，从而可以更直接地分析问题，解决问题等。每个大学生，尤其是理工科的同学，都应该有建模的思想。我们在基础课上 所学的每一个方程都是数学的模型，所解决的问题都需要用到建模思想。可以说要提高自己的素质，建模思想是一个重要的因素。我们可以找一些有关建模的书籍看一看，深一步了解建模。能参加数学建模比赛，是一次很有意义的实践。建模的思想可以通过看书得到，团结协作精神是我在这次实践得到的最大收获。</p>
<p>现实世界是复杂的，无序的，数学建模教我们利用逻辑思维，使用数学工具，运用相关知识来认识它，解释它，解决它提出的问题。从某种意义上说，自然科学里每一次真理火花的闪烁都是一次伟大的建模。在学习，训练的过程中，我们查找和问题有关的资料，分析背景和原理，思考解决的方法并付诸实践，最后在论文里表述我们的观点，展现我们的成果。每一次练习，都是一次冥思和创造的历炼，一次毅力和耐心的考验。</p>
<p>数学建模的生活是苦的，是累的，但充满了温馨，因为有团队成员的合作，学校和老师的关心；数学建模的生活更是难忘的，我们学会了坚持不懈，与挑战自我；数学建模之路使我们学到了许多知识，认识了许多朋友，使我们终身难忘，感谢学校和老师对我们的机会和帮助！</p>
<p>2014年9月11日</p>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>竞赛</tag>
        <tag>数学建模</tag>
        <tag>数模</tag>
        <tag>心得</tag>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>模型融合 Blending 和 Stacking</title>
    <url>/2018/02/11/aggregate/</url>
    <content><![CDATA[<p>构建并结合多个学习器来完成学习任务，我们把它称为模型融合或者集成学习。<br>
不同的模型有各自的长处，具有差异性，而模型融合可以使得发挥出各个模型的优势，让这些相对较弱的模型（学习器）通过某种策略结合起来，达到比较强的模型（学习器）。</p>
<a id="more"></a>
<p>在进行模型融合之前，各个基学习器不能够太差，即“准确性”，第二，它们之间要有区分度，即“差异性”。要满足这两点，把多个学习器结合在一起，它们的效果才能比原先的各个基学习器要好。<br>
那么它们都有哪些方法呢？</p>
<h2><span id="blending">Blending</span><a href="#blending" class="header-anchor"> </a></h2>
<h3><span id="uniform-blending-均匀融合">Uniform Blending (均匀融合)</span><a href="#uniform-blending-均匀融合" class="header-anchor"> </a></h3>
<p>Uniform Blending的分类的模型如下，实际上就是少数服从多数的原则，类似于投票:<br>
$$G(\mathbf x)=sign \left( \sum\limits_{t=1}^{T}1 \cdot g_t(\mathbf x)\right)$$</p>
<p>回归模型如下，直接求T个模型g的结果的平均值:<br>
$$G(\mathbf x)= {1\over T}\sum\limits_{t=1}^{T}1 \cdot g_t(\mathbf x)$$</p>
<p>通过Uniform Blending可以减少varience。</p>
<p>分类问题可以想象为投票，回归问题可以想象为加权。</p>
<h3><span id="linear-blending-线性融合">Linear Blending (线性融合)</span><a href="#linear-blending-线性融合" class="header-anchor"> </a></h3>
<p>上面的Uniform Blending，对于每一个模型，无论是回归还是分类，它们的权重是一样的。但是我们稍加改变，为每一个$g$都指定权重。</p>
$$G({\mathbf{x}}) = sign\left( {\sum\limits_{t = 1}^T {{\alpha _t}}  \cdot {g_t}({\mathbf{x}})} \right)$$
<p>其中，${\alpha _t} \geqslant 0$。那么这些$g$是由最小化评价集合的最小误差得到的，然后通过“特征转化”: $\mathbf z_n = \phi^{-}(\mathbf x_n) = (g_1^{-}(\mathbf x_n), g_2^{-}(\mathbf x_n)...g_{T}^{-}(\mathbf x_n))$，数据变为$(z_n, y_n)$; 而 ${\alpha _t}$通过之前的线性回归，逻辑回归等方法得到投票权重；最后便得到了最终模型。</p>
<h2><span id="stacking">Stacking</span><a href="#stacking" class="header-anchor"> </a></h2>
<p>Stacking实际上就是把Blending组合起来，Blending只有一层，而Stacking有多层，它把各个基学习器的预测结果作为下一层新的训练集，来学习一个新的学习器。通过元分类器或元回归聚合多个分类或回归模型。基础层次模型（level model）基于完整的训练集进行训练，然后元模型基于基础层次模型的输出进行训练。<br>
<img src="//img.tianle.me/image/20180211/stacking.jpg" alt="stacking"></p>
<h2><span id="总结">总结</span><a href="#总结" class="header-anchor"> </a></h2>
<p>上面的这几个方法都是先把小的模型训练出来，然后再进行加权融合。Stacking有个问题，由于它的模型复杂度过高，容易造成过拟合。</p>
<p>在模型融合中，除了不同的算法模型之外，相同的算法模型不同的模型参数，算法中的不同随机种子，也可以用来融合。<br>
<img src="//img.tianle.me/image/20180211/1.png" alt="1"></p>
<h2><span id="参考资料">参考资料</span><a href="#参考资料" class="header-anchor"> </a></h2>
<p><a href="http://shomy.top/2017/03/15/blending-bagging/" target="_blank" rel="noopener">机器学习技法笔记(9)-Blending and Bagging(模型融合)</a><br>
<a href="http://blog.csdn.net/Mr_tyting/article/details/72957853" target="_blank" rel="noopener">机器学习–&gt;集成学习–&gt;Bagging,Boosting,Stacking</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>模型融合</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>缺失值处理</title>
    <url>/2018/01/22/missing-value/</url>
    <content><![CDATA[<p>当我们拿到一批数据的时候，往往都是“不干净”的，而缺失值是最常见也是最容易发现的。不同的缺失值处理方式对接下来的特征提取，建模等都有巨大影响。那么缺失值的处理是有一套流程的，我在这里总结总结：</p>
<a id="more"></a>
<h2><span id="发现缺失值">发现缺失值</span><a href="#发现缺失值" class="header-anchor"> </a></h2>
<ol>
<li>统计每个<strong>特征</strong>在所有个体中缺失的个数 / 缺失率<br>
这一点是查找缺失的<strong>特征</strong><br>
pandas 中 count() 函数为不为空数据的个数，那么将shape与count做差就得到缺失个数，缺失率。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(df.shape[<span class="number">0</span>] - df.count())/df.shape[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p><img src="//img.tianle.me/image/20180122/1.png" alt="missing"></p>
<ol start="2">
<li>对于每个<strong>个体</strong>所缺失的特征个数<br>
这一点是查找缺失的<strong>个体</strong><br>
这个简单，对数据 df 转置一下即可</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(df.shape[<span class="number">1</span>] - df.T.count())/df.shape[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>pandas 其他缺失值函数</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>dropna</td>
<td>根据各标签的值中是否存在缺失数据对轴标签进行过滤, 可通过阀值调节对缺失值的容忍度</td>
</tr>
<tr>
<td>fillna</td>
<td>用指定值或插值方法(如ffill或bfill)填充缺失值</td>
</tr>
<tr>
<td>isnull</td>
<td>返回一个含有bool型的对象, 这些bool型值表示哪些是缺失值NaN, 该对象的类型与源类型一样</td>
</tr>
<tr>
<td>notnull</td>
<td>isnull的否定式</td>
</tr>
</tbody>
</table>
<ol start="4">
<li>隐藏的缺失值<br>
这里要理解数据集内容的含义，比如在某些情况下，0代表缺失值。因为有些值为0的变量是无意义的，可以表示为缺失值。例如：身高、体重等。</li>
</ol>
<h2><span id="缺失机制">缺失机制</span><a href="#缺失机制" class="header-anchor"> </a></h2>
<p>在对缺失数据进行处理前，了解数据缺失的机制和形式是十分必要的。将数据集中不含缺失值的变量（属性）称为完全变量，数据集中含有缺失值的变量称为不完全变量，Little 和 Rubin定义了以下三种不同的数据缺失机制：</p>
<ol>
<li>
<p>完全随机缺失（Missing Completely at Random，MCAR）。数据的缺失与不完全变量以及完全变量都是无关的。</p>
</li>
<li>
<p>随机缺失（Missing at Random，MAR）。数据的缺失仅仅依赖于完全变量。</p>
</li>
<li>
<p>非随机、不可忽略缺失（Not Missing at Random,NMAR，or nonignorable）。不完全变量中数据的缺失依赖于不完全变量本身，这种缺失是不可忽略的。</p>
</li>
</ol>
<p>从缺失值的所属属性上讲，如果所有的缺失值都是同一属性，那么这种缺失成为单值缺失，如果缺失值属于不同的属性，称为任意缺失。另外对于时间序列类的数据，可能存在随着时间的缺失，这种缺失称为单调缺失。</p>
<h3><span id="空值语义">空值语义</span><a href="#空值语义" class="header-anchor"> </a></h3>
<p>对于某个对象的属性值未知的情况，我们称它在该属性的取值为空值(null value)。空值的来源有许多种，因此现实世界中的空值语义也比较复杂。总的说来，可以把空值分成以下三类：</p>
<ol>
<li>不存在型空值。即无法填入的值，或称对象在该属性上无法取值，如一个未婚者的配偶姓名等。</li>
<li>存在型空值。即对象在该属性上取值是存在的，但暂时无法知道。一旦对象在该属性上的实际值被确知以后，人们就可以用相应的实际值来取代原来的空值，使信息趋于完全。存在型空值是不确定性的一种表征，该类空值的实际值在当前是未知的。但它有确定性的一面，诸如它的实际值确实存在，总是落在一个人们可以确定的区间内。一般情况下，空值是指存在型空值。</li>
<li>占位型空值。即无法确定是不存在型空值还是存在型空值，这要随着时间的推移才能够清楚，是最不确定的一类。这种空值除填充空位外，并不代表任何其他信息。</li>
</ol>
<h2><span id="判断缺失值的重要性">判断缺失值的重要性</span><a href="#判断缺失值的重要性" class="header-anchor"> </a></h2>
<p>对于包含有缺失值处理的算法，比如XGB或者LGB，我们可以简单的直接把训练数据扔到模型中训练，查看feature_importance。（由于XGB等属于树模型，不需要太多的数据预处理过程，比如归一化等，也能取得较好的效果，且模型参数对特征的重要性程度影响不是很大，我们只需要知道大概的结果，哪些重要，哪些不重要即可）</p>
<h2><span id="缺失值较多且不重要的特征">缺失值较多且不重要的特征</span><a href="#缺失值较多且不重要的特征" class="header-anchor"> </a></h2>
<p>这些特征我们看情况，可以尝试着直接删除，如果不删除，缺失值又多，处理不好，可能会引来噪声。<br>
至于为什么看情况呢，意思是，做个对比试验，一组是删除的，另一组是没删除的，进行交叉验证，如果删除后的结果比较好，那么就进行删除。</p>
<h2><span id="缺失值较少的特征">缺失值较少的特征</span><a href="#缺失值较少的特征" class="header-anchor"> </a></h2>
<h3><span id="统计量填充">统计量填充</span><a href="#统计量填充" class="header-anchor"> </a></h3>
<p>这一类特征，我们可以简单使用统计量比如：均值、中位数、众数 进行填充；<br>
对于连续值，推荐使用 中位数 ，可以排除一些特别大或者特别小的异常值造成的影响；<br>
对于离散值，推荐使用 众数 ，均值和中位数用不了吧，那就用众数好了。。。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = df.fillna(df.median(axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h3><span id="特殊值填充">特殊值填充</span><a href="#特殊值填充" class="header-anchor"> </a></h3>
<p>我们可以填一个不在正常取值范围内的数值，比如 -999 ，0 等来表示缺失值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.fillna(<span class="number">-999</span>)</span><br></pre></td></tr></table></figure>
<h3><span id="不处理">不处理</span><a href="#不处理" class="header-anchor"> </a></h3>
<p>大家可能都有一个疑惑，为什么对很多人说XGB或者LGB对缺失值不敏感呢，当用缺失值的训练XGB时，算法不会报错，其实这个不能叫不敏感，而是算法本身自己有一套缺失值处理算法，比如XGB，它会把含有缺失值的数据分别分到左右两个子节点，然后计算着两种情况的损失，最后，选取较好的划分结果和对应的损失。XGB缺失值具体算法可以参考我之前的文章<a href="http://tianle.me/2018/01/09/xgboost-note/">XGBoost笔记</a>。<br>
所以，如果遇到有缺失值的情况，最好还是根据缺失的情况，自己处理比较好。</p>
<h3><span id="分类别填充">分类别填充</span><a href="#分类别填充" class="header-anchor"> </a></h3>
<p>我们还可以根据label的类别，取值范围进行更高级的统计量填充（当然这个只适用于知道label的训练集），即取在该label下数据的中位数、均值等进行填充。</p>
<h3><span id="插值填充">插值填充</span><a href="#插值填充" class="header-anchor"> </a></h3>
<p>使用线性，多项式等差值方法，对于时间序列的缺失问题，可以使用此方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.interpolate()</span><br></pre></td></tr></table></figure>
<p><img src="//img.tianle.me/image/20180122/2.png" alt="插值填充"></p>
<h3><span id="插补法">插补法</span><a href="#插补法" class="header-anchor"> </a></h3>
<ol>
<li>随机插补法----从总体中随机抽取某个样本代替缺失样本</li>
<li>多重插补法----通过变量之间的关系对缺失数据进行预测，利用蒙特卡洛方法生成多个完整的数据集，在对这些数据集进行分析，最后对分析结果进行汇总处理</li>
<li>热平台插补----指在非缺失数据集中找到一个与缺失值所在样本相似的样本（匹配样本），利用其中的观测值对缺失值进行插补<br>
优点：简单易行，准去率较高<br>
缺点：变量数量较多时，通常很难找到与需要插补样本完全相同的样本。但我们可以按照某些变量将数据分层，在层中对缺失值实用均值插补</li>
<li>拉格朗日差值法和牛顿插值法</li>
</ol>
<h3><span id="用预测值填充">用预测值填充</span><a href="#用预测值填充" class="header-anchor"> </a></h3>
<p>将缺失的数据当成label，没缺失的作为训练集，缺失的作为测试集，通过某种机器学习算法进行预测，填补缺失值。下面代码以lgb为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_missing</span><span class="params">(df, predict_list)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> predict_feature <span class="keyword">in</span> predict_list:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 原始数据分为已知和未知的</span></span><br><span class="line">        known = df[df[predict_feature].notnull()]</span><br><span class="line">        unknown = df[df[predict_feature].isnull()]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 训练集构造，从已知的部分构造</span></span><br><span class="line">        y = known[predict_feature].as_matrix()</span><br><span class="line">        X = known.drop(predict_feature, axis=<span class="number">1</span>).as_matrix()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 测试集，从未知的部分构造</span></span><br><span class="line">        test_X = unknown.drop(predict_feature, axis=<span class="number">1</span>).as_matrix()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用lgb模型进行训练</span></span><br><span class="line">        predicted_feature = _model_predict(X, y, test_X)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用得到的预测结果填补原缺失数据</span></span><br><span class="line">        df.loc[(df[predict_feature].isnull()), predict_feature] = predicted_feature</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> df</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_model_predict</span><span class="params">(X, y, test_X)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    lgb_train = lgb.Dataset(X_train, y_train)</span><br><span class="line">    lgb_eval = lgb.Dataset(X_test, y_test, reference=lgb_train)</span><br><span class="line"></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">'boosting'</span>: <span class="string">'gbdt'</span>,</span><br><span class="line">        <span class="string">'objective'</span>: <span class="string">'regression'</span>,</span><br><span class="line">        <span class="string">'metric'</span>: <span class="string">'rmse'</span>,</span><br><span class="line">        <span class="string">'num_leaves'</span>: <span class="number">31</span>,</span><br><span class="line">        <span class="string">'min_data_in_leaf'</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="string">'learning_rate'</span>: <span class="number">0.015</span>,</span><br><span class="line">        <span class="string">'cat_smooth'</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="string">'feature_fraction'</span>: <span class="number">0.8</span>,</span><br><span class="line">        <span class="string">'bagging_freq'</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">'verbosity'</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    gbm = lgb.train(params,</span><br><span class="line">                    lgb_train,</span><br><span class="line">                    num_boost_round=<span class="number">1000</span>,</span><br><span class="line">                    valid_sets=lgb_eval,</span><br><span class="line">                    early_stopping_rounds=<span class="number">70</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用得到的模型进行未知年龄结果预测</span></span><br><span class="line">    predicted_feature = gbm.predict(test_X, num_iteration=gbm.best_iteration)</span><br><span class="line">    print(<span class="string">"---------best_iteration: "</span>, gbm.best_iteration)</span><br><span class="line">    <span class="keyword">return</span> predicted_feature</span><br></pre></td></tr></table></figure>
<h2><span id="缺失值比较多的样本">缺失值比较多的样本</span><a href="#缺失值比较多的样本" class="header-anchor"> </a></h2>
<p>当样本很多的时候，而缺失值比较多的样本，且它们数目不多时，直接删掉。</p>
<h2><span id="参考资料">参考资料</span><a href="#参考资料" class="header-anchor"> </a></h2>
<p><a href="http://blog.sina.com.cn/s/blog_670445240102v08m.html" target="_blank" rel="noopener">缺失值的处理</a><br>
<a href="https://www.zhihu.com/question/26639110" target="_blank" rel="noopener">机器学习中如何处理缺失数据？</a><br>
<a href="https://zh.wikipedia.org/zh/%E7%BC%BA%E5%A4%B1%E6%95%B0%E6%8D%AE" target="_blank" rel="noopener">缺失数据</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>数据挖掘</tag>
        <tag>竞赛</tag>
        <tag>缺失值</tag>
        <tag>特征工程</tag>
      </tags>
  </entry>
  <entry>
    <title>XGBoost笔记</title>
    <url>/2018/01/09/xgboost-note/</url>
    <content><![CDATA[<h2><span id="前言">前言</span><a href="#前言" class="header-anchor"> </a></h2>
<p>做过数据竞赛的同学对XGBoost肯定不会陌生，它在各类竞赛中大放异彩。它比GBDT有着更快的运行速度以及更高的准确率。在许多Kaggle以及天池竞赛中，第一名的队伍都使用了XGBoost。它无论在分类还是回归问题上都有卓越的表现。<br>
我们可能只会用XGBoost，但是对其内部实现确不清楚，为了能够更深入地了解算法细节，本人阅读了作者的论文<a href="https://arxiv.org/abs/1603.02754" target="_blank" rel="noopener">XGBoost: A Scalable Tree Boosting System</a> ，并参考其他资料，完成本文。</p>
<a id="more"></a>
<h2><span id="提升树介绍">提升树介绍</span><a href="#提升树介绍" class="header-anchor"> </a></h2>
<h3><span id="集合树的计算方法">集合树的计算方法</span><a href="#集合树的计算方法" class="header-anchor"> </a></h3>
<p>给定<code>m</code>维的<code>n</code>个数据</p>
$$D = \{ ({{\mathbf{x}}_i},{y_i})\} (\left| D \right| = n,{{\mathbf{x}}_i} \in {\mathbb{R}^m},{y_i} \in \mathbb{R})$$
<p>树的集成方法使用<code>K</code>个方程来预测输出，也就是把各个树的预测结果累加作为算法的最终结果。
<img src="//img.tianle.me/image/20180109/f1.png" alt="image"><br>
<code>F</code>表示回归树的模型（如：CART），一个回归树对应着输入空间（即特征空间）的一个划分以及在划分单元上输出值。<br>
<code>q</code>表示每一棵树的结构，也就是每一个数据映射到叶子索引上。<code>T</code>是树的叶子数目。每一个$f_k$对应着一棵独立的树
<img src="//img.tianle.me/image/20180109/f2.png" alt="image"><br>
上图展示了树集成模型的计算方法。提升方法实际采用加法模型（即基函数的线性组合）与前向分布算法。以决策树为基函数的提升方法称为提升树（boosting tree)。对分类问题决策树是二叉分类树，对回归问题决策树是二叉决策树。提升树模型可以表示为决策树的加法模型。</p>
<h3><span id="正则化学习目标">正则化学习目标</span><a href="#正则化学习目标" class="header-anchor"> </a></h3>
<p>为了学习树模型中的参数，构造了如下带有正则化项的目标函数：<br>
<img src="//img.tianle.me/image/20180109/f3.png" alt="image"><br>
其中<code>l</code>为凸的损失函数，<code>omega</code>为模型复杂度的代价函数，可以减少过拟合的风险。</p>
<h3><span id="梯度提升树">梯度提升树</span><a href="#梯度提升树" class="header-anchor"> </a></h3>
<p>提升树采用向前分步算法，首先确定初始提升树${y_0} = 0$，第<code>t</code>步的模型是${y_t} = {y_{t - 1}} + {f_t}({\mathbf{x}})$ 其中，${y_{t - 1}}$为当前模型。<br>
<img src="//img.tianle.me/image/20180109/f11.png" alt="image"><br>
通过经验风险极小化确定下一棵决策树的参数<code>q</code>，构造如下的损失函数：<br>
<img src="//img.tianle.me/image/20180109/f4.png" alt="image"><br>
这意味着，我们可以通过不断添加${f_t}$来优化上面的损失函数。二阶相似性可以快速的优化损失函数。<br>
<img src="//img.tianle.me/image/20180109/f5.png" alt="image"><br>
去掉常数项，化简为：<br>
<img src="//img.tianle.me/image/20180109/f6.png" alt="image"><br>
最后，噼里啪啦一顿操作得到红框中的公式：<br>
<img src="//img.tianle.me/image/20180109/f7.png" alt="image"><br>
红框中的式子可以被用来衡量树结构<code>q</code>。<br>
决策树需要找到一个最优的切分变量和切分点，令$I = {I_L} \cup {I_R}$，$I_L$ 和 $I_L$ 为某个实例集合完成切分后的两个节点。那么它的损失减少量可以由下式表示：<br>
<img src="//img.tianle.me/image/20180109/f8.png" alt="image"></p>
<h3><span id="剪枝和列采样">剪枝和列采样</span><a href="#剪枝和列采样" class="header-anchor"> </a></h3>
<p>上面的目标函数可以通过添加正则化项来减少过拟合，同样在很多算法中还使用了剪枝和列采样的方式来减少过拟合。</p>
<h2><span id="切分点查找算法">切分点查找算法</span><a href="#切分点查找算法" class="header-anchor"> </a></h2>
<h3><span id="传统的精确贪心算法basic-exact-greedy-algorithm">传统的精确贪心算法（Basic Exact Greedy Algorithm）</span><a href="#传统的精确贪心算法basic-exact-greedy-algorithm" class="header-anchor"> </a></h3>
<p>在一般的算法中，如sklearn，以及R语音的gbm，以及简单版本的xgboost都使用这一方法。它需要贪心地去遍历每一个可能的切分点，然后通过 式(7) 来找到最优的切分点。为了提高效率，算法必须先对特征的值进行一个排序，然后遍历这个有序的特征值，计算他们的累计梯度值，从而得到最大的损失降低量，具体算法如下图所示：<br>
<img src="//img.tianle.me/image/20180109/f9.png" alt="image"></p>
<blockquote>
<p>（这个是不是传中的预排序？？）</p>
</blockquote>
<p>例：<br>
对于每次扩展，我们还是要枚举所有可能的分割方案，如何高效地枚举所有的分割呢？我假设我们要枚举所有$x &lt; a$这样的条件，对于某个特定的分割$a$我们要计算$a$左边和右边的导数和。
<img src="//img.tianle.me/image/20180109/f10.png" alt="image"><br>
我们可以发现对于所有的a，我们只要做一遍从左到右的扫描就可以枚举出所有分割的梯度和$G_L$和$G_R$。然后用上面的公式计算每个分割方案的分数就可以了。</p>
<h3><span id="近似分裂算法">近似分裂算法</span><a href="#近似分裂算法" class="header-anchor"> </a></h3>
<p>传统的分裂方法虽然精确，但是十分耗时，而且一旦数据较多，非常占用内存，也不利于并行化。xbg提出了一种近似的算法，具体如下：<br>
<img src="//img.tianle.me/image/20180109/f12.png" alt="image"><br>
对于每个特征，只考察分位点，减少计算复杂度</p>
<ul>
<li>Global：学习每棵树前，提出候选切分点</li>
<li>Local：每次分裂前，重新提出候选切分点</li>
</ul>
<blockquote>
<p>近似算法举例：三分位数<br>
<img src="//img.tianle.me/image/20180109/f14.png" alt="image"></p>
</blockquote>
<p>实际上XGBoost不是简单地按照样本个数进行分位，而是以二阶导数值$h_i$作为权重(WeightedQuantileSketch)，比如:<br>
<img src="//img.tianle.me/image/20180109/f15.png" alt="image"><br>
为什么用$h_i$加权？<br>
把目标函数整理成以下形式，可以看出$h_i$有对loss加权的作用<br>
<img src="//img.tianle.me/image/20180109/f16.png" alt="image"></p>
<p>同时，xgb还有处理稀疏数据的算法：<br>
真实数据中，稀疏是比较普遍的，造成稀疏的原因主要有以下几点：</p>
<ul>
<li>存在缺失值</li>
<li>有很多0</li>
<li>人造特征，比如ont-hot编码<br>
<img src="//img.tianle.me/image/20180109/f13.png" alt="image"><br>
从该算法中，我们可以看出XGBoost缺失值处理方式是，对于某一个特征，假设所有缺失的样本属于右子树或者左子树，然后分别计算其损失减少量得分，最后取其最高值对应的分裂位和得分值。</li>
</ul>
<h2><span id="其他">其他</span><a href="#其他" class="header-anchor"> </a></h2>
<p>并行化，Column Block for Parallel Learning<br>
XGBoost的特征重要性是如何得到的？某个特征的重要性（feature score），等于它被选中为树节点分裂特征的次数的和，比如特征A在第一次迭代中（即第一棵树）被选中了1次去分裂树节点，在第二次迭代被选中2次……那么最终特征A的feature score就是 1+2+….</p>
<h3><span id="含有缺失进行训练">含有缺失进行训练</span><a href="#含有缺失进行训练" class="header-anchor"> </a></h3>
<p>dtrain = xgb.DMatrix(x_train, y_train, missing=np.nan）</p>
<h2><span id="xgboost相比传统gbdt有何不同">xgboost相比传统gbdt有何不同？</span><a href="#xgboost相比传统gbdt有何不同" class="header-anchor"> </a></h2>
<p>作者：wepon<br>
链接： <a href="https://www.zhihu.com/question/41354392/answer/98658997" target="_blank" rel="noopener">https://www.zhihu.com/question/41354392/answer/98658997</a><br>
来源：知乎<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<ul>
<li>传统GBDT以CART作为基分类器，xgboost还支持线性分类器，这个时候xgboost相当于带L1和L2正则化项的逻辑斯蒂回归（分类问题）或者线性回归（回归问题）。传统GBDT在优化时只用到一阶导数信息，xgboost则对代价函数进行了二阶泰勒展开，同时用到了一阶和二阶导数。顺便提一下，xgboost工具支持自定义代价函数，只要函数可一阶和二阶求导。</li>
<li>xgboost在代价函数里加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子节点个数、每个叶子节点上输出的score的L2模的平方和。从Bias-variance tradeoff角度来讲，正则项降低了模型的variance，使学习出来的模型更加简单，防止过拟合，这也是xgboost优于传统GBDT的一个特性。</li>
<li>Shrinkage（缩减），相当于学习速率（xgboost中的eta）。xgboost在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间。实际应用中，一般把eta设置得小一点，然后迭代次数设置得大一点。（补充：传统GBDT的实现也有学习速率）</li>
<li>列抽样（column subsampling）。xgboost借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算，这也是xgboost异于传统gbdt的一个特性。对缺失值的处理。对于特征的值有缺失的样本，xgboost可以自动学习出它的分裂方向。</li>
<li>xgboost工具支持并行。boosting不是一种串行的结构吗?怎么并行的？注意xgboost的并行不是tree粒度的并行，xgboost也是一次迭代完才能进行下一次迭代的（第t次迭代的代价函数里包含了前面t-1次迭代的预测值）。xgboost的并行是在特征粒度上的。我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），xgboost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。可并行的近似直方图算法。树节点在进行分裂时，我们需要计算每个特征的每个分割点对应的增益，即用贪心法枚举所有可能的分割点。当数据无法一次载入内存或者在分布式情况下，贪心算法效率就会变得很低，所以xgboost还提出了一种可并行的近似直方图算法，用于高效地生成候选的分割点。</li>
</ul>
<h2><span id="参考资料">参考资料</span><a href="#参考资料" class="header-anchor"> </a></h2>
<p><a href="https://arxiv.org/abs/1603.02754" target="_blank" rel="noopener">XGBoost: A Scalable Tree Boosting System</a><br>
<a href="https://xgboost.readthedocs.io/en/latest/model.html" target="_blank" rel="noopener">Introduction to Boosted Trees</a><br>
<a href="http://blog.csdn.net/a819825294/article/details/51206410" target="_blank" rel="noopener">xgboost原理 </a><br>
<a href="http://free.tianle.me/image/20180109/xgboost.pdf" target="_blank" rel="noopener">xgboost导读和实战.pdf</a><br>
<a href="http://free.tianle.me/image/20180109/wepon_gbdt.pdf" target="_blank" rel="noopener">wepon_gbdt_ppt.pdf</a><br>
<a href="https://github.com/dmlc/xgboost" target="_blank" rel="noopener">xgboost github项目地址</a><br>
<a href="http://free.tianle.me/image/20180109/BoostedTree.pdf" target="_blank" rel="noopener">Introduction to Boosted Trees_ppt_pdf</a><br>
<a href="http://wepon.me/2016/05/07/XGBoost%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA/" target="_blank" rel="noopener">XGBoost浅入浅出</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>XGBoost</tag>
        <tag>数据竞赛</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>我的2017</title>
    <url>/2017/12/29/my2017/</url>
    <content><![CDATA[<p>站在17年年底，回头看看这一年，猛地感觉就是时间过得太快太快。想做很多事，但好像又是什么都没做。在17年的尾巴上拼命追赶，希望能补回些什么。</p>
<a id="more"></a>
<h2><span id="学习">学习</span><a href="#学习" class="header-anchor"> </a></h2>
<h3><span id="研究">研究</span><a href="#研究" class="header-anchor"> </a></h3>
<p>作为学生，学习还是得放在第一位。在去年的这个时候，师兄和我商量着要写一篇关于深度学习的文章，并计划半年完成。刚开工的时候，进度还可以，看论文，刷刷刷地写代码，每隔一段时间和师兄讨论一下想法。但是做着做着，就遇到瓶颈了，实验仿真效果一直不好，期间也尝试着各种想法，但是依旧没有什么改善。然后呢，我懒惰的天性就暴露出来了，实验效果不好，改着改着，就改不动了。接下来又是傻乎乎，漫无目的看论文。我在实验上面卡住了很多时间，论文也没有开始写，本来进度还可以，这么一卡，进度就慢了。突然间，和我一届的哥们投出了一篇论文，大修之后，立刻录用，瞬间，我觉得压力山大，得要赶紧写了。再到后来，只好硬着头皮写论文，其实，写的时候还好，多看看文章，就能发现一些套路。比如：</p>
<p>首先abstract；再introduction，讲讲当今的研究趋势、为什么要做这个题目、有什么好处、有哪些应用、怎么想到的、动机是什么、本工作有什么特色 亮点等等，这部分要好好写写；接下来related works，目前已经有哪些工作，优缺点，本工作的亮点；然后还可以写预备知识preliminaries，本工作用到了哪些已知知识；然后才是本工作的主要内容，写论文提出的算法，自己提出的东西的是要写得牛逼一点，比如来点定义啊啥的，看起来比较高深。。。；再后来就是experiments实验部分了，这一块不光可以和其他算法比，也可以自己和自己比，说明自己提出的哪一点是有效果的。还有啊，实验的结果图尽量多分析分析，不要只有几句话，a比b好就完了，可以多扯一些理由，比如，曲线的趋势是怎么样的，快速（缓慢）增长、a比b好很多（差距不大），转折点等等，总之不要放过每一个细节，还有啊，为什么a要比b好，又是分析一波。这样一写，人家会觉得你实验做得比较充分，分析到位，不是随便做的，水水的那种。以前我看文章的时候，总是把实验忽略了，现在在自己写的时候，又把以前没看的实验部分好好补了补；最后就是conclusion总结啦，把文章中的创新点，亮点再提一提，总结概括一下，也可以简单地写一写未来工作。</p>
<p>经过在n轮师兄的耐心修改帮助下，至少改过7、8次，真是麻烦师兄了，得要好好谢谢师兄！其中也体会到，论文是改出来的。。。 终于在今年的年末把弄了将近一年的论文投了出去，也算是完成一个小任务吧。</p>
<h3><span id="竞赛">竞赛</span><a href="#竞赛" class="header-anchor"> </a></h3>
<p>做完论文后，立刻开始准备大数据竞赛，因为今后打算往大数据，数据挖掘，机器学习方向上发展。况且实验室里也有位天池拿过第四名的大佬，遇到问题还可以向师兄请教请教。我的第一个比赛是京东金融的借贷量预测，在这个比赛中，从刚开始的什么都不会，逐渐掌握了数据竞赛常用的算法和python常用包的使用，可以说是边学习边比赛吧，最终的成绩是48/700+, 这个结果还算过得去吧，毕竟是第一次比赛，但还是有些遗憾。整个比赛下来，感觉大部分的时间都在特征工程上，构造各种各样的特征。比赛的总结写在<a href="http://tianle.me/2017/12/12/jd/">2017京东金融信贷需求预测 赛题总结</a>。</p>
<h3><span id="上课">上课</span><a href="#上课" class="header-anchor"> </a></h3>
<p>这个就比较尴尬了，特别是研一上学期《最优化方法》这门课考烂了，导致平均分下降很多，而我们老板自己的课又没有选上，错失一个大大的提分机会。要不是最后总评的时候，老板给我的分高，可能奖学金就没了。。。</p>
<p>不过，高兴的是，听说英语老师竟然给了我85+，写作的分数也不低，要知道我最烂的就是英语了，我知道自己考试的时候分数可能不会高，但是有平时分啊，因此上课时拼命地回答问题，与老师互动，上课留下的作业也是认认真真的完成，估计是给老师留下了个好印象吧，因此最后期末分相对于其他人还挺高。</p>
<h3><span id="六级">六级</span><a href="#六级" class="header-anchor"> </a></h3>
<p>六级啊，六级，唉，说多了都是泪，o(╥﹏╥)o</p>
<h2><span id="工作">工作</span><a href="#工作" class="header-anchor"> </a></h2>
<p>这里的工作指的是学生工作</p>
<h3><span id="研究生会">研究生会</span><a href="#研究生会" class="header-anchor"> </a></h3>
<p>加入研究生会的主要目的就是想多认识人，要是能认识到女朋友那是极好的，可是到目前还是没得。</p>
<p>总的来说研究生会要比本科的学生会少了很多事，毕竟大家都那么大了，而且学习、科研都比较忙，没空搞杂七杂八的事。嗯~ 所以呢，我也偷懒了。最开始的时候加了校研会的交流部和院研会的宣传部，但是后面精力有限啊，大概过了半个多学期吧，校研会就退了，比较学习和搞科研更重要嘛。</p>
<p>在研究生会里面，做的最多的还是打杂了，我呢，还是和以前差不多，做做PS，海报，不过，相对于本科，这里老师让学生干活，还有发劳务费，这点还是挺开心的。</p>
<h2><span id="娱乐">娱乐</span><a href="#娱乐" class="header-anchor"> </a></h2>
<p>这一年里玩的还是挺多的，从 吃 和 游玩 两个方面展开吧。</p>
<h3><span id="玩">玩</span><a href="#玩" class="header-anchor"> </a></h3>
<p>来西安后，去的地方还是比较多的，甚至比原来本科在西安的同学去过的地方还要多。今年前前后后接待了不少西安玩的朋友，每隔一两个月，就有朋友来西安。光是华山，就去两遍，一次夜爬，一次日爬，可以说把华山两种爬法都玩了一遍。特别值得一提的是“滑雪”，真是有意思~ 在北方，可要好好体验体验，以后回家了，机会就少了好多呢。</p>
<h3><span id="吃">吃</span><a href="#吃" class="header-anchor"> </a></h3>
<p>实验室有位对吃灰常有研究的师兄，几乎每天都在琢磨这哪里哪里有好吃的。我最服的是，平日里为了吃个晚饭，都能坐半个小时公交。当然为了能吃到好吃的，咋们肯定要跟着师兄混嘛，哈哈哈！我在西安吃过的东西，至少有个百分之八九十都是师兄带的吧。如果你想知道西安有什么好吃的，哪里最地道，找师兄保证没问题。准备好，下面开始放毒~</p>
<h2><span id="下一年的计划">下一年的计划</span><a href="#下一年的计划" class="header-anchor"> </a></h2>
<p>最核心的当然是找工作喽，围绕这一点，从以下几个方面展开：</p>
<ol>
<li>基础知识，如数据结构、算法等。看书、刷题；</li>
<li>大数据、数据挖掘、人工智能等知识。 看书、竞赛；</li>
<li>实习</li>
<li>英语</li>
</ol>
<p>除了找工作之外，还得陶冶陶冶情操吧，比如：多看看社科类的文学书籍、还有一些经典电影。找完工作之后呢，再好好出去玩玩。</p>
<h2><span id="附图">附图</span><a href="#附图" class="header-anchor"> </a></h2>
<p><img src="//img.tianle.me/image/20171229/1.jpg" alt="pic"><br>
<img src="//img.tianle.me/image/20171229/2.jpg" alt="pic"><br>
<img src="//img.tianle.me/image/20171229/6.jpg" alt="pic"><br>
<img src="//img.tianle.me/image/20171229/8.jpg" alt="pic"><br>
<img src="//img.tianle.me/image/20171229/12.jpg" alt="pic"><br>
<img src="//img.tianle.me/image/20171229/15.jpg" alt="pic"><br>
<img src="//img.tianle.me/image/20171229/17.jpg" alt="pic"><br>
<img src="//img.tianle.me/image/20171229/3.jpg" alt="pic"><br>
<img src="//img.tianle.me/image/20171229/4.jpg" alt="pic"><br>
<img src="//img.tianle.me/image/20171229/5.jpg" alt="pic"><br>
<img src="//img.tianle.me/image/20171229/7.jpg" alt="pic"><br>
<img src="//img.tianle.me/image/20171229/16.jpg" alt="pic"></p>
<p><img src="//img.tianle.me/image/20171229/9.jpg" alt="pic"><br>
<img src="//img.tianle.me/image/20171229/11.jpg" alt="pic"><br>
<img src="//img.tianle.me/image/20171229/14.jpg" alt="pic"><br>
<img src="//img.tianle.me/image/20171229/13.jpg" alt="pic"><br>
<img src="//img.tianle.me/image/20171229/10.jpg" alt="pic"></p>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>决策树笔记</title>
    <url>/2017/12/28/decision-tree/</url>
    <content><![CDATA[<h2><span id="特征选择">特征选择</span><a href="#特征选择" class="header-anchor"> </a></h2>
<h3><span id="准则">准则</span><a href="#准则" class="header-anchor"> </a></h3>
<p>信息增益 或 信息增益比</p>
<a id="more"></a>
<blockquote>
<p>信息增益：<br>
表示得知特征X的信息而使得类Y的信息不确定性减少的程度。
特征A对训练数据集D的信息增益g(D,A)，定义为集合D的经验熵H(D)与特征A给定条件下D的经验条件熵H(D|A)之差。</p>
</blockquote>
$$g(D,A) = H(D) - H(D|A)$$ 
<blockquote>
<p>信息增益比：<br>
以信息增益作为划分训练集的特征，存在偏向于选择取值较多的特征的问题。使用信息增益比可以对这一问题进行校正。</p>
</blockquote>
$${g_R}(D,A) = \frac{{g(D,A)}}{{{H_A}(D)}}$$ 
<h2><span id="决策树的生成">决策树的生成</span><a href="#决策树的生成" class="header-anchor"> </a></h2>
<h3><span id="id3算法">ID3算法</span><a href="#id3算法" class="header-anchor"> </a></h3>
<p>应用<strong>信息增益</strong>准则选择特征，递归地构建决策树。</p>
<h3><span id="c45算法">C4.5算法</span><a href="#c45算法" class="header-anchor"> </a></h3>
<p>用<strong>信息增益比</strong>来选择特征。</p>
<h2><span id="决策树的剪枝">决策树的剪枝</span><a href="#决策树的剪枝" class="header-anchor"> </a></h2>
<p>防止过拟合<br>
极小化决策树的整体损失函数(loss function)或代价函数(cost funciton)</p>
$${C_\alpha }(T) = \sum\limits_{t = 1}^{|T|} {{N_t}{H_t}(T) + \alpha |T|}$$ 
<p>其中${H_t}(T)$为叶节点$t$上的经验熵：</p>
$${H_t}(T) =  - \sum\limits_k {\frac{{{N_{tk}}}}{{{N_t}}}\log \frac{{{N_{tk}}}}{{{N_t}}}}$$ 
<h2><span id="cart算法">CART算法</span><a href="#cart算法" class="header-anchor"> </a></h2>
<p>分类与回归树(classification and regression tree, CART)，既可以分类也可以回归。<br>
CART算法由以下两步组成：</p>
<ol>
<li>决策树生成；</li>
<li>决策树剪枝。</li>
</ol>
<p>决策树的生成就是递归地构建二叉决策树的过程。对回归树用<strong>平方误差</strong>最小化准则，对分类树用<strong>基尼指数</strong>（Gini index）最小化准则，进行特征选择，生成二叉树。</p>
<h3><span id="决策树生成">决策树生成</span><a href="#决策树生成" class="header-anchor"> </a></h3>
<h4><span id="回归树">回归树</span><a href="#回归树" class="header-anchor"> </a></h4>
<p>《统计学习》 P69<br>
最小二乘回归树生成算法：<br>
在训练数据集所在的输入空间中，递归地将每个区域划分为两个子区域并决定每个子区域上的输出值，构建二叉决策树：</p>
<ol>
<li>选择最优切变量j与切分点s，（可以用平方误差来表示回归树对于训练数据的预测误差）</li>
</ol>
$$\mathop {\min }\limits_{j,s} [\mathop {\min }\limits_{{c_1}} \sum\limits_{{x_i} \in {R_1}(j,s)} {{{({y_i} - {c_1})}^2}}  + \mathop {\min }\limits_{{c_2}} \sum\limits_{{x_i} \in {R_2}(j,s)} {{{({y_i} - {c_2})}^2}} ]$$
<p>遍历遍历j，对固定的切分变量j扫描切分点s，选择使上式达到最小值的对(j,s)</p>
<ol start="2">
<li>用选定的对(j,s)划分区域并决定相对应的输出值：
$${R_1}(j,s) = \{ x|{x^{(j)}} \leqslant s\} ,{\text{  }}{R_2}(j,s) = \{ x|{x^{(j)}} > s\}$$
$${\hat c_m} = \frac{1}{{{N_m}}}\sum\limits_{{x_i} \in {R_m}(j,s)} {{y_i}} ,{\text{ }}x \in {R_m},{\text{ }}m = 1,2$$</li>
<li>继续对连个子区域调用步骤1,2，直至满足停止条件；</li>
<li>将输入空间划分为M个区域R1, R2, …, RM，生成决策树。
$$f(x) = \sum\limits_{m = 1}^M {{{\hat c}_m}I(x \in {R_m})} $$</li>
</ol>
<h4><span id="分类树生成">分类树生成</span><a href="#分类树生成" class="header-anchor"> </a></h4>
<p>基尼指数<br>
分类问题中，假设有K个类，样本点属于第k类的概率为pk，则概率分布的基尼指数定义为：</p>
$$Gini(p) = \sum\limits_{k = 1}^K {{p_k}(1 - {p_{\text{k}}}) = 1 - } \sum\limits_{k = 1}^K {p_k^2}$$
<p>如果样本集合D根据特征A是否取某一可能值a被分割成D1和D2两部分，即</p>
$${D_1} = \{ (x,y) \in D|A(x) = a\} ,{D_2} = D - {D_1}$$
<p>特征在A的条件下，集合D的基尼指数定义为</p>
$$Gini(D,A) = \frac{{|{D_1}|}}{{|D|}}Gini({D_1}) + \frac{{|{D_2}|}}{{|D|}}Gini({D_2})$$
<p>基尼指数Gini(D)表示集合D的不确定性，基尼指数Gini(D,A)表示经A=a分割后集合D的不确定性。基尼指数值越大，样本集合的不确定性也就越大，这一点与熵相似。</p>
<p>CART生成算法(p 70)：</p>
<ol>
<li><strong>计算现有特征对训练数据集的基尼指数。</strong> 此时，对每一个特征A，对其可能取的每个值a，根据样本点A=a的测试为“是”或“否”将D分为D1和D2两部分，利用Gini(D,A)计算A=a时的基尼系数；</li>
<li>在所有可能的特征以及它们所有可能的切分点a中，选择基尼指数<strong>最小</strong>的特征及其对应的切分点作为最优特征与最优切分点；依最优特征与最优切分点，从现节点生成两个子节点，将训练数据集依特征分配到两个子节点中去；</li>
<li>对两个子节点<strong>递归</strong>地调用（1），（2），直至满足停止条件。</li>
</ol>
<p>算法停止计算的条件是节点中的样本个数小于预定阈值，或样本集的基尼指数小于预定阈值（样本基本属于同一类），或者没有更多特征。</p>
<h2><span id="总结">总结</span><a href="#总结" class="header-anchor"> </a></h2>
<ol>
<li>决策树学习算法包括3部分：特征选择、树的生成、树的剪枝。</li>
<li>决策树的生成：通常使用信息增益最大、信息增益比最大或基尼指数最小作为特征选择的准则。</li>
<li>决策树的剪枝：往往从已生成的树上减掉一些叶节点或叶节点以上的子树，并将其父节点或根节点作为新的叶节点，从而简化生成的决策树。</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>机器学习</tag>
        <tag>decision tree</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>2017京东金融信贷需求预测 赛题总结</title>
    <url>/2017/12/12/jd/</url>
    <content><![CDATA[<h2><span id="赛题回顾">赛题回顾</span><a href="#赛题回顾" class="header-anchor"> </a></h2>
<p>京东金融提供8到11月的用户借款信息，订单购买信息，页面点击信息以及用户个人和贷款的初始额度信息；要求预测12月每个用户的贷款信息。评价方式采用RMSE函数：</p>
$$RMSE = \sqrt {\frac{1}{n}\sum\nolimits_{i = 1}^n {{{({y_i} - {{\hat y}_i})}^2}} } $$  
<p>其中yi真实值，y_hati为预测值，n为用户总数。<br>
<a href="https://github.com/zhangtianle/jd" target="_blank" rel="noopener">项目代码 github</a><br>
<a href="https://pan.baidu.com/s/1eSjeq9W" target="_blank" rel="noopener">数据下载,百度网盘</a>  密码：2lk3</p>
<a id="more"></a>
<p>---- 20171219更新 ----</p>
<blockquote>
<p>浪教授</p>
</blockquote>
<ol>
<li>以30天划分训练集，按30天为周期对齐；</li>
<li>滑动窗口特征，等差 每 7 天 10 天 等；</li>
<li>让预测月份的均值等于前几个月的均值（比赛前期）；</li>
<li>强特征：激活日期、loan time、可贷款金额、 pid param组合前20个 one-hot</li>
<li>模型融合，加权平均</li>
</ol>
<blockquote>
<p>第17名代码</p>
</blockquote>
<p><a href="https://github.com/klyan/JDD_Loan_Forecasting" target="_blank" rel="noopener">https://github.com/klyan/JDD_Loan_Forecasting</a></p>
<h2><span id="比赛结果">比赛结果</span><a href="#比赛结果" class="header-anchor"> </a></h2>
<p>A榜50，B榜48<br>
<img src="//img.tianle.me/image/20171212/a.png" alt="A榜"><br>
<img src="//img.tianle.me/image/20171212/b.png" alt="B榜"></p>
<h2><span id="解决方案">解决方案</span><a href="#解决方案" class="header-anchor"> </a></h2>
<ol>
<li>数据分析</li>
<li>区间划分</li>
<li>特征提取</li>
<li>模型分析</li>
<li>模型调参</li>
<li>模型融合</li>
</ol>
<h3><span id="数据分析">数据分析</span><a href="#数据分析" class="header-anchor"> </a></h3>
<p>在本次比赛中，数据分析比较少，仅仅是用 Jupyter Notebook 简单的画了几个图，没有针对数据情况进行特定的特征提取，基本上是想到什么特征就用什么特征，然后 总和、平均、最大、最小、方差 这几个来一套。这是本次比赛中不足的地方。<br>
赛题中对金额字段进行了加密，但是在竞赛群里，立刻就有大佬给出了加密（$y = {\log _5}(x + 1)$）和脱敏（$y = {5^x} + 1$）方法，我们直接使用该方法，效果提升非常明显。</p>
<h3><span id="区间划分">区间划分</span><a href="#区间划分" class="header-anchor"> </a></h3>
<p>采用传统的划窗法对数据划分，<strong>注意：在划分数据时，一定不能出现数据穿越，即 训练的数据集中用到预测的数据</strong> <em>（如：要预测11月的贷款数据，则在训练数据中不能包含11月的数据信息）</em> 否则会造成线下CV（交叉验证）效果非常好，但是线上糟糕。<br>
本次比赛的划分方式我们尝试了两种方案：</p>
<ul>
<li>方案一：</li>
</ul>
<table>
<thead>
<tr>
<th>0</th>
<th>特征区间（feature）</th>
<th>预测区间（llabel）</th>
</tr>
</thead>
<tbody>
<tr>
<td>训练集</td>
<td>2016-08-03到2016-10-31</td>
<td>2016-11-01到2016-11-30</td>
</tr>
<tr>
<td>测试集</td>
<td>2016-<strong>08</strong>-03到2016-11-30</td>
<td>2016-12-01到2016-12-31</td>
</tr>
</tbody>
</table>
<ul>
<li>方案二：<br>
将测试集中的8到11月改成9到11月，即</li>
</ul>
<table>
<thead>
<tr>
<th>0</th>
<th>特征区间（feature）</th>
<th>预测区间（llabel）</th>
</tr>
</thead>
<tbody>
<tr>
<td>训练集</td>
<td>2016-08-03到2016-10-31</td>
<td>2016-11-01到2016-11-30</td>
</tr>
<tr>
<td>测试集</td>
<td>2016-<strong>09</strong>-01到2016-11-30</td>
<td>2016-12-01到2016-12-31</td>
</tr>
</tbody>
</table>
<p>在实际测试中我们发现，本次比赛，在相同的特征提取方式下，方案一的结果优于方案二，因此采用方案一。</p>
<h3><span id="特征提取">特征提取</span><a href="#特征提取" class="header-anchor"> </a></h3>
<p>这就比较多了。。。。
参数说明：<br>
<code>start_month</code> 划分区间的起始月份<br>
<code>end_month</code> 划分区间的结束月份<br>
<code>NUM</code> 结束月份 - 起始月份 + 1，即 期间经过了<code>NUM</code>个月</p>
<h4><span id="user用户信息表">user用户信息表</span><a href="#user用户信息表" class="header-anchor"> </a></h4>
<table>
<thead>
<tr>
<th>特征名</th>
<th>特征含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>delta_time</td>
<td>结束时间 - 激活时间 （天）</td>
</tr>
<tr>
<td>start_delta_time</td>
<td>起始时间 - 激活时间 （天）</td>
</tr>
<tr>
<td>age，sex，limit</td>
<td>年龄，性别，初始额度 one-hot编码</td>
</tr>
</tbody>
</table>
<h4><span id="click点击信息表">click点击信息表</span><a href="#click点击信息表" class="header-anchor"> </a></h4>
<p>这个表貌似没什么用，也不知道这里面具体参数是什么含义，所以直接one-hot编码</p>
<table>
<thead>
<tr>
<th>特征名</th>
<th>特征含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>uid，param</td>
<td>点击页面，点击参数 one-hot编码</td>
</tr>
</tbody>
</table>
<h4><span id="loan贷款信息表">loan贷款信息表</span><a href="#loan贷款信息表" class="header-anchor"> </a></h4>
<table>
<thead>
<tr>
<th>特征名</th>
<th>特征含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>remain_days</td>
<td>到下个月的天数 （平均、方差、最大、最小） datetime(2016, end_month+ 1, 1) - parse(x)</td>
</tr>
<tr>
<td>pass_days</td>
<td>开始月的天数过去的天数 （平均、方差、最大、最小） parse(x) - dt.datetime(2016, start_month, 1)</td>
</tr>
<tr>
<td>over</td>
<td>计划时间是否超出时间</td>
</tr>
<tr>
<td>average_loan</td>
<td>平均每月贷款</td>
</tr>
<tr>
<td>loan_month</td>
<td>区间内贷款额（最大、最小、方差）</td>
</tr>
<tr>
<td>average_pay</td>
<td>每月月供（平均、最小、最大）</td>
</tr>
<tr>
<td>remain_loan</td>
<td>历史贷款总额</td>
</tr>
<tr>
<td>remain_pay</td>
<td>累计月供</td>
</tr>
<tr>
<td>current_loan_sum</td>
<td>当月月供（总和、最大、最小、平均、方差）</td>
</tr>
<tr>
<td>current_pay</td>
<td>当月贷款总额（总和、最大、最小、平均、方差）</td>
</tr>
<tr>
<td>pay_each</td>
<td>每一次月供（最大、最小、平均）</td>
</tr>
<tr>
<td>loan_each</td>
<td>每一贷款（最大、最小、平均）</td>
</tr>
<tr>
<td>average_plannum</td>
<td>平均贷款还款周期</td>
</tr>
</tbody>
</table>
<h4><span id="order订单信息表">order订单信息表</span><a href="#order订单信息表" class="header-anchor"> </a></h4>
<p>参数说明：<br>
<code>per_price</code>：用户购买单价<br>
<code>price_sum</code>：购买总和<br>
<code>discount_ratio</code>：优惠率</p>
<table>
<thead>
<tr>
<th>特征名</th>
<th>特征含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>price_sum_mean</td>
<td>每次购物的平均价格</td>
</tr>
<tr>
<td>num_order</td>
<td>每月购买次数（最大、最小、平均、方差）</td>
</tr>
<tr>
<td>price_each</td>
<td>每个用户每次消费（最大、最小、平均、方差）</td>
</tr>
<tr>
<td>price</td>
<td>每个用户购物价格（最大、最小、平均、方差）</td>
</tr>
<tr>
<td>real_price</td>
<td>每个用户购物折扣后总价（最大、最小、平均、方差）</td>
</tr>
<tr>
<td>average_discount</td>
<td>平均折扣</td>
</tr>
<tr>
<td>qty_each</td>
<td>每个用户每次购买（最大、最小、平均、方差）</td>
</tr>
<tr>
<td>discount_price_ration</td>
<td>历史折扣力度(平均、方差)</td>
</tr>
<tr>
<td>no_free_discount_ratio</td>
<td>每月非免费平均总价格/每月非免费平均折扣后的总价/每月非免费平均折扣力度/每月非免费平均折扣(平均、方差)</td>
</tr>
<tr>
<td>current_real_price</td>
<td>每个用户当月的购买物品总价格和(平均、方差)</td>
</tr>
<tr>
<td>current_price</td>
<td>当月平均单价（平均、方差）</td>
</tr>
<tr>
<td>current_no_freeprice</td>
<td>当月非免费平均单价（平均、方差）</td>
</tr>
<tr>
<td>current_discount</td>
<td>当月每次平均折扣（平均、方差）</td>
</tr>
<tr>
<td>current_discount_ratio</td>
<td>每次折扣力度（平均、方差）</td>
</tr>
</tbody>
</table>
<h4><span id="order_loan-订单-贷款交叉信息">order_loan 订单-贷款交叉信息</span><a href="#order_loan-订单-贷款交叉信息" class="header-anchor"> </a></h4>
<table>
<thead>
<tr>
<th>特征名</th>
<th>特征含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>loan_order_ratio</td>
<td>贷款总额 / 购买总额</td>
</tr>
<tr>
<td>diff_order_loan</td>
<td>购买总额 - 贷款总额</td>
</tr>
</tbody>
</table>
<h4><span id="user_order-用户-订单交叉信息">user_order 用户-订单交叉信息</span><a href="#user_order-用户-订单交叉信息" class="header-anchor"> </a></h4>
<table>
<thead>
<tr>
<th>特征名</th>
<th>特征含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>diff_loan</td>
<td>贷款总额和初始的差</td>
</tr>
</tbody>
</table>
<h3><span id="模型分析">模型分析</span><a href="#模型分析" class="header-anchor"> </a></h3>
<p>一看题目，咋们就很明显的看出这是一个回归问题，那么我们就先选用回归的各种模型来尝试，比如 GBDT、XGB、LR、 Ridge。<br>
随后，我们通过分析数据发现，有相当大的一部分用户没有发生贷款行为，那么是否可以尝试采用先分类再回归呢？分为用户是否会贷款，如果否，直接将贷款值设为0；如果是，那么再用回归模型对用户的贷款行为预测。但是实际情况是，我们的分类模型得到的CV结果准确率仅为85%，加上分类再回归，反而导致了总体评分下降。在做了简单的尝试之后，我们便放弃了这个方法，还是直接使用回归模型。</p>
<h3><span id="模型调参">模型调参</span><a href="#模型调参" class="header-anchor"> </a></h3>
<p>在这里，我们安利一个非常棒的 <strong>自动</strong> 特征处理（归一化、放缩）、模型选择、调参、模型融合的工具 <a href="https://rhiever.github.io/tpot/" target="_blank" rel="noopener">TPOT</a>，它是用遗传算法跑的，所以运行速度非常非常慢。在本次比赛中，我们一百多维的特征，9W多行（用户），TPOT参数设置：迭代25次，种群规模40，跑完一次，得到模型结果需要1-2天的时间。<br>
此外，我们主要尝试了XGB和GBDT模型，最终的结果是GBDT要优于XGB，参数如下：
GBDT：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train, X_test, y_train, y_test = train_test_split(train_X, train_Y, test_size=<span class="number">0.2</span>, random_state=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">clf = GradientBoostingRegressor(loss=<span class="string">'ls'</span>, alpha=<span class="number">0.9</span>,</span><br><span class="line">                                n_estimators=<span class="number">500</span>,</span><br><span class="line">                                learning_rate=<span class="number">0.05</span>,</span><br><span class="line">                                max_depth=<span class="number">8</span>,</span><br><span class="line">                                subsample=<span class="number">0.8</span>,</span><br><span class="line">                                max_features=<span class="number">0.6</span>,</span><br><span class="line">                                min_samples_split=<span class="number">9</span>,</span><br><span class="line">                                max_leaf_nodes=<span class="number">10</span>)</span><br><span class="line">clf = clf.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<p>XGB：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'max_depth'</span>: <span class="number">5</span>, <span class="string">'eta'</span>: <span class="number">0.05</span>, <span class="string">'silent'</span>: <span class="number">1</span>, <span class="string">'eval_metric'</span>: <span class="string">'rmse'</span>, <span class="string">'max_leaf_nodes'</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="模型融合">模型融合</span><a href="#模型融合" class="header-anchor"> </a></h4>
<p>在这次比赛中，我们采用了Stacking融合方法，理解不深，只是简单尝试了一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gbdt = GradientBoostingRegressor(loss=<span class="string">'ls'</span>, alpha=<span class="number">0.9</span>,</span><br><span class="line">                                         n_estimators=<span class="number">500</span>,</span><br><span class="line">                                         learning_rate=<span class="number">0.05</span>,</span><br><span class="line">                                         max_depth=<span class="number">8</span>,</span><br><span class="line">                                         subsample=<span class="number">0.8</span>,</span><br><span class="line">                                         min_samples_split=<span class="number">9</span>,</span><br><span class="line">                                         max_leaf_nodes=<span class="number">10</span>)</span><br><span class="line">xgb = XGBRegressor(max_depth=<span class="number">5</span>, n_estimators=<span class="number">500</span>, learning_rate=<span class="number">0.05</span>, silent=<span class="literal">False</span>)</span><br><span class="line">lr = LinearRegression()</span><br><span class="line">rfg = RandomForestRegressor(bootstrap=<span class="literal">False</span>, max_features=<span class="number">0.05</span>, min_samples_leaf=<span class="number">11</span>, min_samples_split=<span class="number">8</span>,n_estimators=<span class="number">100</span>)</span><br><span class="line">svr_rbf = SVR(kernel=<span class="string">'rbf'</span>)</span><br><span class="line"></span><br><span class="line">stregr = StackingRegressor(regressors=[gbdt, xgb, lr, rfg], meta_regressor=svr_rbf)</span><br><span class="line"></span><br><span class="line">stregr.fit(X_train, y_train)</span><br><span class="line">stregr.predict(X_train)</span><br></pre></td></tr></table></figure>
<p>但是效果不咋滴。<br>
由于我们用了TPOT这个调参工具，根据它生成的模型，貌似已经加上模型融合，所以我们在这一块没有放上太多的时间。<br>
还有其他几个模型融合方法，比如：blending，加权平均。据师兄介绍，加权平均的融合方法有时候能取得一个非常不错的结果。根据阿里天池O2O比赛第一名的分享，他们就采用了加权的方法<a href="https://github.com/wepe/O2O-Coupon-Usage-Forecast" target="_blank" rel="noopener">O2O-Coupon-Usage-Forecast</a>。</p>
<h3><span id="总结">总结</span><a href="#总结" class="header-anchor"> </a></h3>
<p>初次比赛，还不懂套路，拿到赛题和数据后，我们没有做数据分析，直接巴拉巴拉暴力提取特征，导致很多特征都没有什么实际用处。另外在数据清洗上也没有进行操作，直接选取了全部数据；在一些缺失值，异常值（比如购买金额，贷款金额为负值）操作上，直接进行填零。不知道是否因为这些原因导致结果比较差。另外，在比赛初期，我们新增特征时，对结果有较大提高，特别是一些强特征（GBDT特征重要性排序），但在比赛后期，新增特征后，对结果几乎没有提高，有时甚至下降了。在本次比赛中，没有找到什么骚操作，也没有发掘出某个神奇的东西，对结果有大幅提高。但是，TPOT是个不错的东西，在特征确定的情况下，通过该工具，对模型调整有着突出的效果，缺点是运行速度太慢。过段时间，看看各位大佬的分享，再好好总结总结。</p>
<h3><span id="参考资料">参考资料</span><a href="#参考资料" class="header-anchor"> </a></h3>
<p><a href="https://dnc1994.com/2016/04/rank-10-percent-in-first-kaggle-competition/" target="_blank" rel="noopener">如何在 Kaggle 首战中进入前 10%</a><br>
<a href="http://scarletpan.github.io/summary-of-get-a-silver-medal-in-kaggle/" target="_blank" rel="noopener">第一次参加Kaggle拿银总结</a><br>
<a href="http://blog.csdn.net/bryan__/article/details/53907292" target="_blank" rel="noopener">[天池竞赛系列]O2O优惠券使用预测复赛第三名思路</a><br>
<a href="https://github.com/wepe/O2O-Coupon-Usage-Forecast" target="_blank" rel="noopener">O2O第一名【诗人都藏在水底】代码 思路</a><br>
<a href="https://github.com/InsaneLife/O2O-Predict-Coupon-Usage" target="_blank" rel="noopener">O2O第十六名代码 思路</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>数据挖掘</tag>
        <tag>竞赛</tag>
        <tag>京东</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx服务器常见配置</title>
    <url>/2017/11/05/nginxConfig/</url>
    <content><![CDATA[<p>nginx是一个优秀的静态服务器，本博客就搭建在nginx服务器中。本博客由Hexo生成静态文件，上传至nginx里的网站目录中(www)即可，用起来非常方便。现将搭博客中用到的配置总结一下，包括： 排除指定目录； 添加服务器ssl证书； 301重定向</p>
<a id="more"></a>
<h2><span id="预备">预备</span><a href="#预备" class="header-anchor"> </a></h2>
<p>这里介绍查找nginx配置文件路径的方法</p>
<h3><span id="查找nginx服务器配置文件路径">查找nginx服务器配置文件路径</span><a href="#查找nginx服务器配置文件路径" class="header-anchor"> </a></h3>
<p>不同安装方式，不同服务器的nginx的配置文件路径会不一样，那么使用<code>whereis</code>命令可以很快定位nginx的安装位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ whereis nginx</span><br><span class="line">nginx: /usr/sbin/nginx /etc/nginx /usr/share/nginx</span><br></pre></td></tr></table></figure>
<p>很明显<code>/etc/nginx</code>就是我们要找的nginx配置路径</p>
<h2><span id="排除指定目录">排除指定目录</span><a href="#排除指定目录" class="header-anchor"> </a></h2>
<p>hexo博客在部署时直接采用git上传至服务器中，但是目录中包含了git的配置目录<code>.git</code>，如果不进行排除，在浏览器地址栏中输入文件名，是可以直接访问的，可能会造成一些安全问题，因此，我们要把此目录排除，不能通过浏览器直接访问。</p>
<p>找到配置文件中<code>server</code>的位置，在<code>server</code>里添加如下语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  location ~ /\. &#123;</span><br><span class="line">      deny all;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="nginx301重定向">nginx301重定向</span><a href="#nginx301重定向" class="header-anchor"> </a></h2>
<p>如果一个网站有多个域名（包括二级域名），通过301重定向可以使搜索引擎的权重集中到同一个域名上。</p>
<h3><span id="修改配置文件">修改配置文件</span><a href="#修改配置文件" class="header-anchor"> </a></h3>
<p>找到配置文件中<code>server</code>的位置，添加如下语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    if ($host != &apos;tianle.me&apos;)&#123;</span><br><span class="line">           rewrite ^/(.*)$ http://tianle.me/$1 permanent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="添加ssl证书支持https访问">添加SSL证书（支持https访问）</span><a href="#添加ssl证书支持https访问" class="header-anchor"> </a></h2>
<p><s>为了装逼</s>，为了安全</p>
<h3><span id="申请ssl证书">申请SSL证书</span><a href="#申请ssl证书" class="header-anchor"> </a></h3>
<p>目前很多网站都可以申请SSL免费证书<s>穷</s>，安照步骤来就好了，申请成功后下载证书。</p>
<h3><span id="在nginx中安装证书">在nginx中安装证书</span><a href="#在nginx中安装证书" class="header-anchor"> </a></h3>
<p>下载完证书，打开后我们会发现有很多服务器，我们选择nginx。<br>
<img src="//img.tianle.me/image/20171105/1.jpg" alt="证书截图"><br>
把里面的两证书文件<code>crt</code>,<code>key</code>上传到服务器的任意路径，如：<code>~/ssl/</code></p>
<h3><span id="修改配置文件">修改配置文件</span><a href="#修改配置文件" class="header-anchor"> </a></h3>
<p>同样，在server里面加入如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">        # SSL configuration</span><br><span class="line">        #</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        listen [::]:443 ssl;</span><br><span class="line"></span><br><span class="line">        #rewrite ^(.*) https://$host$1 permanent;</span><br><span class="line"></span><br><span class="line">        #ssl on;</span><br><span class="line">        ssl_certificate ~/ssl/1_tianle.me_bundle.crt;</span><br><span class="line">        ssl_certificate_key ~/ssl/2_tianle.me.key;</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="重启nginx服务">重启nginx服务</span><a href="#重启nginx服务" class="header-anchor"> </a></h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></figure>
<p><strong>Done!</strong></p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>301</tag>
        <tag>重定向</tag>
        <tag>https</tag>
        <tag>ssl</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Johnson-Trotter算法生成排列数</title>
    <url>/2017/10/30/permutations/</url>
    <content><![CDATA[<p>排列，一般地，从<code>n</code>个不同元素中取出<code>m（m≤n）</code>个元素，按照一定的顺序排成一列，叫做从<code>n</code>个元素中取出<code>m</code>个元素的一个排列(permutation)。特别地，当<code>m=n</code>时，这个排列被称作全排列(all permutation)。<br>
Johnson-Trotter是一种基于最小变换的全排列生成算法。</p>
<a id="more"></a>
<h2><span id="题目描述">题目描述</span><a href="#题目描述" class="header-anchor"> </a></h2>
<p><a href="https://leetcode.com/problems/permutations/description/" target="_blank" rel="noopener">46. permutations</a></p>
<blockquote>
<p>Given a collection of distinct numbers, return all possible permutations.<br>
For example, [1,2,3] have the following permutations:<br>
[<br>
[1,2,3],<br>
[1,3,2],<br>
[2,1,3],<br>
[2,3,1],<br>
[3,1,2],<br>
[3,2,1]<br>
]</p>
</blockquote>
<h2><span id="johnson-trotter算法">Johnson-Trotter算法</span><a href="#johnson-trotter算法" class="header-anchor"> </a></h2>
<p>我们给每一个排列中的每个元素<code>k</code>赋予一个方向。我们在所讨论的每个元素上画一个箭头来指出它的方向，例如：</p>
 $$ \vec 3\overset{\lower0.5em\hbox{$\smash{\scriptscriptstyle\leftarrow}$}}{2} \vec 4\overset{\lower0.5em\hbox{$\smash{\scriptscriptstyle\leftarrow}$}}{1} $$ 
<h3><span id="移动元素">移动元素</span><a href="#移动元素" class="header-anchor"> </a></h3>
<p>如果元素<code>k</code>的箭头指向一个相邻的较小的元素，我们说它在这个以箭头标记的排列中是<strong>移动（mobile）<strong>的。例如对于排列 $ \vec 3\overset{\lower0.5em\hbox{$\smash{\scriptscriptstyle\leftarrow}$}}{2} \vec 4\overset{\lower0.5em\hbox{$\smash{\scriptscriptstyle\leftarrow}$}}{1} $ 来说，3和4是移动的，而2和1不是。通过使用移动元素这个概念，我们可以给出所谓的</strong>Johnson-Trotter算法</strong>的描述，它也是用来生成排列的。</p>
<h3><span id="算法">算法</span><a href="#算法" class="header-anchor"> </a></h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//实现用来生成排列的Johnson-Trotter算法  </span><br><span class="line">//输入：一个正整数n</span><br><span class="line">//输出：&#123;1, ... , n&#125;的所有排列的列表</span><br><span class="line"></span><br><span class="line">将第一个排列初始化为 1 2 .. n （箭头全向左）</span><br><span class="line"></span><br><span class="line">while 存在一个移动元素 do</span><br><span class="line">  求最大的移动元素k</span><br><span class="line">  把k和它箭头指向的相邻元素互换（包括元素值和元素的方向）</span><br><span class="line">  调转所有大于k的元素的方向</span><br><span class="line">  将新排列添加到列表中</span><br></pre></td></tr></table></figure>
<p>在这里我们对<code>n=3</code>应用该算法，其中最大的移动整数用粗体字表示：<br>
$\overleftarrow 1 \overleftarrow 2 \overleftarrow {\mathbf{3}} $， $\overleftarrow 1 \overleftarrow {\mathbf{3}} \overleftarrow 2 $，  $\overleftarrow {\mathbf{3}} \overleftarrow 1 \overleftarrow 2 $，  $\overrightarrow {\mathbf{3}} \overleftarrow 2 \overleftarrow 1 $，  $\overleftarrow 2 \overrightarrow {\mathbf{3}} \overleftarrow 1 $，  $\overleftarrow {\mathbf{2}} \overleftarrow 1 \overrightarrow 3 $</p>
<p>在这里特别要注意的是，算法第二步，交换元素的时，不仅要把元素值换了，还要把这个元素的方向也一起换了（看出一个整体）。</p>
<h2><span id="java实现">Java实现</span><a href="#java实现" class="header-anchor"> </a></h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Kyle on 2017/10/29.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Permutations</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] directions = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        Arrays.fill(directions, Boolean.TRUE);</span><br><span class="line">        <span class="keyword">boolean</span>[] mobiles;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            list1.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        lists.add(list1);</span><br><span class="line"></span><br><span class="line">        lableA:</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            mobiles = containMobile(directions, nums);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mobiles[i]) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] &gt; max) &#123;</span><br><span class="line">                        max = nums[i];</span><br><span class="line">                        maxIndex = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span> lableA;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// false right, true left</span></span><br><span class="line">            <span class="keyword">if</span> (directions[maxIndex] == <span class="keyword">false</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[maxIndex + <span class="number">1</span>];</span><br><span class="line">                nums[maxIndex + <span class="number">1</span>] = nums[maxIndex];</span><br><span class="line">                nums[maxIndex] = temp;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> d = directions[maxIndex + <span class="number">1</span>];</span><br><span class="line">                directions[maxIndex + <span class="number">1</span>] = directions[maxIndex];</span><br><span class="line">                directions[maxIndex] = d;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[maxIndex - <span class="number">1</span>];</span><br><span class="line">                nums[maxIndex - <span class="number">1</span>] = nums[maxIndex];</span><br><span class="line">                nums[maxIndex] = temp;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> d = directions[maxIndex - <span class="number">1</span>];</span><br><span class="line">                directions[maxIndex - <span class="number">1</span>] = directions[maxIndex];</span><br><span class="line">                directions[maxIndex] = d;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// change directions when the element &gt; max</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; max) &#123;</span><br><span class="line">                    directions[j] = !directions[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            lists.add(list);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] containMobile(<span class="keyword">boolean</span>[] directions, <span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] mobiles = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            mobiles[i] = mobile(directions[i], nums, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mobiles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">mobile</span><span class="params">(<span class="keyword">boolean</span> direction, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (direction == <span class="keyword">false</span> &amp;&amp; index != nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] &gt; nums[index + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction == <span class="keyword">true</span> &amp;&amp; index != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] &gt; nums[index - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = permute(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Johnson-Trotter</tag>
        <tag>排列</tag>
        <tag>permutation</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL无法本地连接</title>
    <url>/2017/10/15/fuckmysql/</url>
    <content><![CDATA[<p>今天在GPU上安装MySQL，折腾了大半天，服务器用的是arch系统，之前没接触过，遇到了不少问题，我现在从安装开始讲：</p>
<a id="more"></a>
<h2><span id="在arch上安装mysql">在Arch上安装MySQL</span><a href="#在arch上安装mysql" class="header-anchor"> </a></h2>
<blockquote>
<p>MariaDB 现在是 Arch Linux 官方默认的 MySQL 实现。Oracle MySQL 已被移动到 AUR，推荐所有用户升级[broken link: invalid section]到 MariaDB。参见这条公告。<br>
<a href="https://wiki.archlinux.org/index.php/MySQL_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">MySQL (简体中文)</a></p>
</blockquote>
<p>安装步骤比较简单，安装网上的说明文档一步步来就好了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pacman -S mariadb mariadb-clients</span><br></pre></td></tr></table></figure>
<p>安装完软件包之后，再运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql</span><br></pre></td></tr></table></figure>
<p>结束后，启动MySQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start mysqld</span><br></pre></td></tr></table></figure>
<p>设置密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqladmin -u root password &apos;12345678&apos;</span><br></pre></td></tr></table></figure>
<p>搞定！</p>
<h2><span id="设置远程登录">设置远程登录</span><a href="#设置远程登录" class="header-anchor"> </a></h2>
<p>这TM的坑就来了，不知道怎么的就把原来数据库的值给改了，下面我一步一步说：<br>
网上的教程大部分都是这样的：</p>
<h3><span id="更改配置文件">更改配置文件</span><a href="#更改配置文件" class="header-anchor"> </a></h3>
<p>不同系统的目录可能不一样，大家应该不难找到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure>
<p>在旧版本中找到 skip-networking，把它注释掉就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#skip-networking</span><br></pre></td></tr></table></figure>
<p>在新版本中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Instead of skip-networking the default is now to listen only on</span><br><span class="line"># localhost which is more compatible and is not less secure.</span><br></pre></td></tr></table></figure>
<p>找到 ：bind-address           = 127.0.0.1 这一行要注释掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#bind-address           = 127.0.0.1</span><br></pre></td></tr></table></figure>
<h3><span id="修改权限">修改权限</span><a href="#修改权限" class="header-anchor"> </a></h3>
<p>格式：grant 权限 on 数据库名.表名 用户@登录主机 identified by “用户密码”;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant select,update,insert,delete on *.* to root@&apos;%&apos; identified by &apos;123456&apos;;</span><br></pre></td></tr></table></figure>
<p>或者所有权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO root@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;</span><br></pre></td></tr></table></figure>
<p>接着执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges; 使授权生效</span><br></pre></td></tr></table></figure>
<h3><span id="修改user表坑">修改user表（坑）</span><a href="#修改user表坑" class="header-anchor"> </a></h3>
<blockquote>
<p>MySQL建用户的时候会指定一个host，默认是127.0.0.1/localhost，那么这个用户就只能本机访问，其它机器用这个用户帐号访问会提示没有权限，host改为%，表示允许所有机器访问。</p>
</blockquote>
<p>然后呢，一些博客里面就让我们把原来的localhost改为&quot;%&quot;</p>
<table>
<thead>
<tr>
<th>Host</th>
<th>User</th>
</tr>
</thead>
<tbody>
<tr>
<td>xxx</td>
<td>root</td>
</tr>
<tr>
<td>127.0.0.1</td>
<td>root</td>
</tr>
<tr>
<td>::1</td>
<td>root</td>
</tr>
<tr>
<td>localhost</td>
<td>root</td>
</tr>
<tr>
<td>%</td>
<td>root</td>
</tr>
</tbody>
</table>
<p>恩，没错就是这里。这里的<code>127.0.0.1</code>和<code>localhost</code>是不一样的，我们平常默认登录是用<code>mysql -uroot -p</code>，这样的话（前提是没有修改过配置文件中的对应设置），我们本机地址是<code>localhost</code>,如果不小心把这个改没了。。。。那你就登不上喽：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: &apos;Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: YES)&apos;</span><br></pre></td></tr></table></figure>
<p>恩，没错，就是这样的提示，刚开始我还以为密码错了。。。。结果重置了好几遍密码都不行，知道后来才知道，原来是登录地址的权限不对/(ㄒoㄒ)/~~<br>
你想登录的话要这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h 127.0.0.1 -uroot -p</span><br></pre></td></tr></table></figure>
<p>哈哈哈，登录进去了吧，这就说明<code>127.0.0.1</code>和<code>localhost</code>是不一样的。<br>
那么解决办法呢，就是再新增一条<code>127.0.0.1</code>的记录，我们可以直接拷贝原有记录，其余不变，把<code>host</code>中的记录改为<code>127.0.0.1</code>即可。</p>
]]></content>
      <categories>
        <category>应用开发</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>深层网络结构嵌入</title>
    <url>/2017/06/30/SDNE/</url>
    <content><![CDATA[<h1><span id="structural-deep-network-embedding">Structural Deep Network Embedding</span><a href="#structural-deep-network-embedding" class="header-anchor"> </a></h1>
<p>论文阅读<a href="http://dl.acm.org/citation.cfm?id=2939753" target="_blank" rel="noopener">Structural Deep Network Embedding</a><br>
本文的PDF版<a href="//img.tianle.me/image/20170630/web.pdf">深层网络结构嵌入</a><br>
这学期选了非线性电路与系统，最近又在做网络表示的相关研究，特将平时看过比较好的论文写一写，和大家分享一下。</p>
<h2><span id="简介">简介</span><a href="#简介" class="header-anchor"> </a></h2>
<p>信息网络在现实世界中普遍存在，例如航空公司网络，出版物网络，通信网络和万维网。这些信息网络的规模从几百个节点到数百万和数十亿个节点不等。大规模信息网络的分析在学术界和工业界引起越来越多的关注。本文研究的是将信息网络嵌入到低维空间的问题，其中每个顶点都表示为一个低维向量。这种低维嵌入在各种应用中非常有用，如可视化，节点分类，链路预测和选择推荐。</p>
<a id="more"></a>
<p>网络嵌入目前依旧面临许多挑战。（1）<strong>高维且非线性</strong>，深层的网络结构特征通常是非线性且高维的。因此，如何去描述学习这种高维非线性的特征是非常具有挑战性的。（2）<strong>结构保持</strong>，为了能够将结果应用到一些具体的网络分析任务中，网络嵌入方法需要能够将网络结构较好的保存下来，但是隐藏的网络结构是非常复杂并且难以发现的。节点的特性往往依赖于其局部和全局的网络结构。（3）<strong>稀疏性</strong>，真实世界中的大部分网络都是稀疏的，只能够利用极少数已发现的关系连接，因此还远远不能依此得到满意的效果。<br>
近些年来，许多网络嵌入的方法相继被提出，它们采用了一些浅显的模型，比如说：IsoMAP，Laplacian Eigenmap(LE)，Line。由于这些模型的局限性，它们很难获得网络高维的非线性特征。为了解决这个难题，本文提出了深层模型来学习网络中的节点表示。我们受深度学习的启发，因为其展现出了强大的表示学习能力，能够从复杂的网络中学习特征。它已经在图像、文本、语音等方面取得了卓越的成绩。特别的，我们提出的模型设计了多层的网络结构，这些结构是由许多非线性函数构成，能够将网络数据映射到隐藏的非线性空间中，从而挖掘出网络的非线性结构。<br>
为了处理网络结构保存以及稀疏性问题，我们把一阶相似度和二阶相似度相结合，并融于学习过程中。一阶相似度是两个顶点之间的局部点对的邻近度，但由于网络的稀疏性，许多真实存在的边可能缺失，因此，一阶相似度不足以表示网络结构。因此我们更进一步地提出了二阶相似度，一对顶点之间的接近程度表示在网络中其邻域网络结构之间的相似性。通过一阶相似度和二阶相似度，我们可以很好的捕获网络的局部特性与全局特性。为了保证网络的局部和全局特性在我们的模型中有较好的表示，我们提出了一种半监督的结构，其中，无监督部分重构了二阶相似度，以保持全局网络结构。而有监督的部分利用一阶相似度作为监督信息来保存网络的全局结构。因此，所学的表示能够很好的保存网络的局部和全局结构。此外，从图1可以看出，在许多网络中二阶相似度邻近点对的数目比一阶相似度多很多。由此可以得到，二阶相似度的引入能够在描述网络结构方面提供更多的信息。因此，我们的方法对稀疏网络是鲁棒的。<br>
<img src="//img.tianle.me/image/20170630/1.png" alt="图一"><br>
图1</p>
<h3><span id="主要贡献">主要贡献</span><a href="#主要贡献" class="header-anchor"> </a></h3>
<ol>
<li>我们提出了一种深层网络结构嵌入的方法，称为SDNE。这种方法能够将网络数据映射到深层的非线性低维空间，并且具有较好的鲁棒性。同时具我们所知，该方法是第一次将深度学习运用于网络表示中。</li>
<li>我们提出了一个新的半监督深层模型，整合了网络中的一阶和二阶相似性。因此，通过该模型得到的低维网络表示，能够很好的表现网络的局部和整体特征。</li>
<li>我们提出的算法在5个真实的数据集中，分别对2种应用问题（多标签分类、可视化）进行了实验验证。结果显示，对于网络标签稀少的数据，我们比其它基准方法提升了至少20%的效果。在某些情况下，我们只需要60%甚至更少的训练数据，也能得到很好的成绩。</li>
</ol>
<h3><span id="其他相关工作">其他相关工作</span><a href="#其他相关工作" class="header-anchor"> </a></h3>
<h4><span id="isomap">IsoMAP</span><a href="#isomap" class="header-anchor"> </a></h4>
<p>算法主要步骤：</p>
<ol>
<li>通过k-Nearest neighbor算法得到每个点的一个近邻。（参数k）</li>
<li>通过最短路算法构造一个N*N的距离矩阵。</li>
<li>通过Multi-dimensional Scaling算法根据距离矩阵进行非线性降维。（参数e）<br>
算法结束以后，我们得到的就是一些e维空间的点。</li>
</ol>
<h4><span id="deepwalk">DeepWalk</span><a href="#deepwalk" class="header-anchor"> </a></h4>
<p>算法主要步骤：<br>
在图上随机游走产生长度为$2w + 1$的路径，对每个点随机$\gamma $个随机游走序列。每一条随机游走路径便是相当于一个序列（相当于一句话），这样序列中的点就有上下文，定义一个时间窗口$w$，并进行马尔可夫假设，最后使用word2vec中的Skip-Gram训练每一个节点的向量。<br>
Gram训练每一个节点的向量。<br>
假设一个路径序列为$S = \left\{ {{v_1},...,{v_{|S|}}} \right\} $,对于${v_i} \in S$，其上下文为$C = \left\{ {{v_{i - w}},{v_{i - w + 1}},...,{v_{i + w - 1}},{v_{i + w}}} \right\}$, 那么DeepWalk的优化目标为:</p>
 $$f = \frac{1}{{\left| S \right|}}\sum\limits_{i = 1}^{\left| S \right|} {\sum\limits_{ - w \le j \le w,j \ne 0} {\log p({v_{i + j}}|{v_i})} } $$
<p>其中：</p>
$$p\left( {{v_j}|{v_i}} \right) = \frac{{exp\left( {c_{{v_j}}^T{r_{{v_i}}}} \right)}}{{\sum\nolimits_{v \in C} {exp\left( {c_{{v_j}}^T{r_{{v_i}}}} \right)} }}$$
${r_{{v_i}}}$是点${v_i}$的向量表征, ${c_{{v_i}}}$是点${v_i}$上下文中点${v_j}$的向量表征。  
<p>DeepWalk使目标$f$最大化，使用Skip-Gram与Hierarchical Softmax进行训练得到每个点的vector，DeepWalk等价于MF(matrix factorization,矩阵分解)。</p>
<h2><span id="深层网络结构嵌入">深层网络结构嵌入</span><a href="#深层网络结构嵌入" class="header-anchor"> </a></h2>
<h3><span id="深层网络结构嵌入">深层网络结构嵌入</span><a href="#深层网络结构嵌入" class="header-anchor"> </a></h3>
<p><strong>定义1（网络）</strong>：给定一个网络$G = \left( {V,E} \right)$，其中$V = \{ {v_1}, \cdots ,{v_n}\} $表示为n个节点，$E = \{ {e_{i,j}}\} _{i,j = 1}^n$表示网络中所有边的集合。每一条边${e_{i,j}}$与其网络中边的权重${s_{i,j}} \ge 0$相关联。如果${v_i}$和${v_j}$之间没有连接，那么${s_{i,j}} = 0$，否则，对于无权图${s_{i,j}} = 1$，有权图${s_{i,j}} > 0$<br>
网络嵌入的目的是将原始的高维网络数据映射到低维的表示空间中，网络中的每一个节点即可表示为一个低维向量，同时网络计算将会变得非常方便。正如我们之前提到的，网络的局部结构和全局结构都非常有必要在降维后保存下来，下面将详细定义一阶相似度和二阶相似度。<br>
<strong>定义2（一阶相似度）</strong>：网络中的一阶相似度是两个顶点之间的局部点对的邻近度。对于由边（u，v）链接的每对顶点，该边的权重${s_{u,v}}$表示u和v之间的一阶相似性，如果在u和v之间没有边，它们的一阶相似度为0。<br>
一阶相似度通常意味着现实世界网络中两个节点的相似性。例如，在社交网络中成为朋友的人往往具有类似的兴趣；在万维网上互相链接的页面往往谈论类似的主题。由于一阶相似度的重要性，许多现有的图嵌入算法，如IsoMap，LLE，Laplacian Eigenmaps目的都是保持一阶相似度。<br>
然而，在现实世界的信息网络中，能够观察到的链接只是小部分，许多隐藏的其他关系都没有被观察到。缺失链路上的一对节点，即使它们在本质上非常相似，然而他们的一阶相似度为0。 因此，只有一阶相似度对维持网络结构来说不是很有效。我们自然而然的想到，具有类似邻居的顶点往往是相似的。 例如，在社交网络中，分享相同内容的人往往具有相似的兴趣，从而成为朋友，在文本网络中，总是与同一组词汇共同出现的词往往具有相似的含义。 因此，我们定义二阶相似度，其补充了一阶相似性并能够保留网络结构。<br>
<strong>定义3（二阶相似度）</strong>：二阶相似度对应于网络中的点对（u，v）是其邻域网络结构之间的相似性。数学上，让${{\rm{\mathcal{N}}}_u} = \{ {s_{u,1}}, \cdots ,{s_{u,\left| V \right|}}\} $表示一阶附近 u 与所有其他的顶点，那么 u 和v之间的二阶相似性由${{\rm{\mathcal{N}}}_u}$和${{\rm{\mathcal{N}}}_v}$之间的相似性来决定。如果没有一个顶点同时和 u 与 v 链接，那么 u 和 v的二阶相似性是0。<br>
<strong>定义4（网络嵌入）</strong>：给定网络$G = \left( {V,E} \right)$，网络嵌入的问题是将每个顶点$v \in V$表示为低维空间${\mathbb{R}^d}$中的向量，学习函数$f:\left| V \right| \mapsto {\mathbb{R}^d}$，其中$d \ll \left| V \right|$。在空间${\mathbb{R}^d}$中，顶点之间的一阶相似度和二阶相似度都被保留。</p>
<h3><span id="snde模型">SNDE模型</span><a href="#snde模型" class="header-anchor"> </a></h3>
<h4><span id="算法框架">算法框架</span><a href="#算法框架" class="header-anchor"> </a></h4>
<p>在本篇文章中，我们提出了一个半监督的网络嵌入深度框架，整体框架如图2所示。具体来说，为了捕捉高维非线性的网络结构，我们提出了一个深层的体系结构，它由多个非线性映射函数组成，将输入数据映射到一个高维非线性的隐藏空间，以捕获网络结构。为了解决网络结构保持和稀疏性问题，我们提出了一个半监督模型来利用一阶和二阶相似度。对于每个顶点，我们都可以得到它的邻域。因此，我们设计了无监督的组件来保持二阶相似度，并重建每个顶点的邻域结构。同时，对节点的一部分，我们可以获得他们的一阶相似度。因此，我们设计了有监督的组件，利用一阶相似度作为监督信息来改进隐藏空间中的表示。通过联合优化所提出的半监督深度模型，SDNE可以保持高维的非线性网络结构，保证稀疏网络的健壮性。在接下来的部分中，我们将详细介绍如何实现半监督的深度模型。<br>
<img src="//img.tianle.me/image/20170630/2.png" alt="图2"><br>
图2.网络整体结构</p>
<h3><span id="损失函数">损失函数</span><a href="#损失函数" class="header-anchor"> </a></h3>
<p>我们首先描述无监督组件如何利用二阶近似保持全局网络结构。<br>
二阶相似性值指的是节点的邻居相似，因此模型的二阶相似性，需要每个节点邻居的性质。给定一个网络$G = \left( {V,E} \right)$，我们可以获得到它的邻接矩阵S，它包含了n个元素${s_1}, \cdots {s_n}$，对于每一个元素${s_i} = \{ {s_{i,j}}\} _{j = 1}^n$，如果${v_i}$与${v_j}$间有相连的边，那么${s_{i,j}} > 0$。因此，${s_i}$描述了节点${v_i}$的邻居结构，$S$提供了每一个节点的邻居结构信息。对于$S$来说，我们将传统的深度自编码器的进行延伸，用来保存网络的二阶相似性。<br>
下面简单回顾一下深度自编码器的主要思想。它属于一种非监督模型，包含编码器与解码器。编码器由许多非线性函数构成，将输入数据映射到表示空间。对应的，解码器也由许多非线性函数构成，它将表示空间映射到输入数据的重构空间。给定输入数据${x_i}$，其中对于各个层的隐藏表示如下公式进行计算：</p>
$$y_i^{(1)} = \sigma ({W^{(1)}}{x_i} + {b^{(1)}})$$
$$y_i^{(k)} = \sigma ({W^{(k)}}y_i^{(k - 1)} + {b^{(k)}}),k = 2, \cdots ,K$$
<p>通过一系列编码器的计算，我们可以获得输出${\hat x_i}$。自动编码器的目标是尽量减少输入和输出的重构误差。损失函数可以表示为：</p>
$${\rm{\mathcal{L}}} = \sum\limits_{i = 1}^n {\left\| {{{\hat x}_i} - {x_i}} \right\|_2^2} $$
<p>通过最小化损失函数能够较好的还原输入数据的原始表达，其表示空间能够提取出原始输入数据的特征。基于上述特性，我们将网络的邻接矩阵S作为自动编码器的输入，如： ${x_i} = {s_i}$，那么每一个元素${s_i}$表示节点${v_i}$邻居节点的特征。因此，通过重构可以让具有相似邻居结构的节点在隐藏的表示空间也具有相似的表达。
但是，仅仅通过这种方式还不能直接解决问题。因为在网络中，我们可以观察到一些连接，但是也有一些合法的连接是缺失的。此外，由于网络的稀疏性，在邻接矩阵$S$中，零元素远远大于非零元素。如果我们直接将S输入到传统的自编码器中，可能会导致大量的零元素出现在重构空间，这并不是我们想要的结果。为了解决这个问题，我们让其对非零元素的重构误差比零元素的惩罚更大。改进的目标函数如下所示：</p>
$$\begin{array}{l}{{\rm{\mathcal{L}}}_{2nd}} = \sum\limits_{i = 1}^n {\left\| {({{\hat x}_i} - {x_i}) \odot {b_i}} \right\|_2^2} \\{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \left\| {(\hat X - X) \odot B} \right\|_F^2\end{array}$$  
<p>其中$ \odot $表示Hadamard积，${b_i} = \{ {b_{i,j}}\} _{j = 1}^n$，如果${s_{i,j}} = 0$，那么${b_{i,j}} = 1$，否则${b_{i,j}} = \beta  &gt; 1$。通过这种改进的损失函数，可以更好的让具有相似邻居的点在获得的表示空间也相似。换句话说，这个非监督部分能够很好的保存网络的二阶相似度。<br>
不仅要维持全局网络结构，而且要捕获局部结构。我们使用一阶相似度表示网络局部结构。一阶相似度可以作为监督信息来约束一对顶点在隐藏表示空间的相似性。因此，我们设计了监督部分来利用一阶相似度。损失函数如下所示：</p>
$$\begin{array}{l}{{\rm{\mathcal{L}}}_{1nd}} = \sum\limits_{i = 1}^n {{s_{i,j}}\left\| {y_i^{(K)} - y_j^{(K)}} \right\|_2^2} \\{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \sum\limits_{i = 1}^n {{s_{i,j}}\left\| {{y_i} - {y_j}} \right\|_2^2} \end{array}$$
<p>其中${Y^{(k)}} = \{ y_i^{(k)}\} _{i = 1}^n$为编码器获得的隐藏表示空间。<br>
该公式的灵感来源于拉普拉斯特征映射(Laplacian Eigenmaps)，在表示空间中，如果相似的节点相距较远，那么会受到一个较大的惩罚。通过这一操作，我们的模型能够很好的保持网络的一阶相似度。<br>
我们同时考虑网络的一阶相似度和二阶相似度，另外在加上L2正则项，共同构成了自动编码器的损失函数：</p>
$$\begin{array}{l}{{\rm{\mathcal{L}}}_{mix}} = {{\rm{\mathcal{L}}}_{2nd}} + \alpha {{\rm{\mathcal{L}}}_{1nd}} + \upsilon {{\rm{\mathcal{L}}}_{reg}}\\{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \left\| {(\hat X - X) \odot B} \right\|_F^2 + \alpha \sum\limits_{i = 1}^n {{s_{i,j}}\left\| {{y_i} - {y_j}} \right\|_2^2}  + \upsilon {{\rm{\mathcal{L}}}_{reg}}\end{array}$$  
<p>其中：</p>
$$\begin{array}{l}{{\rm{\mathcal{L}}}_{mix}} = {{\rm{\mathcal{L}}}_{2nd}} + \alpha {{\rm{\mathcal{L}}}_{1nd}} + \upsilon {{\rm{\mathcal{L}}}_{reg}}\\{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt}  = \left\| {(\hat X - X) \odot B} \right\|_F^2 + \alpha \sum\limits_{i = 1}^n {{s_{i,j}}\left\| {{y_i} - {y_j}} \right\|_2^2}  + \upsilon {{\rm{\mathcal{L}}}_{reg}}\end{array}$$
<h2><span id="实验">实验</span><a href="#实验" class="header-anchor"> </a></h2>
<h3><span id="数据集">数据集</span><a href="#数据集" class="header-anchor"> </a></h3>
<p>为了能够全面地评价算法得到的低维表示，我们使用了5个真实的网络数据，包括3个社交网络，1个引文网络，1个语言网络；实验了2类网络应用任务，包括多标签分类和可视化。考虑到各个网络数据的本身属性，对于每一类应用，我们使用了至少一个数据集进行试验。数据集的参数如下表所示：</p>
<table>
<thead>
<tr>
<th>数据集</th>
<th>#(V)</th>
<th>#(E)</th>
</tr>
</thead>
<tbody>
<tr>
<td>BLOGCATALOG</td>
<td>10312</td>
<td>667966</td>
</tr>
<tr>
<td>FLICKR</td>
<td>80513</td>
<td>11799764</td>
</tr>
<tr>
<td>YOUTUBE</td>
<td>1138499</td>
<td>5980886</td>
</tr>
<tr>
<td>ARXIV GR-QC</td>
<td>5242</td>
<td>28980</td>
</tr>
<tr>
<td>20-NEWSGROUP</td>
<td>1720</td>
<td>Full-connected</td>
</tr>
</tbody>
</table>
<p>表1. 网络数据集参数</p>
<h3><span id="对比算法">对比算法</span><a href="#对比算法" class="header-anchor"> </a></h3>
<p>我们实验与以下几个基准算法进行比较：DeepWalk、LINE、GraRep、Laplacian Eigenmaps、Common Neighbor。</p>
<h3><span id="评价指标">评价指标</span><a href="#评价指标" class="header-anchor"> </a></h3>
<p>对于多标签分类问题，我们采用micro-F1和macro-F1指标进行评价。对于标签A，我们将TP（A），FP（A）和FN（A）分别表示为属于A的样本被正确分类到A的数目，不属于A的样本被错误分类到A的数目和不属于A的样本被正确分类到了类别A的其他类的数目。假设 是整个标签集。Micro-F1和Macro-F1定义如下：
Macro-F1是一个每个类的权重的度量。 定义如下：</p>
$$Macro - F1 = \frac{{\sum\nolimits_{A \in {\rm{\mathcal{C}}}} {F1(A)} }}{{\left| {\rm{\mathcal{C}}} \right|}}$$
<p>其中F1(A)是标签A的F1度量。<br>
Micro-F1是对每个实例权重的度量。定义如下：</p>
$$\Pr  = \frac{{\sum\nolimits_{A \in {\rm{\mathcal{C}}}} {TP(A)} }}{{\sum\nolimits_{A \in {\rm{\mathcal{C}}}} {(TP(A) + FP(A))} }}$$
$$R = \frac{{\sum\nolimits_{A \in {\rm{\mathcal{C}}}} {TP(A)} }}{{\sum\nolimits_{A \in {\rm{\mathcal{C}}}} {(TP(A) + FN(A))} }}$$
$$Micro - F1 = \frac{{2*\Pr *R}}{{\Pr  + R}}$$
<h3><span id="参数设置">参数设置</span><a href="#参数设置" class="header-anchor"> </a></h3>
<p>我们在本文中提出了一种多层的神经网络结构，层数随不同的数据集而做相应调整。每层的神经元数目如表2所示。其中BLOGCATALOG，ARXIV GR-QC和20-EWSGROUP使用了三层神经网络，FLICKR和YOUTUBE使用了四层。如果我们使用更深的模型，性能几乎保持不变，甚至变得更糟。</p>
<table>
<thead>
<tr>
<th>数据集</th>
<th>每一层神经元数</th>
</tr>
</thead>
<tbody>
<tr>
<td>BLOGCATALOG</td>
<td>10300-1000-100</td>
</tr>
<tr>
<td>FLICKR</td>
<td>80513-5000-1000-100</td>
</tr>
<tr>
<td>YOUTUBE</td>
<td>22693-5000-1000-100</td>
</tr>
<tr>
<td>ARXIV GR-QC</td>
<td>5242-500-100</td>
</tr>
<tr>
<td>20-NEWSGROUP</td>
<td>1720-200-100</td>
</tr>
</tbody>
</table>
<p>表2. 神经网络结构<br>
对于我们的方法，通过在验证集上使用网格搜索(grid search)来调整 ， 和 三个超参数。对于LINE，随机梯度下降的mini-batch大小设置为1。学习速率的初始值为0.025。负采样数(number of negative samples)为5，总采样数(the total number of samples)设为100亿。对于DeepWalk，我们将窗口大小设置为10，步长为40，每次采样40个顶点。对于GraRep，我们将最大转移矩阵步长(maximum matrix transition step)设置为5。</p>
<h3><span id="实验结果">实验结果</span><a href="#实验结果" class="header-anchor"> </a></h3>
<h4><span id="多标签分类">多标签分类</span><a href="#多标签分类" class="header-anchor"> </a></h4>
<p>我们通过本实验中的多标签分类任务来评估不同网络表示的有效性。顶点的表示是从网络嵌入方法生成的，并被用作将每个顶点分成一组标签的特征。具体来说，我们采用LIBLINEAR软件包来训练分类器。训练分类器时，我们随机抽取标签节点的一部分作为训练数据，其余作为测试。对于BLOGCATALOG，我们随机抽取10％至90％的顶点作为训练样本，并使用剩余顶点来测试性能。对于FLICKR和YOUTUBE，我们随机抽取1％至10％的顶点作为训练样本，并使用剩余顶点来测试性能。另外，我们删除没有在YOUTUBE中被任何类别标记的顶点。我们重复进行5次实验，取Micro-F1和Macro-F1指标的平均值进行度量。结果分别如图3到图5所示。<br>
<img src="//img.tianle.me/image/20170630/3.png" alt="图3"><br>
图3 .Micro-F1和Macro-F1在BLOGCATALOG上的表现<br>
<img src="//img.tianle.me/image/20170630/4.png" alt="图4"><br>
图4 .Micro-F1和Macro-F1在FLICKR上的表现<br>
<img src="//img.tianle.me/image/20170630/5.png" alt="图5"><br>
图5 .Micro-F1和Macro-F1在YOUTUBE上的表现<br>
在图3到图5中，我们算法的曲线一直高于其他基准算法的曲线。它表明，在多标签分类任务中我们算法学习得到的网络表示比其他算法得到的效果更好。<br>
在图3（BLOGCATALOG）中，当训练百分比从60％下降到10％时，我们的方法在基准线上的改善幅度更为明显。它表明当标签数据有限时，我们的方法可以比基准算法有更显着的改进。这样的优势对于现实世界的应用尤其重要，因为标记的数据通常很少。<br>
在大多数情况下，DeepWalk的性能是网络嵌入方法中最差的。原因有两个方面。首先，DeepWalk没有明确的目标函数来捕获网络结构。其次，DeepWalk使用随机游走来获得顶点的邻居，由于随机性而引起了很多噪音，特别是对于度数高的顶点。</p>
<h4><span id="可视化">可视化</span><a href="#可视化" class="header-anchor"> </a></h4>
<p>网络嵌入的另一个重要应用是在二维空间上生成网络的可视化。对此我们在20-NEWSGROUP网络进行可视化的实验。我们使用不同网络嵌入方法学习的低维网络表示作为可视化工具t-SNE的输入。因此，每个新闻组文档被映射为二维向量。然后我们可以将每个向量可视化为二维空间上的一个点。对于被标记为不同类别的文档，我们在对应的点上使用不同的颜色。因此，良好的可视化结果能让相同颜色的点彼此靠近。可视化结果如图6所示。<br>
<img src="//img.tianle.me/image/20170630/6.png" alt="图6"><br>
图6.  20-NEWSGROUP的可视化<br>
每个点表示一个文档。点的颜色表示文档的类别。蓝色表示rec.sport.baseball的主题，红色表示comp.graphics的主题，绿色表示talk.politics.guns的主题。<br>
从图7可以看出，LE和DeepWalk的结果并不理想，属于不同类别的点相互混合。对于LINE，形成不同类别的群集。然而，在中心部分，不同类别的文件仍然相互混合。对于GraRep，结果看起来更好，因为相同颜色的点分割成分组，但是，每个群体的边界不是很清楚。显然，SDNE的可视化效果在群体分离和边界方面都表现最好。</p>
<h2><span id="总结">总结</span><a href="#总结" class="header-anchor"> </a></h2>
<p>在本文中，我们提出了一种深层网络结构嵌入，即SDNE来执行网络嵌入。具体来说，为了捕获高维非线性的网络结构，我们设计了一个具有多层非线性函数的半监督深度模型。为了进一步解决网络结构保持和稀疏问题，我们同时使用了一阶邻近度和二阶邻近度来表示网络的局部和全局特征。通过在半监督的深度模型中优化它们，所学习的表示能够体现出网络的局部和全局特征，并且对稀疏网络是鲁棒的。我们在真实的网络数据集上试验了多标签分类和可视化任务。结果表明，我们的算法与当前最好的算法(state-of-the-art)相比有本质性的提高。</p>
]]></content>
      <categories>
        <category>研究</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>网络表示学习</tag>
        <tag>嵌入</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中遇到的坑</title>
    <url>/2017/06/08/shitinPython/</url>
    <content><![CDATA[<p>只要一写程序，再加上不熟悉，多多少少会遇到一些问题。在这篇文章中，我把在Python中遇到的一些问题，进行一个简单的总结。</p>
<a id="more"></a>
<h2><span id="pip-与-easy_install">pip 与 easy_install</span><a href="#pip-与-easy_install" class="header-anchor"> </a></h2>
<p>首先，这两个都是Python的包管理工具。简单来说pip是easy_install的升级版，可以用pip就用pip吧。<br>
另外，如果python通过源码setup.py文件进行安装，如<code>python setup.py install xxx</code>，那么其安装所依赖包的下载镜像源的配置文件为easy_install的配置，所以即便修改了pip的下载镜像配置文件<code>~/.pip/pip.conf</code>是没有效果的，要修改<code>~/.pydistutils.cfg</code>才能起作用，具体方式在下文说明。
<em>那么能否说明用采用这种方式安装用的是easy_install呢？还请大佬解答</em></p>
<h3><span id="用法">用法</span><a href="#用法" class="header-anchor"> </a></h3>
<h4><span id="easy_install的用法">easy_install的用法：</span><a href="#easy_install的用法" class="header-anchor"> </a></h4>
<ol>
<li>安装一个包</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ easy_install &lt;package_name&gt;</span><br><span class="line">$ easy_install &quot;&lt;package_name&gt;==&lt;version&gt;&quot;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>升级一个包</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ easy_install -U &quot;&lt;package_name&gt;&gt;=&lt;version&gt;&quot;</span><br></pre></td></tr></table></figure>
<h4><span id="pip的用法">pip的用法</span><a href="#pip的用法" class="header-anchor"> </a></h4>
<ol>
<li>安装一个包</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip install &lt;package_name&gt;</span><br><span class="line">$ pip install &lt;package_name&gt;==&lt;version&gt;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>升级一个包 (如果不提供version号，升级到最新版本）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip install --upgrade &lt;package_name&gt;&gt;=&lt;version&gt;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>删除一个包</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip uninstall &lt;package_name&gt;</span><br></pre></td></tr></table></figure>
<p>以上可以看出easy_install没有删除包的方法。</p>
<h3><span id="使用国内源">使用国内源</span><a href="#使用国内源" class="header-anchor"> </a></h3>
<h4><span id="方法1命令方式临时修改">方法1:命令方式临时修改</span><a href="#方法1命令方式临时修改" class="header-anchor"> </a></h4>
<ul>
<li>easy_install:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">easy_install -i https://pypi.tuna.tsinghua.edu.cn/simple fabric</span><br></pre></td></tr></table></figure>
<ul>
<li>pip:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip -i https://pypi.tuna.tsinghua.edu.cn/simple install fabric</span><br></pre></td></tr></table></figure>
<h4><span id="方法2配置方式修改">方法2:配置方式修改</span><a href="#方法2配置方式修改" class="header-anchor"> </a></h4>
<ul>
<li>easy_install:</li>
</ul>
<ol>
<li>打开pydistutils.cfg</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi ~/.pydistutils.cfg</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>写入以下内容</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[easy_install]</span><br><span class="line">index_url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>
<ul>
<li>pip:</li>
</ul>
<ol>
<li>打开pip.conf</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi ~/.pip/pip.conf</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>写入以下内容</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>
<p>速度比较快的国内镜像<br>
豆瓣：<a href="https://pypi.douban.com/simple" target="_blank" rel="noopener">https://pypi.douban.com/simple</a><br>
清华：<a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<h2><span id="python变量作用域">python变量作用域</span><a href="#python变量作用域" class="header-anchor"> </a></h2>
<p>这个是我觉得比较坑的一个地方，在写程序的时候一定要仔细看看某个变量是否在之前用过了，因为python的局部变量作用域不是以缩进（对应其他语言的大括号）进行划分的。<br>
Python变量作用域分为四类</p>
<blockquote>
<p>L （Local） 局部作用域<br>
E （Enclosing） 闭包函数外的函数中<br>
G （Global） 全局作用域<br>
B （Built-in） 内建作用域</p>
</blockquote>
<p>以<code>L --&gt; E --&gt; G --&gt;B</code> 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。<br>
Python除了<code>def/class/lambda</code> 外，其他如: if/elif/else/  try/except  for/while并不能改变其作用域。定义在他们之内的变量，外部还是可以访问。这和其他语言，如：Java，按照括号来分作用域，是有很大区别的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    a = <span class="string">'I am A'</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">'I am A'</span></span><br><span class="line"><span class="comment"># 定义在if语言中的变量a，外部还是可以访问的。</span></span><br><span class="line"><span class="comment"># 但是需要注意如果if被 def/class/lambda 包裹，在内部赋值，就变成了此 函数/类/lambda 的局部作用域。</span></span><br></pre></td></tr></table></figure>
<p>在 def/class/lambda内进行赋值，就变成了其局部的作用域，局部作用域会覆盖全局作用域，但不会影响全局作用域。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = <span class="number">1</span>  <span class="comment">#全局的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    g = <span class="number">2</span> <span class="comment">#局部的</span></span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> fun()</span><br><span class="line"><span class="comment"># 结果为2</span></span><br><span class="line"><span class="keyword">print</span> g</span><br><span class="line"><span class="comment"># 结果为1</span></span><br></pre></td></tr></table></figure>
<p>但是要注意，有时候想在函数内部引用全局的变量，疏忽了就会出现错误，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#file1.py</span></span><br><span class="line">var = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> var</span><br><span class="line">    var = <span class="number">200</span></span><br><span class="line"><span class="keyword">print</span> fun()</span><br><span class="line"></span><br><span class="line"><span class="comment">#file2.py</span></span><br><span class="line">var = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line">    var = var + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> var</span><br><span class="line"><span class="keyword">print</span> fun()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这两个函数都会报错UnboundLocalError: local variable 'var' referenced before assignment</span></span><br></pre></td></tr></table></figure>
<p>在未被赋值之前引用的错误！为什么？因为在函数的内部，解释器探测到var被重新赋值了，所以var成为了局部变量，但是在没有被赋值之前就想使用var，便会出现这个错误。解决的方法是在函数内部添加 <code>globals var</code>但运行函数后全局的var也会被修改。</p>
<h2><span id="浅拷贝与深拷贝">浅拷贝与深拷贝</span><a href="#浅拷贝与深拷贝" class="header-anchor"> </a></h2>
<p>这部分内容可以参考我之前的一篇文章<a href="http://tianle.me/2017/02/28/python-array/">python二维数组重复赋值问题</a></p>
<h2><span id="参考资料">参考资料</span><a href="#参考资料" class="header-anchor"> </a></h2>
<ol>
<li><a href="https://my.oschina.net/lujian863/blog/201220" target="_blank" rel="noopener">easy_install与pip 区别</a></li>
<li><a href="http://www.jianshu.com/p/785bb1f4700d" target="_blank" rel="noopener">pip 更换软件镜像源</a></li>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/" target="_blank" rel="noopener">清华pypi 镜像使用帮助</a></li>
<li><a href="http://www.jianshu.com/p/3bb277c2935c" target="_blank" rel="noopener">Python 变量作用域</a></li>
</ol>
]]></content>
      <categories>
        <category>应用开发</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算智能】目标优化智能算法之遗传算法（Python实现）</title>
    <url>/2017/04/19/GA/</url>
    <content><![CDATA[<p>遗传算法(genetic algorithm, GA)是一种进化算法，其基本原理是仿效生物界中的“物竞天择，适者生存”的演化法则。遗传算法是把问题参数编码为染色体，再利用迭代的方式进行选择、交叉以及变异等运算来交换种群中染色体的信息，最终生成符合优化目标的染色体。</p>
<a id="more"></a>
<h3><span id="名词解释">名词解释</span><a href="#名词解释" class="header-anchor"> </a></h3>
<p>在遗传算法中，染色体对应的是数据或数组，通常是由一维的串结构数据来表示，串上各个位置对应基因的取值。基因组成的串就是染色体(chromosome)，或者称为基因型个体(individual)。一定数量的个体组成了群体(population)。群体中的个体数目称为群体大小(population size)，也成为群体规模。而各个个体对环境的适应程度叫适应度(fitness)。</p>
<h3><span id="基本步骤">基本步骤</span><a href="#基本步骤" class="header-anchor"> </a></h3>
<h4><span id="编码">编码</span><a href="#编码" class="header-anchor"> </a></h4>
<p>GA在进行搜索之前先将解空间的解数据表示成遗传空间的基因型串结构数据，这些串结构数据的不同组合便构成了不同的点。</p>
<h4><span id="初始群体的生成">初始群体的生成</span><a href="#初始群体的生成" class="header-anchor"> </a></h4>
<p>随机产生N个初始串结构数据，每个串结构数据称为一个个体，N个个体构成了一个群体。GA以这N个串结构数据作为初始点开始进化。</p>
<h4><span id="适应度评估">适应度评估</span><a href="#适应度评估" class="header-anchor"> </a></h4>
<p>适应度表明个体或解的优劣性。不同的问题，适应度函数的定义方式也不同。</p>
<h4><span id="选择">选择</span><a href="#选择" class="header-anchor"> </a></h4>
<p>选择的目的是为了从当前群体中选出优良的个体，使它们有机会作为父代为下一代繁殖子孙。遗传算法通过选择过程体现这一思想，进行选择的原则是适应度强的个体为下一代贡献一个或多个后代的概率大。选择体现了达尔文的适者生存原则。</p>
<h4><span id="交叉">交叉</span><a href="#交叉" class="header-anchor"> </a></h4>
<p>交叉操作是遗传算法中最主要的遗传操作。通过交叉操作可以得到新一代个体，新个体组合了其父辈个体的特性。交叉体现了信息交换的思想。</p>
<h4><span id="变异">变异</span><a href="#变异" class="header-anchor"> </a></h4>
<p>变异首先在群体中随机选择一个个体，对于选中的个体以一定的概率随机地改变串结构数据中某个串的的值。同生物界一样，GA中变异发生的概率很低，通常取值很小。</p>
<h3><span id="实例详解">实例详解</span><a href="#实例详解" class="header-anchor"> </a></h3>
<p>之前已经使用matlab实现了一次，由于现在又布置了作业，正好现在对python不是特别熟悉，那就写个代码练练手吧。</p>
<h4><span id="目标函数">目标函数</span><a href="#目标函数" class="header-anchor"> </a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">max    f (x1, x2) = 21.5 + x1·sin(4 pi x1) + x2·sin(20 pi x2)  </span><br><span class="line">  </span><br><span class="line">s. t.    -3.0 &lt;= x1 &lt;= 12.1  </span><br><span class="line">          4.1 &lt;= x2 &lt;= 5.8</span><br></pre></td></tr></table></figure>
<p><img src="//img.tianle.me/image/20170419/maxfunction.jpg" alt="function"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.decoding(self.code_x1, self.code_x2)</span><br><span class="line">        self.y = <span class="number">21.5</span> + self.x1 * math.sin(<span class="number">4</span> * math.pi * self.x1) + self.x2 * math.sin(<span class="number">20</span> * math.pi * self.x2)</span><br></pre></td></tr></table></figure>
<h4><span id="二进制编码">二进制编码</span><a href="#二进制编码" class="header-anchor"> </a></h4>
<p>在刚刚提到的遗传算法中，我们首先要将数据进行编码，这里我们采用二进制的方式进行编码。第一步，我们根据题目的介绍可以得知该函数含有两个变量，以及各自的定义域。在二进制编码中，我们首先要先计算它的编码长度。计算公式如下:</p>
$${2^{{m_j} - 1}} < ({b_j} - {a_j})*precision \le {2^{{m_j}}} - 1$$
<p>其中precision为精度，如小数点后5位，则precision=10^5，m<sub>j</sub>为编码长度，${x_j} \in [{a_j},{b_j}]$</p>
<h4><span id="二进制解码">二进制解码</span><a href="#二进制解码" class="header-anchor"> </a></h4>
<p>解码即编码的逆过程:</p>
$${x_j} = {a_j} + {\rm{decimal}}(substrin{g_j}) \times \frac{{{b_j} - {a_j}}}{{{2^{{m_j}}} - 1}}$$
<p><img src="//img.tianle.me/image/20170419/coding.jpg" alt="function"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decoding</span><span class="params">(self, code_x1, code_x2)</span>:</span></span><br><span class="line">        self.x1 = self.bounds[<span class="number">0</span>][<span class="number">0</span>] + int(code_x1, <span class="number">2</span>) * (self.bounds[<span class="number">0</span>][<span class="number">1</span>] - self.bounds[<span class="number">0</span>][<span class="number">0</span>]) / (</span><br><span class="line">        <span class="number">2</span> ** self.code_x1_length - <span class="number">1</span>)</span><br><span class="line">        self.x2 = self.bounds[<span class="number">1</span>][<span class="number">0</span>] + int(code_x2, <span class="number">2</span>) * (self.bounds[<span class="number">1</span>][<span class="number">1</span>] - self.bounds[<span class="number">1</span>][<span class="number">0</span>]) / (</span><br><span class="line">        <span class="number">2</span> ** self.code_x2_length - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4><span id="种群初始化">种群初始化</span><a href="#种群初始化" class="header-anchor"> </a></h4>
<p>编码完成那我们就开始对种群初始化吧，为了简便我采用了随机地方式进行初始化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, bounds, precision)</span>:</span></span><br><span class="line">        self.x1 = <span class="number">1</span></span><br><span class="line">        self.x2 = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        self.y = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.code_x1 = <span class="string">''</span></span><br><span class="line">        self.code_x2 = <span class="string">''</span></span><br><span class="line"></span><br><span class="line">        self.bounds = bounds</span><br><span class="line"></span><br><span class="line">        temp1 = (bounds[<span class="number">0</span>][<span class="number">1</span>] - bounds[<span class="number">0</span>][<span class="number">0</span>]) * precision</span><br><span class="line">        self.code_x1_length = math.ceil(math.log(temp1, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">        temp2 = (bounds[<span class="number">1</span>][<span class="number">1</span>] - bounds[<span class="number">1</span>][<span class="number">0</span>]) * precision</span><br><span class="line">        self.code_x2_length = math.ceil(math.log(temp2, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">        self.rand_init()</span><br><span class="line">        self.func()</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rand_init</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.code_x1_length):</span><br><span class="line">            self.code_x1 += str(random.randint(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.code_x2_length):</span><br><span class="line">            self.code_x2 += str(random.randint(<span class="number">0</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h4><span id="选择">选择</span><a href="#选择" class="header-anchor"> </a></h4>
<p>选择我们采用轮盘赌方式进行选择，主要思想是适应度高的，被选择到的概率大。<br>
<img src="//img.tianle.me/image/20170419/selection.jpg" alt="function"></p>
<p>没怎么优化，用了一堆for循环。。。。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    轮盘赌选择</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># calculate fitness function</span></span><br><span class="line">    sum_f = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(self.pop_size):</span><br><span class="line">        self.pop[i].func()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># guarantee fitness &gt; 0</span></span><br><span class="line">    min = self.pop[<span class="number">0</span>].y</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(self.pop_size):</span><br><span class="line">        <span class="keyword">if</span> self.pop[i].y &lt; min:</span><br><span class="line">            min = self.pop[i].y</span><br><span class="line">    <span class="keyword">if</span> min &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.pop_size):</span><br><span class="line">            self.pop[i].y = self.pop[i].y + (<span class="number">-1</span>) * min</span><br><span class="line"></span><br><span class="line">    <span class="comment"># roulette</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(self.pop_size):</span><br><span class="line">        sum_f += self.pop[i].y</span><br><span class="line">    p = [<span class="number">0</span>] * self.pop_size</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(self.pop_size):</span><br><span class="line">        p[i] = self.pop[i].y / sum_f</span><br><span class="line">    q = [<span class="number">0</span>] * self.pop_size</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(self.pop_size):</span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i+<span class="number">1</span>):</span><br><span class="line">            s += p[j]</span><br><span class="line">        q[i] = s</span><br><span class="line">    <span class="comment"># start roulette</span></span><br><span class="line">    v = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(self.pop_size):</span><br><span class="line">        r = random.random()</span><br><span class="line">        <span class="keyword">if</span> r &lt; q[<span class="number">0</span>]:</span><br><span class="line">            v.append(self.pop[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, self.pop_size):</span><br><span class="line">            <span class="keyword">if</span> q[j - <span class="number">1</span>] &lt; r &lt;= q[j]:</span><br><span class="line">                v.append(self.pop[j])</span><br><span class="line">    self.pop = v</span><br></pre></td></tr></table></figure>
<h4><span id="变异">变异</span><a href="#变异" class="header-anchor"> </a></h4>
<p>这里的变异，我们先以变异概率，从种群中选一个，然后对选中的个体，随机选一个变异位点进行变异。<br>
<img src="//img.tianle.me/image/20170419/mutation.jpg" alt="function"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mutation</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    变异</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(self.pop_size):</span><br><span class="line">        <span class="keyword">if</span> self.pm &gt; random.random():</span><br><span class="line">            pop = self.pop[i]</span><br><span class="line">            <span class="comment"># select mutation index</span></span><br><span class="line">            index1 = random.randint(<span class="number">0</span>, pop.code_x1_length<span class="number">-1</span>)</span><br><span class="line">            index2 = random.randint(<span class="number">0</span>, pop.code_x2_length<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">            i = pop.code_x1[index1]</span><br><span class="line">            i = self.__inverse(i)</span><br><span class="line">            pop.code_x1 = pop.code_x1[:index1] + i + pop.code_x1[index1+<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">            i = pop.code_x2[index2]</span><br><span class="line">            i = self.__inverse(i)</span><br><span class="line">            pop.code_x2 = pop.code_x2[:index2] + i + pop.code_x2[index2+<span class="number">1</span>:]</span><br></pre></td></tr></table></figure>
<h4><span id="交叉">交叉</span><a href="#交叉" class="header-anchor"> </a></h4>
<p>这里采用单点交叉法。随机从种群中选两个个体，然后再随机选一个交叉点，交换位置。看图 = . =</p>
<p><img src="//img.tianle.me/image/20170419/crossover.jpg" alt="function"></p>
<p><img src="//img.tianle.me/image/20170419/crossoverCode.jpg" alt="function"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    交叉</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(self.pop_size / <span class="number">2</span>)):</span><br><span class="line">        <span class="keyword">if</span> self.pc &gt; random.random():</span><br><span class="line">            <span class="comment"># randon select 2 chromosomes in pops</span></span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            j = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i == j:</span><br><span class="line">                i = random.randint(<span class="number">0</span>, self.pop_size<span class="number">-1</span>)</span><br><span class="line">                j = random.randint(<span class="number">0</span>, self.pop_size<span class="number">-1</span>)</span><br><span class="line">            pop_i = self.pop[i]</span><br><span class="line">            pop_j = self.pop[j]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># select cross index</span></span><br><span class="line">            pop_1 = random.randint(<span class="number">0</span>, pop_i.code_x1_length - <span class="number">1</span>)</span><br><span class="line">            pop_2 = random.randint(<span class="number">0</span>, pop_i.code_x2_length - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># get new code</span></span><br><span class="line">            new_pop_i_code1 = pop_i.code_x1[<span class="number">0</span>: pop_1] + pop_j.code_x1[pop_1: pop_i.code_x1_length]</span><br><span class="line">            new_pop_i_code2 = pop_i.code_x2[<span class="number">0</span>: pop_2] + pop_j.code_x2[pop_2: pop_i.code_x2_length]</span><br><span class="line"></span><br><span class="line">            new_pop_j_code1 = pop_j.code_x1[<span class="number">0</span>: pop_1] + pop_i.code_x1[pop_1: pop_i.code_x1_length]</span><br><span class="line">            new_pop_j_code2 = pop_j.code_x2[<span class="number">0</span>: pop_2] + pop_i.code_x2[pop_2: pop_i.code_x2_length]</span><br><span class="line"></span><br><span class="line">            pop_i.code_x1 = new_pop_i_code1</span><br><span class="line">            pop_i.code_x2 = new_pop_i_code2</span><br><span class="line"></span><br><span class="line">            pop_j.code_x1 = new_pop_j_code1</span><br><span class="line">            pop_j.code_x2 = new_pop_j_code2</span><br></pre></td></tr></table></figure>
<h4><span id="算法主流程">算法主流程</span><a href="#算法主流程" class="header-anchor"> </a></h4>
<p>至此，遗传的主要框架已经完毕，下面展示主流程，及画图部分代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ga</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    算法主函数</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self.init_pop()</span><br><span class="line">    best = self.find_best()</span><br><span class="line">    self.g_best = copy.deepcopy(best)</span><br><span class="line">    y = [<span class="number">0</span>] * self.pop_size</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(self.max_gen):</span><br><span class="line">        self.cross()</span><br><span class="line">        self.mutation()</span><br><span class="line">        self.select()</span><br><span class="line">        best = self.find_best()</span><br><span class="line">        self.bests[i] = best</span><br><span class="line">        <span class="keyword">if</span> self.g_best.y &lt; best.y:</span><br><span class="line">            self.g_best = copy.deepcopy(best)</span><br><span class="line">        y[i] = self.g_best.y</span><br><span class="line">        print(self.g_best.y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># plt</span></span><br><span class="line">    plt.figure(<span class="number">1</span>)</span><br><span class="line">    x = range(self.pop_size)</span><br><span class="line">    plt.plot(x, y)</span><br><span class="line">    plt.ylabel(<span class="string">'generations'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'function value'</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<h4><span id="实验结果图">实验结果图</span><a href="#实验结果图" class="header-anchor"> </a></h4>
<p><img src="//img.tianle.me/image/20170419/result.png" alt="function"></p>
<h3><span id="总结">总结</span><a href="#总结" class="header-anchor"> </a></h3>
<p>在编码的时候，我偷懒了一下，把两个变量拆开写，x1和x2，导致之后的操作变得异常复杂，并且不利于代码重构。<br>
程序中过多的使用了for循环，并没有对此进行优化。<br>
针对上述两个问题，在此记录一下。</p>
<h3><span id="程序完整代码">程序完整代码</span><a href="#程序完整代码" class="header-anchor"> </a></h3>
<p><a href="https://github.com/zhangtianle/Genetic-Algorithms" target="_blank" rel="noopener">Genetic-Algorithms</a></p>
<h3><span id="参考资料">参考资料</span><a href="#参考资料" class="header-anchor"> </a></h3>
<p>《MATLAB智能算法-30个案例分析》</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>计算智能</tag>
        <tag>GA</tag>
        <tag>目标优化</tag>
        <tag>遗传</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2017华为软件精英挑战赛心得</title>
    <url>/2017/04/06/huawei2017/</url>
    <content><![CDATA[<p>连续撸了一整个清明假期的挑战赛代码终于结束了。作为比赛的最后，做个小小的总结。</p>
<a id="more"></a>
<h3><span id="一些小感悟">一些小感悟</span><a href="#一些小感悟" class="header-anchor"> </a></h3>
<ol>
<li>写代码的时候，千万不要为了方便随意使用全局变量，使用全局变量后，代码的耦合度大大提高。</li>
<li>对于这类比赛，能对特定的case进行特定的编程或者调参，对结果会有一定提升（可能会被禁止）。</li>
<li>对于每一次提交，保存好当前的提交版本，使用git是一个不错的方案。</li>
<li>看不懂的代码最好不要随意复制，出了问题怎么改都不知道。</li>
<li>团队的互相协助，是在比赛中陷入僵局时的解药。</li>
</ol>
<h3><span id="题目">题目</span><a href="#题目" class="header-anchor"> </a></h3>
<p><a href="https://img.tianle.me/image/20170406/huawei2017.pdf" target="_blank" rel="noopener">【PDF】赛题</a></p>
<h3><span id="求解思路">求解思路</span><a href="#求解思路" class="header-anchor"> </a></h3>
<p>基本思路是最小费用流+遗传<br>
在刚看到题目的时候，很容易发现这是一个最优化问题，而且属于NP-难问题。因此我第一个想法就是，采用遗传或者粒子群算法进行求解，目标函数根据题意很快就可以写出，我们使用费用函数即可，但是却不知道怎么个编码，对服务器编码 or 网络流编码 or both。<br>
直到我找到了最小费用最大流算法，使用该算法，输入服务器节点，即可计算出从服务器到满足各个消费节点需求的最小费用网络流路径。这样，结合第一个思路，算法的整体框架就很明确了。我们先通过遗传算法，产生一堆服务器节点，然后将这些服务器节点输入到最小费用流算法中，得出各条路径，通过路径和服务器信息我们既可以得出该方案下的网络费用，将费用作为遗传算法的适应度函数，再使用遗传算法中的变异、交叉、选择等操作，选出优秀的染色体，然后返回最小费用流算法，如此迭代循环。下面展示算法的流程图。<br>
<img src="//img.tianle.me/image/20170406/2.png" alt="liuchengtu"></p>
<h3><span id="最大流-最小费用算法">最大流、最小费用算法</span><a href="#最大流-最小费用算法" class="header-anchor"> </a></h3>
<p>算法的具体过程这里我就不展开了，放上比赛时，我们参考的一些文档与网页。<br>
<a href="https://img.tianle.me/image/20170406/11_NF_3.pdf" target="_blank" rel="noopener">【PDF】网络流的应用</a><br>
<a href="https://riteme.github.io/blog/2016-2-2/mincost-maxflow.html" target="_blank" rel="noopener">最小费用最大流</a><br>
<a href="https://artofproblemsolving.com/community/c1368h1020435__zkw" target="_blank" rel="noopener">从入门到精通: 最小费用流的“zkw算法”</a></p>
<h3><span id="spfa算法">SPFA算法</span><a href="#spfa算法" class="header-anchor"> </a></h3>
<p>SPFA是一种单源最短路径算法。在这个题目中，我们使用了最小费用流算法，网络中存在负权边，大家熟知的Dijkstra算法便失去了用武之地。SPFA该上场了。<br>
SPFA算法的详细步骤，看看下面这个链接就好了(⊙o⊙)<a href="http://blog.csdn.net/muxidreamtohit/article/details/7894298" target="_blank" rel="noopener">SPFA 算法详解( 强大图解，不会都难！) </a><br>
接下来我说说针对赛题的改进策略。<br>
首先，SPFA算法本身有两种改进策略：SLF 和 LLL<br>
<strong>SLF：Small Label First 策略</strong>，设要加入的节点是<code>j</code>，队首元素为<code>i</code>，若<code>dist(j) &lt; dist(i)</code>，则将j插入队首，否则插入队尾。</p>
<p><strong>LLL：Large Label Last 策略</strong>，设队首元素为<code>i</code>，队列中所有<code>dist</code>值的平均值为<code>x</code>，若<code>dist(i)&gt;x</code>则将<code>i</code>插入到队尾，查找下一元素，直到找到某一<code>i</code>使得<code>dist(i) &lt;= x</code>，则将i出对进行松弛操作。<br>
SLF 可使速度提高 15 ~ 20%；SLF + LLL 可提高约 50%。</p>
<p>其次，我们在最小费用流使用SPFA算法时，我们只需要知道是否存在从S到T的路径，而不必需要他们之间的最短路径，因此，我们在求到了其中的一条路径时<code>dist != null</code>，即可返回，不必继续执行。</p>
<h3><span id="程序代码">程序代码</span><a href="#程序代码" class="header-anchor"> </a></h3>
<p>比赛的代码我已经放到<a href="https://github.com/zhangtianle/huawei2017" target="_blank" rel="noopener">GitHub</a>上，写的比较糟糕，没有优化，请各位大佬轻喷+_+</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>华为</tag>
        <tag>参赛心得</tag>
      </tags>
  </entry>
  <entry>
    <title>python二维数组重复赋值问题</title>
    <url>/2017/02/28/python-array/</url>
    <content><![CDATA[<p>今天在写程序时遇到一个怪异的问题，采用双重for循环对一个二维数组中的每一个元素进行赋值，结果发现，它们的每一列都一起改变了。例子如下:</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">k = <span class="number">0</span></span><br><span class="line">a = [[<span class="number">0</span>] * <span class="number">3</span>] * <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        a[i][j] = k</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[6, 7, 8], [6, 7, 8], [6, 7, 8]]</span><br></pre></td></tr></table></figure>
<p>百思不得其解，搜索得知，Python中的list属于一个可变对象，那么对它进行赋值时，会进行一个浅拷贝。所谓浅拷贝，我们可以把它理解为引用，仅仅复制了容器中元素的地址，改变其中一个，其对应的值也会随之改变。<br>
例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr       = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr       = [arr]*<span class="number">2</span></span><br><span class="line">arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">arr[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">200</span></span><br><span class="line">print(arr)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[100, 1, 2, 200], [100, 1, 2, 200]]</span><br></pre></td></tr></table></figure>
<p>为了防止这种浅拷贝，我们需要换个方式来创建二位数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [([<span class="number">0</span>] * <span class="number">3</span>) <span class="keyword">for</span> p <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br></pre></td></tr></table></figure>
<p>这样我们就避免了浅拷贝带来的影响（意外中改变了值）<br>
我们在进行一次实验：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">k = <span class="number">0</span></span><br><span class="line">a = [([<span class="number">0</span>] * <span class="number">3</span>) <span class="keyword">for</span> p <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        a[i][j] = k</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0, 1, 2], [3, 4, 5], [6, 7, 8]]</span><br></pre></td></tr></table></figure>
<p>解决！</p>
<p>参考链接:<br>
<a href="https://segmentfault.com/q/1010000003482195" target="_blank" rel="noopener">Python 二维数组赋值</a><br>
<a href="http://www.cnblogs.com/btchenguang/archive/2012/01/30/2332479.html" target="_blank" rel="noopener">python的二维数组操作</a><br>
<a href="http://www.jianshu.com/p/efa9dd51f5cc#" target="_blank" rel="noopener">谈谈python中的深拷贝和浅拷贝</a></p>
]]></content>
      <categories>
        <category>应用开发</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>使用TensorFlow-GUP并在Ubuntu上安装CUDA cuDNN</title>
    <url>/2017/02/01/installCUDA/</url>
    <content><![CDATA[<p>为了加速TensorFlow的计算，我们采用TensorFlow的GUP版本。其需要CUDA和cuDNN，本文将以Ubuntu为例。</p>
<a id="more"></a>
<blockquote>
<p><strong>Requirements</strong><br>
The TensorFlow Python API supports Python 2.7 and Python 3.3+.<br>
The GPU version works best with Cuda Toolkit 8.0 and cuDNN v5.1. Other versions are supported (Cuda toolkit &gt;= 7.0 and cuDNN &gt;= v3) only when installing from sources. Please see Cuda installation for details. For Mac OS X, please see Setup GPU for Mac.</p>
</blockquote>
<h3><span id="本机环境">本机环境</span><a href="#本机环境" class="header-anchor"> </a></h3>
<p>操作系统： Linux Mint 18.1 Serena<br>
CPU： Intel® Core™ i5-3210M CPU @ 2.50GHz<br>
GPU： GeForce GT 635M</p>
<h3><span id="cuda安装步骤">CUDA安装步骤</span><a href="#cuda安装步骤" class="header-anchor"> </a></h3>
<h4><span id="安装显卡驱动">安装显卡驱动</span><a href="#安装显卡驱动" class="header-anchor"> </a></h4>
<p>System Setting --&gt; Driver Manager 选择合适的驱动<br>
<img src="//img.tianle.me/image/20170201/1.png" alt="driver manger"></p>
<h4><span id="下载cuda">下载CUDA</span><a href="#下载cuda" class="header-anchor"> </a></h4>
<p><a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">点击此处进行下载</a><br>
<img src="//img.tianle.me/image/20170201/2.png" alt="cuda downloads"></p>
<h4><span id="运行安装cuda">运行安装CUDA</span><a href="#运行安装cuda" class="header-anchor"> </a></h4>
<p>进入刚刚下载的目录，并在终端中运行<br>
Run <code>sudo sh cuda_8.0.44_linux.run</code><br>
Follow the command-line prompts<br>
在安装过程中会询问是否安装显卡驱动，由于我们在第一步中已经安装，所以我们选择no（不安装）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Do you accept the previously read EULA? (accept/decline/quit): accept  </span><br><span class="line">You are attempting to install on an unsupported configuration. Do you wish to continue? ((y)es/(n)o) [ default is no ]: y  </span><br><span class="line">Install NVIDIA Accelerated Graphics Driver for Linux-x86_64 352.39? ((y)es/(n)o/(q)uit): n  </span><br><span class="line">Install the CUDA 8.0 Toolkit? ((y)es/(n)o/(q)uit): y  </span><br><span class="line">Enter Toolkit Location [ default is /usr/local/cuda-8.0 ]:  </span><br><span class="line">Do you want to install a symbolic link at /usr/local/cuda? ((y)es/(n)o/(q)uit): y  </span><br><span class="line">Install the CUDA 8.0 Samples? ((y)es/(n)o/(q)uit): y  </span><br><span class="line">Enter CUDA Samples Location [ default is /home/kyle ]:</span><br></pre></td></tr></table></figure>
<p>等待完成安装即可。<br>
安装完成后可能会有警告，提示samplees缺少必要的包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Installing the CUDA Toolkit in /usr/local/cuda-8.0 ...</span><br><span class="line">Missing recommended library: libGLU.so</span><br><span class="line">Missing recommended library: libX11.so</span><br><span class="line">Missing recommended library: libXi.so</span><br><span class="line">Missing recommended library: libXmu.so</span><br><span class="line">Missing recommended library: libGL.so</span><br><span class="line"></span><br><span class="line">Installing the CUDA Samples in /home/kyle ...</span><br><span class="line">Copying samples to /home/kyle/NVIDIA_CUDA-8.0_Samples now...</span><br><span class="line">Finished copying samples.</span><br><span class="line"></span><br><span class="line">===========</span><br><span class="line">= Summary =</span><br><span class="line">===========</span><br><span class="line"></span><br><span class="line">Driver:   Not Selected</span><br><span class="line">Toolkit:  Installed in /usr/local/cuda-8.0</span><br><span class="line">Samples:  Installed in /home/kyle, but missing recommended libraries</span><br><span class="line"></span><br><span class="line">Please make sure that</span><br><span class="line"> -   PATH includes /usr/local/cuda-8.0/bin</span><br><span class="line"> -   LD_LIBRARY_PATH includes /usr/local/cuda-8.0/lib64, or, add /usr/local/cuda-8.0/lib64 to /etc/ld.so.conf and run ldconfig as root</span><br><span class="line"></span><br><span class="line">To uninstall the CUDA Toolkit, run the uninstall script in /usr/local/cuda-8.0/bin</span><br><span class="line"></span><br><span class="line">Please see CUDA_Installation_Guide_Linux.pdf in /usr/local/cuda-8.0/doc/pdf for detailed information on setting up CUDA.</span><br><span class="line"></span><br><span class="line">***WARNING: Incomplete installation! This installation did not install the CUDA Driver. A driver of version at least 361.00 is required for CUDA 8.0 functionality to work.</span><br><span class="line">To install the driver using this installer, run the following command, replacing &lt;CudaInstaller&gt; with the name of this run file:</span><br><span class="line">    sudo &lt;CudaInstaller&gt;.run -silent -driver</span><br><span class="line"></span><br><span class="line">Logfile is /tmp/cuda_install_9426.log</span><br></pre></td></tr></table></figure>
<p>这几个包可以不用管他，不用这几个sample是没有问题的。</p>
<h4><span id="配置环境变量">配置环境变量</span><a href="#配置环境变量" class="header-anchor"> </a></h4>
<p>打开shell运行：<code>gedit ~/.bashrc</code>
加入如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># add cuda</span><br><span class="line">export PATH=/usr/local/cuda-8.0/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>
<p>立即生效，运行<code>source ~/.bashrc</code></p>
<p>关于linux环境变量的设置可参考：<br>
<a href="http://www.cnblogs.com/hdk1993/p/4509302.html" target="_blank" rel="noopener">Ubuntu中设置环境变量详解</a><br>
<a href="http://www.powerxing.com/linux-environment-variable/" target="_blank" rel="noopener">设置Linux环境变量的方法和区别_Ubuntu</a></p>
<h4><span id="测试是否安装成功">测试是否安装成功</span><a href="#测试是否安装成功" class="header-anchor"> </a></h4>
<ol>
<li>查看CUDA版本</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kyle@kyle-Lenovo-M490 ~ $ nvcc -V</span><br><span class="line">nvcc: NVIDIA (R) Cuda compiler driver</span><br><span class="line">Copyright (c) 2005-2016 NVIDIA Corporation</span><br><span class="line">Built on Sun_Sep__4_22:14:01_CDT_2016</span><br><span class="line">Cuda compilation tools, release 8.0, V8.0.44</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>编译 CUDA Samples<br>
进入samples的安装目录<br>
为了节约时间，我们选择其中一个进行编译如：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kyle@kyle-Lenovo-M490 ~ $ cd ~/NVIDIA_CUDA-8.0_Samples/0_Simple/vectorAdd</span><br><span class="line">kyle@kyle-Lenovo-M490 ~/NVIDIA_CUDA-8.0_Samples/0_Simple/vectorAdd $ make</span><br><span class="line">&quot;/usr/local/cuda-8.0&quot;/bin/nvcc -ccbin g++ -I../../common/inc  -m64    -gencode arch=compute_20,code=sm_20 -gencode arch=compute_30,code=sm_30 -gencode arch=compute_35,code=sm_35 -gencode arch=compute_37,code=sm_37 -gencode arch=compute_50,code=sm_50 -gencode arch=compute_52,code=sm_52 -gencode arch=compute_60,code=sm_60 -gencode arch=compute_60,code=compute_60 -o vectorAdd.o -c vectorAdd.cu</span><br><span class="line">nvcc warning : The &apos;compute_20&apos;, &apos;sm_20&apos;, and &apos;sm_21&apos; architectures are deprecated, and may be removed in a future release (Use -Wno-deprecated-gpu-targets to suppress warning).</span><br><span class="line">&quot;/usr/local/cuda-8.0&quot;/bin/nvcc -ccbin g++   -m64      -gencode arch=compute_20,code=sm_20 -gencode arch=compute_30,code=sm_30 -gencode arch=compute_35,code=sm_35 -gencode arch=compute_37,code=sm_37 -gencode arch=compute_50,code=sm_50 -gencode arch=compute_52,code=sm_52 -gencode arch=compute_60,code=sm_60 -gencode arch=compute_60,code=compute_60 -o vectorAdd vectorAdd.o</span><br><span class="line">nvcc warning : The &apos;compute_20&apos;, &apos;sm_20&apos;, and &apos;sm_21&apos; architectures are deprecated, and may be removed in a future release (Use -Wno-deprecated-gpu-targets to suppress warning).</span><br><span class="line">mkdir -p ../../bin/x86_64/linux/release</span><br><span class="line">cp vectorAdd ../../bin/x86_64/linux/release</span><br><span class="line">kyle@kyle-Lenovo-M490 ~/NVIDIA_CUDA-8.0_Samples/0_Simple/vectorAdd $ ./vectorAdd</span><br><span class="line">[Vector addition of 50000 elements]</span><br><span class="line">Copy input data from the host memory to the CUDA device</span><br><span class="line">CUDA kernel launch with 196 blocks of 256 threads</span><br><span class="line">Copy output data from the CUDA device to the host memory</span><br><span class="line">Test PASSED</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>
<p>如果没有报错，则安装完成</p>
<h3><span id="cudnn安装步骤">cuDNN安装步骤</span><a href="#cudnn安装步骤" class="header-anchor"> </a></h3>
<p>接下来我们安装<a href="https://developer.nvidia.com/cudnn" target="_blank" rel="noopener">cuDNN</a><br>
在下载cuDNN之前，我们需要注册一个账号</p>
<blockquote>
<p>cuDNN is freely available to members of the Accelerated Computing Developer Program</p>
</blockquote>
<p>注册完账号后我们选择下载<br>
选择<code>cuDNN v5.1 Library for Linux</code><br>
<img src="//img.tianle.me/image/20170201/3.png" alt="cuDNN downloads"><br>
安装cuDNN非常简单，我们只需解压下载的包，并将其拷贝到<code>lib64</code>和<code>include</code>这两个目录即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ~</span><br><span class="line">$ tar -zxf cudnn-8.0-linux-x64-v5.1.tgz</span><br><span class="line">$ cd cuda</span><br><span class="line">$ sudo cp lib64/* /usr/local/cuda/lib64/</span><br><span class="line">$ sudo cp include/* /usr/local/cuda/include/</span><br></pre></td></tr></table></figure>
<p>恭喜你！ cuDNN 已经安装成功</p>
<h3><span id="安装完成">安装完成</span><a href="#安装完成" class="header-anchor"> </a></h3>
<p>至此，CUDA与cuDNN已经安装完成</p>
<h3><span id="安装tensorflow-gup">安装TensorFlow-GUP</span><a href="#安装tensorflow-gup" class="header-anchor"> </a></h3>
<p>安装TensorFlow-GUP非常简单，我们使用pip即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip install tensorflow-gpu</span><br></pre></td></tr></table></figure>
<p>如有问题，参考<a href="https://www.tensorflow.org/get_started/os_setup" target="_blank" rel="noopener">TensorFlow下载与安装</a></p>
<h3><span id="测试tensorflow">测试TensorFlow</span><a href="#测试tensorflow" class="header-anchor"> </a></h3>
<p>我们在Python环境中输入<code>import tensorflow</code>看看能否成功导入cuda</p>
<pre><code>Python 3.5.2 |Anaconda custom (64-bit)| (default, Jul  2 2016, 17:53:06)
[GCC 4.4.7 20120313 (Red Hat 4.4.7-1)] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; import tensorflow
I tensorflow/stream_executor/dso_loader.cc:128] successfully opened CUDA library libcublas.so locally
I tensorflow/stream_executor/dso_loader.cc:128] successfully opened CUDA library libcudnn.so locally
I tensorflow/stream_executor/dso_loader.cc:128] successfully opened CUDA library libcufft.so locally
I tensorflow/stream_executor/dso_loader.cc:128] successfully opened CUDA library libcuda.so.1 locally
I tensorflow/stream_executor/dso_loader.cc:128] successfully opened CUDA library libcurand.so locally
&gt;&gt;&gt;
</code></pre>
<p>哈哈！恭喜你，完成啦！</p>
<h3><span id="参考资料">参考资料</span><a href="#参考资料" class="header-anchor"> </a></h3>
<p><a href="http://www.pyimagesearch.com/2016/07/04/how-to-install-cuda-toolkit-and-cudnn-for-deep-learning/" target="_blank" rel="noopener">How to install CUDA Toolkit and cuDNN for deep learning</a><br>
<a href="https://gist.github.com/dangbiao1991/2c895917ea888ce33af8c1c72444b7bf" target="_blank" rel="noopener">Ubuntu 16.04 安装 NVIDIA CUDA Toolkit 7.5</a></p>
]]></content>
      <categories>
        <category>研究</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
        <tag>CUDA</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>disqus不能加载解决办法</title>
    <url>/2017/01/22/disquscantload/</url>
    <content><![CDATA[<p>由于多说的头像不支持https，以及UI不好看，经过一番折腾，最终决定将评论系统转至disqus</p>
<a id="more"></a>
<p>博客使用hexo的next主题搭建，根据next作者的文档进行配置，但是在从多说切换至disqus后，博客页面的评论始终无法显示，disqus显示无法加载，页面显示</p>
<blockquote>
<p>We were unable to load Disqus. If you are a moderator please see our troubleshooting guide.</p>
</blockquote>
<h4><span id="问题产生原因及解决办法">问题产生原因及解决办法</span><a href="#问题产生原因及解决办法" class="header-anchor"> </a></h4>
<p><strong>产生原因：</strong> 没有配置hexo的站点url。<a href="https://hexo.io/docs/configuration.html" target="_blank" rel="noopener">hexo Configuration</a>  <em>(配置文件为站点根目录下的_config.yml)</em><br>
<strong>解决方案：</strong> 根据文档提示填写站点url即可，如<code>http://tianle.me</code></p>
<h5><span id="例">例：</span><a href="#例" class="header-anchor"> </a></h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: http://tianle.me</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure>
<h4><span id="参考">参考</span><a href="#参考" class="header-anchor"> </a></h4>
<p><a href="https://github.com/iissnan/hexo-theme-next/issues/876" target="_blank" rel="noopener">disqus 不能load的一种可能分析和解决方案</a><br>
<a href="https://github.com/JamesPan/duoshuo-migrator" target="_blank" rel="noopener">多说评论导入DISQUS</a></p>
]]></content>
      <categories>
        <category>应用开发</category>
      </categories>
      <tags>
        <tag>disqus</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>MathType输入不存在符号</title>
    <url>/2016/12/20/notExistsSys/</url>
    <content><![CDATA[<p>最近在使用MathType编写公式时，在其面板中一直找不到不存在的符号$\nexists$，通过网上搜索得知，可以将<code>\nexists</code>或者<code>\not\exists</code>复制到MathType输入框中即可。</p>
<a id="more"></a>
<blockquote>
<p><a href="http://bbs.ctex.org/forum.php?mod=viewthread&amp;tid=60608" target="_blank" rel="noopener">如何输入“不存在符号”</a></p>
</blockquote>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>【分享】在线AI技术在搜索与推荐场景的应用</title>
    <url>/2016/12/06/aliAI/</url>
    <content><![CDATA[<p>分享<a href="https://atf.alibaba.com/?spm=0.0.0.0.cafjha#index" target="_blank" rel="noopener">2016阿里巴巴技术论坛</a>（Alibaba Technology Forum，简称ATF）中《在线AI技术在搜索与推荐场景的应用》徐盈辉（仁基）的演讲PPT</p>
<a id="more"></a>
<p><img src="//img.tianle.me/image/20161206/1.png" alt="enter image description here">
<img src="//img.tianle.me/image/20161206/2.png" alt="enter image description here">
<img src="//img.tianle.me/image/20161206/3.png" alt="enter image description here">
<img src="//img.tianle.me/image/20161206/4.png" alt="enter image description here">
<img src="//img.tianle.me/image/20161206/5.png" alt="enter image description here">
<img src="//img.tianle.me/image/20161206/6.png" alt="enter image description here">
<img src="//img.tianle.me/image/20161206/7.png" alt="enter image description here">
<img src="//img.tianle.me/image/20161206/8.png" alt="enter image description here">
<img src="//img.tianle.me/image/20161206/9.png" alt="enter image description here">
<img src="//img.tianle.me/image/20161206/10.png" alt="enter image description here">
<img src="//img.tianle.me/image/20161206/11.png" alt="enter image description here">
<img src="//img.tianle.me/image/20161206/12.png" alt="enter image description here">
<img src="//img.tianle.me/image/20161206/13.png" alt="enter image description here">
<img src="//img.tianle.me/image/20161206/14.png" alt="enter image description here">
<img src="//img.tianle.me/image/20161206/15.png" alt="enter image description here">
<img src="//img.tianle.me/image/20161206/16.png" alt="enter image description here">
<img src="//img.tianle.me/image/20161206/17.png" alt="enter image description here">
<img src="//img.tianle.me/image/20161206/18.png" alt="enter image description here"></p>
]]></content>
      <categories>
        <category>研究</category>
      </categories>
  </entry>
  <entry>
    <title>斐讯K1S路由器刷机</title>
    <url>/2016/11/22/phicommPassionRoot/</url>
    <content><![CDATA[<p>斐讯路由器“免费”的活动已经过了大半年了，官网以及商店中都明确表示该活动真实有效，身边也有一些朋友购买了该路由，确实也获得了返现。之前上过计算机网络编程的相关课程，对课程中提到的计算机网络协议，openWRT等充满兴趣，但一直没有实践。基于以上背景，驱使我上车买台路由器试试。</p>
<a id="more"></a>
<p><a href="http://www.phicomm.com/cn/index.php/News/detail/cateid/2/id/372.html" target="_blank" rel="noopener">斐讯官网的声明</a></p>
<blockquote>
<p>[严正声明]关于“斐讯路由器0元购”活动
致广大新老用户：<br>
　　我司上海斐讯数据通信技术有限公司于2016年1月5日起开展【斐讯路由器0元购】活动，活动内容为：在活动店铺购买参与活动的斐讯路由器， 即可获得一个K码，激活后全额返现。本次活动正在联合上海联璧电子科技有限公司顺利开展。<br>
　　请新老客户仔细阅读活动细则，并放心参与【斐讯路由器0元购】活动。</p>
</blockquote>
<p>在购买时考虑到可能会有一定风险，因此购买了中等价位的199元的K1s路由。</p>
<h2><span id="准备刷机">准备刷机</span><a href="#准备刷机" class="header-anchor"> </a></h2>
<p>下载刷机所需必要文件，可在本文底端的“刷机素材下载”中，<a href="http://pan.baidu.com/s/1pLyFMm3" target="_blank" rel="noopener">本文提到的所需素材</a>下载</p>
<ol>
<li>将路由器接通电源，通过网线将交换机与电脑相连。</li>
<li>打开电脑浏览器，在地址栏中输入http://192.168.2.1 ，登录账号名以及密码为admin、admin</li>
<li>在web管理界面中依次点击“高级设置”——“系统管理”</li>
<li>上传经过修改的“官方”固件，K1s选择“K1S_V22.3.1.5.bin”，K2选择“K2 V22.4.2.8 测试版.bin”，点击升级<br>
<img src="//img.tianle.me/image/20161123/01.png-tianle.me" alt="降级"></li>
<li>等待路由器重启完毕，重新打开web管理界面<br>
<img src="//img.tianle.me/image/20161123/02.png-tianle.me" alt="enter link description here"></li>
</ol>
<h2><span id="开始刷机">开始刷机</span><a href="#开始刷机" class="header-anchor"> </a></h2>
<ol>
<li>在web管理界面中依次点击高级设置”——“系统设置”——“备份恢复“</li>
<li>在恢复配置文件一栏，点击浏览，选中配置文件“tianbaoha_breed_ssh.dat”</li>
<li>选择完毕后，点击“恢复备份”
<img src="//img.tianle.me/image/20161123/03.png-tianle.me" alt="恢复备份"></li>
<li>等待路由器重启完毕<br>
<img src="//img.tianle.me/image/20161123/02.png-tianle.me" alt="enter link description here"></li>
<li>重启完毕后登录web管理系统http://192.168.2.1，登录密码修改为 tianbaoha</li>
</ol>
<h2><span id="刷入第三方固件">刷入第三方固件</span><a href="#刷入第三方固件" class="header-anchor"> </a></h2>
<p>附一张华硕Padavan的固件图<br>
<img src="//img.tianle.me/image/20161123/5.png-tianle.me" alt="华硕Padavan"></p>
<h3><span id="方法一通过破解的管理界面升级">方法一：通过破解的管理界面升级</span><a href="#方法一通过破解的管理界面升级" class="header-anchor"> </a></h3>
<ol>
<li>在web管理界面中依次点击“高级设置”——“系统设置”——“手动升级” ，选择你想刷的第三方固件，并点击升级<br>
<img src="//img.tianle.me/image/20161123/04.png-tianle.me" alt="刷机"></li>
<li>等待路由器重启完毕后，重新进入web管理界面（华硕固件管理界面为：<a href="http://192.168.123.1" target="_blank" rel="noopener">http://192.168.123.1</a> 账号密码admin、admin，openwrt为：<a href="http://192.168.1.1" target="_blank" rel="noopener">http://192.168.1.1</a> 账号密码root、root）</li>
</ol>
<h3><span id="方法二通过下方所述的救砖方法进入breed恢复页面更新固件刷机">方法二：通过下方所述的救砖方法进入breed恢复页面，更新固件刷机</span><a href="#方法二通过下方所述的救砖方法进入breed恢复页面更新固件刷机" class="header-anchor"> </a></h3>
<p>简单来说为：把电源、插电源，同时按住复位按钮不放、松开按钮进入管理界面。具体如下见救砖方法</p>
<h2><span id="救砖gt_lt">救砖%&gt;_&lt;%</span><a href="#救砖gt_lt" class="header-anchor"> </a></h2>
<p>如果不小心将路由器刷成砖，或者因为设置错误无法进入路由器web管理界面，各位也不要害怕。毕竟还有救转方法，主要有两种方式：1强制进入breed恢复界面；2通过编程器重新写入代码。第二种方式需要编程器，由于博主没出现大故障，因此还没尝试使用第二种方式，一般来说使用方式一救转足矣，下面我来进行具体介绍。</p>
<ol>
<li>将路由器与电脑通过网线连接</li>
<li>电脑IP设置为192.168.1.2，子网设置为255.255.255.0</li>
<li>断开路由器电源</li>
<li>接通路由器电源，同时按住reset按钮不放，大约需要按住3-5秒</li>
<li>在电脑浏览器中访问http://192.168.1.1<br>
<img src="//img.tianle.me/image/20161123/1.jpg-tianle.me" alt="breed web恢复"></li>
<li>选择固件更新，选择需要上传的固件<br>
<img src="//img.tianle.me/image/20161123/2.jpg-tianle.me" alt="固件更新"></li>
<li>点击更新<br>
<img src="//img.tianle.me/image/20161123/3.jpg-tianle.me" alt="固件更新2"></li>
</ol>
<h2><span id="参考资料">参考资料</span><a href="#参考资料" class="header-anchor"> </a></h2>
<p><a href="http://blog.sina.com.cn/s/blog_dc642faa0102x1on.html" target="_blank" rel="noopener">斐讯新版V22固件（V22.3.17.148、V22.3.15.128等）K2 K1S路由刷机教程</a><br>
<a href="http://www.right.com.cn/forum/thread-161324-1-1.html" target="_blank" rel="noopener">改华硕[N14U N54U]5G 2G的7620老毛子Padavan固件</a><br>
<a href="http://post.smzdm.com/p/438946/" target="_blank" rel="noopener">免费的午餐要自己做——PHICOMM 斐讯 K2 简评兼刷机体验（附教程</a><br>
<a href="http://www.shaoit.com/feixunshuaji.html" target="_blank" rel="noopener">斐讯k2傻瓜刷机教程，一键刷breed刷华硕Padavan固件</a></p>
<h2><span id="刷机素材下载">刷机素材下载</span><a href="#刷机素材下载" class="header-anchor"> </a></h2>
<p><a href="http://pan.baidu.com/s/1pLyFMm3" target="_blank" rel="noopener">本文提到的所需素材</a><br>
<a href="https://bitbucket.org/padavan/rt-n56u/src" target="_blank" rel="noopener">rt-n56u project</a><br>
<a href="https://eyun.baidu.com/s/3kV0JV19#sharelink/path=/" target="_blank" rel="noopener">华硕固件下载百度云</a></p>
<h2><span id="扩展阅读">扩展阅读</span><a href="#扩展阅读" class="header-anchor"> </a></h2>
<p><a href="https://github.com/miao1007/Openwrt-NetKeeper/blob/master/README-CN.md" target="_blank" rel="noopener">Openwrt-NetKeeper 闪讯拨号</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>刷机</tag>
        <tag>瞎折腾</tag>
        <tag>路由器</tag>
        <tag>斐讯</tag>
      </tags>
  </entry>
  <entry>
    <title>提高Linux服务器安全</title>
    <url>/2016/11/14/serverSecurity/</url>
    <content><![CDATA[<p>虽然Linux已经很安全了，但是如果密码设置的不够复杂，如果说小写+数字共12位以下，你的SSH还用的默认端口，那么你的服务器是非常危险的。</p>
<a id="more"></a>
<p>下面放一张图，来展示一下攻击的频繁程度，大家自行体会一下。<br>
这个是我买的阿里主机<br>
<img src="//img.tianle.me/image/20161114/1.png" alt="服务器被攻击"><br>
好啦，下面开始正题：</p>
<h2><span id="修改ssh端口禁止root登陆">修改SSH端口+禁止ROOT登陆</span><a href="#修改ssh端口禁止root登陆" class="header-anchor"> </a></h2>
<p><strong>为了防止误操作，而导致无法登录系统，建议先新建快照</strong></p>
<h3><span id="修改默认ssh默认22端口">修改默认SSH默认22端口</span><a href="#修改默认ssh默认22端口" class="header-anchor"> </a></h3>
<h4><span id="一-修改文件etcsshsshd_config">一、修改文件：/etc/ssh/sshd_config</span><a href="#一-修改文件etcsshsshd_config" class="header-anchor"> </a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<p>在原来大约第5行的地方，修改Port 22，中的22端口号，建议改为1025-65535之间，不要和其他端口产生冲突即可。修改完成后记得保存。</p>
<h4><span id="二-重启ssh服务">二、重启ssh服务</span><a href="#二-重启ssh服务" class="header-anchor"> </a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/init.d/sshd restart #centos系统，重启ssh服务命令  </span><br><span class="line">/etc/init.d/ssh restart #debian/ubuntu系统，重启ssh服务命令  </span><br><span class="line">或 service ssh restart #debian/ubuntu系统，重启ssh服务命令</span><br></pre></td></tr></table></figure>
<h4><span id="三-修改防火墙配置">三、修改防火墙配置</span><a href="#三-修改防火墙配置" class="header-anchor"> </a></h4>
<p>改完端口号还不要忘了在防火墙中打开所修改的端口哦~</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/sbin/iptables -A INPUT -p tcp --dport 22(修改后的端口号) -j ACCEPT</span><br></pre></td></tr></table></figure>
<h3><span id="禁止root登录">禁止root登录</span><a href="#禁止root登录" class="header-anchor"> </a></h3>
<h4><span id="一-新建用户">一、新建用户</span><a href="#一-新建用户" class="header-anchor"> </a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo adduser username(要新建的用户名)</span><br></pre></td></tr></table></figure>
<p>按照提示一步步操作即可</p>
<h4><span id="二-修改配置文件禁止root登录">二、修改配置文件禁止root登录</span><a href="#二-修改配置文件禁止root登录" class="header-anchor"> </a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config #修改的文件还是这个</span><br><span class="line">PermitRootLogin no #把yes，改成no，保存退出，并重启SSH服务（上面有重启命令）</span><br></pre></td></tr></table></figure>
<p>OK 大功告成，还不赶紧试试</p>
<h2><span id="设置-ssh-通过密钥登录">设置 SSH 通过密钥登录</span><a href="#设置-ssh-通过密钥登录" class="header-anchor"> </a></h2>
<p>我们一般使用 PuTTY 等 SSH 客户端来远程管理 Linux 服务器。但是，一般的密码方式登录，容易有密码被暴力破解的问题。所以，一般我们会将 SSH 的端口设置为默认的 22 以外的端口，或者禁用 root 账户登录。其实，有一个更好的办法来保证安全，而且让你可以放心地用 root 账户从远程登录——那就是通过密钥方式登录。</p>
<p>密钥形式登录的原理是：利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。这样一来，没有私钥，任何人都无法通过 SSH 暴力破解你的密码来远程登录到系统。此外，如果将公钥复制到其他账户甚至主机，利用私钥也可以登录。</p>
<p>下面来讲解如何在 Linux 服务器上制作密钥对，将公钥添加给账户，设置 SSH，最后通过客户端登录。</p>
<h3><span id="1-制作密钥对">1. 制作密钥对</span><a href="#1-制作密钥对" class="header-anchor"> </a></h3>
<p>首先在服务器上制作密钥对。首先用密码登录到你打算使用密钥登录的账户，然后执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@host ~]$ ssh-keygen  &lt;== 建立密钥对</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/root/.ssh/id_rsa): &lt;== 按 Enter</span><br><span class="line">Created directory &apos;/root/.ssh&apos;.</span><br><span class="line">Enter passphrase (empty for no passphrase): &lt;== 输入密钥锁码，或直接按 Enter 留空</span><br><span class="line">Enter same passphrase again: &lt;== 再输入一遍密钥锁码</span><br><span class="line">Your identification has been saved in /root/.ssh/id_rsa. &lt;== 私钥</span><br><span class="line">Your public key has been saved in /root/.ssh/id_rsa.pub. &lt;== 公钥</span><br><span class="line">The key fingerprint is:</span><br><span class="line">0f:d3:e7:1a:1c:bd:5c:03:f1:19:f1:22:df:9b:cc:08 root@host</span><br></pre></td></tr></table></figure>
<p>密钥锁码在使用私钥时必须输入，这样就可以保护私钥不被盗用。当然，也可以留空，实现无密码登录。</p>
<p>现在，在 root 用户的家目录中生成了一个 .ssh 的隐藏目录，内含两个密钥文件。id_rsa 为私钥，id_rsa.pub 为公钥。</p>
<h3><span id="2-在服务器上安装公钥">2. 在服务器上安装公钥</span><a href="#2-在服务器上安装公钥" class="header-anchor"> </a></h3>
<p>键入以下命令，在服务器上安装公钥：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@host ~]$ cd .ssh</span><br><span class="line">[root@host .ssh]$ cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure>
<p>如此便完成了公钥的安装。为了确保连接成功，请保证以下文件权限正确：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@host .ssh]$ chmod 600 authorized_keys</span><br><span class="line">[root@host .ssh]$ chmod 700 ~/.ssh</span><br></pre></td></tr></table></figure>
<h3><span id="3-设置-ssh打开密钥登录功能">3. 设置 SSH，打开密钥登录功能</span><a href="#3-设置-ssh打开密钥登录功能" class="header-anchor"> </a></h3>
<p>编辑 /etc/ssh/sshd_config 文件，进行如下设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br></pre></td></tr></table></figure>
<p>另外，请留意 root 用户能否通过 SSH 登录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure>
<p>当你完成全部设置，并以密钥方式登录成功后，再禁用密码登录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PasswordAuthentication no</span><br></pre></td></tr></table></figure>
<p>最后，重启 SSH 服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@host .ssh]$ service sshd restart</span><br></pre></td></tr></table></figure>
<h3><span id="4-将私钥下载到客户端然后转换为-putty-能使用的格式">4. 将私钥下载到客户端，然后转换为 PuTTY 能使用的格式</span><a href="#4-将私钥下载到客户端然后转换为-putty-能使用的格式" class="header-anchor"> </a></h3>
<p>使用 WinSCP、SFTP 等工具将私钥文件 id_rsa 下载到客户端机器上。然后打开 PuTTYGen，单击 Actions 中的 Load 按钮，载入你刚才下载到的私钥文件。如果你刚才设置了密钥锁码，这时则需要输入。</p>
<p>载入成功后，PuTTYGen 会显示密钥相关的信息。在 Key comment 中键入对密钥的说明信息，然后单击 Save private key 按钮即可将私钥文件存放为 PuTTY 能使用的格式。</p>
<p>今后，当你使用 PuTTY 登录时，可以在左侧的 Connection -&gt; SSH -&gt; Auth 中的 Private key file for authentication: 处选择你的私钥文件，然后即可登录了，过程中只需输入密钥锁码即可。</p>
<h2><span id="iptables配置">iptables配置</span><a href="#iptables配置" class="header-anchor"> </a></h2>
<p>来源<a href="https://wsgzao.github.io/post/iptables/" target="_blank" rel="noopener">iptables配置实践</a></p>
<h3><span id="前言">前言</span><a href="#前言" class="header-anchor"> </a></h3>
<p>在大企业中防火墙角色主要交给硬件来支持，效果自然没话说只是需要增加一点点成本，但对于大多数个人或者互联网公司来说选择系统自带的<code>iptables</code>或者第三方云防火墙似乎是更加合适的选择，通过一些合理的优化和灵活的配置，我们也可以很轻松实现硬件防火墙的部分功能，够用就好。</p>
<blockquote>
<p>建立防火墙白名单机制很重要</p>
</blockquote>
<h3><span id="基础知识">基础知识</span><a href="#基础知识" class="header-anchor"> </a></h3>
<h4><span id="关闭iptables">关闭iptables</span><a href="#关闭iptables" class="header-anchor"> </a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/init.d/iptables stop</span><br><span class="line">chkconfig iptables off</span><br></pre></td></tr></table></figure>
<h4><span id="基础语法">基础语法</span><a href="#基础语法" class="header-anchor"> </a></h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#规则的观察与清除</span><br><span class="line"></span><br><span class="line">     iptables [-t tables] [-L] [-nv]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">-t ：后面接 table ，例如 nat 或 filter ，若省略此项目，则使用默认的 filter</span><br><span class="line">-L ：列出目前的 table 的规则</span><br><span class="line">-n ：不进行 IP 与 HOSTNAME 的反查，显示讯息的速度会快很多！</span><br><span class="line">-v ：列出更多的信息，包括通过该规则的封包总位数、相关的网络接口等</span><br><span class="line"></span><br><span class="line">     iptables [-t tables] [-FXZ]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">-F ：清除所有的已订定的规则；</span><br><span class="line">-X ：杀掉所有使用者 &quot;自定义&quot; 的 chain (应该说的是 tables ）啰；</span><br><span class="line">-Z ：将所有的 chain 的计数与流量统计都归零</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#封包的基础比对：IP, 网域及接口装置</span><br><span class="line"></span><br><span class="line">    iptables [-AI 链名] [-io 网络接口] [-p 协议] [-s 来源IP/网域] [-d 目标IP/网域] -j [ACCEPT|DROP|REJECT|LOG]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">-AI 链名：针对某的链进行规则的 &quot;插入&quot; 或 &quot;累加&quot;</span><br><span class="line">    -A ：新增加一条规则，该规则增加在原本规则的最后面。例如原本已经有四条规则，</span><br><span class="line">         使用 -A 就可以加上第五条规则！</span><br><span class="line">    -I ：插入一条规则。如果没有指定此规则的顺序，默认是插入变成第一条规则。</span><br><span class="line">         例如原本有四条规则，使用 -I 则该规则变成第一条，而原本四条变成 2~5 号</span><br><span class="line">    链 ：有 INPUT, OUTPUT, FORWARD 等，此链名称又与 -io 有关，请看底下。</span><br><span class="line"></span><br><span class="line">-io 网络接口：设定封包进出的接口规范</span><br><span class="line">    -i ：封包所进入的那个网络接口，例如 eth0, lo 等接口。需与 INPUT 链配合；</span><br><span class="line">    -o ：封包所传出的那个网络接口，需与 OUTPUT 链配合；</span><br><span class="line"></span><br><span class="line">-p 协定：设定此规则适用于哪种封包格式</span><br><span class="line">   主要的封包格式有： tcp, udp, icmp 及 all 。</span><br><span class="line"></span><br><span class="line">-s 来源 IP/网域：设定此规则之封包的来源项目，可指定单纯的 IP 或包括网域，例如：</span><br><span class="line">   IP  ：192.168.0.100</span><br><span class="line">   网域：192.168.0.0/24, 192.168.0.0/255.255.255.0 均可。</span><br><span class="line">   若规范为『不许』时，则加上 ! 即可，例如：</span><br><span class="line">   -s ! 192.168.100.0/24 表示不许 192.168.100.0/24 之封包来源；</span><br><span class="line"></span><br><span class="line">-d 目标 IP/网域：同 -s ，只不过这里指的是目标的 IP 或网域。</span><br><span class="line"></span><br><span class="line">-j ：后面接动作，主要的动作有接受(ACCEPT)、丢弃(DROP)、拒绝(REJECT)及记录(LOG)</span><br><span class="line"></span><br><span class="line">#TCP, UDP 的规则比对：针对端口设定</span><br><span class="line"></span><br><span class="line">    iptables [-AI 链] [-io 网络接口] [-p tcp,udp] [-s 来源IP/网域] [--sport 埠口范围] [-d 目标IP/网域] [--dport 端口范围] -j [ACCEPT|DROP|REJECT]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">--sport 埠口范围：限制来源的端口号码，端口号码可以是连续的，例如 1024:65535</span><br><span class="line">--dport 埠口范围：限制目标的端口号码。</span><br><span class="line"></span><br><span class="line">#iptables 外挂模块：mac 与 state</span><br><span class="line"></span><br><span class="line">    iptables -A INPUT [-m state] [--state 状态]</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">-m ：一些 iptables 的外挂模块，主要常见的有：</span><br><span class="line">     state ：状态模块</span><br><span class="line">     mac   ：网络卡硬件地址 (hardware address)</span><br><span class="line">--state ：一些封包的状态，主要有：</span><br><span class="line">     INVALID    ：无效的封包，例如数据破损的封包状态</span><br><span class="line">     ESTABLISHED：已经联机成功的联机状态；</span><br><span class="line">     NEW        ：想要新建立联机的封包状态；</span><br><span class="line">     RELATED    ：这个最常用！表示这个封包是与我们主机发送出去的封包有关</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ICMP 封包规则的比对：针对是否响应 ping 来设计</span><br><span class="line"></span><br><span class="line">    iptables -A INPUT [-p icmp] [--icmp-type 类型] -j ACCEPT</span><br><span class="line"></span><br><span class="line">选项与参数：</span><br><span class="line">--icmp-type ：后面必须要接 ICMP 的封包类型，也可以使用代号，</span><br><span class="line">              例如 8  代表 echo request 的意思。</span><br></pre></td></tr></table></figure>
<h3><span id="配置iptables白名单机制">配置iptables白名单机制</span><a href="#配置iptables白名单机制" class="header-anchor"> </a></h3>
<blockquote>
<p>配置iptables白名单是相对简单有效的管理手段</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#清除所有规则(慎用)</span><br><span class="line">iptables -F</span><br><span class="line">iptables -X</span><br><span class="line">iptables -Z</span><br><span class="line"></span><br><span class="line">#查看iptable和行号</span><br><span class="line">iptables -nL --line-number</span><br><span class="line"></span><br><span class="line">#保存当前防火墙配置</span><br><span class="line">service iptables save</span><br><span class="line"></span><br><span class="line">#手动编辑防火墙策略</span><br><span class="line">vi /etc/sysconfig/iptables</span><br><span class="line"></span><br><span class="line"># Generated by iptables-save v1.4.7 on Fri Jul 24 09:42:09 2015</span><br><span class="line">*filter</span><br><span class="line">:INPUT ACCEPT [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line">#开放本地和Ping</span><br><span class="line">-A INPUT -i lo -j ACCEPT  </span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -j ACCEPT</span><br><span class="line">#配置内网白名单</span><br><span class="line">-A INPUT -s 10.0.0.0/8 -j ACCEPT</span><br><span class="line">-A INPUT -s 172.16.0.0/12 -j ACCEPT</span><br><span class="line">-A INPUT -s 192.168.0.0/16 -j ACCEPT</span><br><span class="line">#配置外网白名单</span><br><span class="line">-A INPUT -s 180.168.36.198 -j ACCEPT</span><br><span class="line">-A INPUT -s 180.168.34.218 -j ACCEPT</span><br><span class="line">-A INPUT -s 222.73.202.251 -j ACCEPT</span><br><span class="line">#控制端口</span><br><span class="line">-A INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line">#拒绝其它</span><br><span class="line">-A INPUT -j DROP</span><br><span class="line">-A FORWARD -j DROP</span><br><span class="line">#开放出口</span><br><span class="line">-A OUTPUT -j ACCEPT</span><br><span class="line">COMMIT</span><br><span class="line"># Completed on Fri Jul 24 09:40:16 2015</span><br><span class="line"></span><br><span class="line">#重启生效</span><br><span class="line">service iptables restart</span><br><span class="line"></span><br><span class="line">#复查结果</span><br><span class="line"></span><br><span class="line">iptables -nL --line-number</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">num  target     prot opt source               destination         </span><br><span class="line">1    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">2    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           state RELATED,ESTABLISHED</span><br><span class="line">3    ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line">4    ACCEPT     all  --  10.0.0.0/8           0.0.0.0/0           </span><br><span class="line">5    ACCEPT     all  --  172.16.0.0/12        0.0.0.0/0           </span><br><span class="line">6    ACCEPT     all  --  192.168.0.0/16       0.0.0.0/0           </span><br><span class="line">7    ACCEPT     all  --  180.168.36.198       0.0.0.0/0           </span><br><span class="line">8    ACCEPT     all  --  180.168.34.218       0.0.0.0/0           </span><br><span class="line">9    ACCEPT     all  --  222.73.202.251       0.0.0.0/0           </span><br><span class="line">10   ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:80</span><br><span class="line">11   ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:22</span><br><span class="line">12   DROP       all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">num  target     prot opt source               destination         </span><br><span class="line">1    DROP       all  --  0.0.0.0/0            0.0.0.0/0           </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">num  target     prot opt source               destination         </span><br><span class="line">1    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0</span><br></pre></td></tr></table></figure>
<h3><span id="设置crontab脚本">设置crontab脚本</span><a href="#设置crontab脚本" class="header-anchor"> </a></h3>
<blockquote>
<p>便于运维集中化管理扩展</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /root/start_iptables.sh</span><br><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">#0 0 * * * /root/start_iptables.sh</span><br><span class="line"></span><br><span class="line">#清除配置</span><br><span class="line">/sbin/iptables -P INPUT ACCEPT</span><br><span class="line">/sbin/iptables -F</span><br><span class="line">/sbin/iptables -X</span><br><span class="line">#开放本地和Ping</span><br><span class="line">/sbin/iptables -A INPUT -i lo -j ACCEPT  </span><br><span class="line">/sbin/iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">/sbin/iptables -A INPUT -p icmp -j ACCEPT</span><br><span class="line">#配置内网白名单</span><br><span class="line">/sbin/iptables -A INPUT -s 10.0.0.0/8 -j ACCEPT</span><br><span class="line">/sbin/iptables -A INPUT -s 172.16.0.0/12 -j ACCEPT</span><br><span class="line">/sbin/iptables -A INPUT -s 192.168.0.0/16 -j ACCEPT</span><br><span class="line">#配置外网白名单</span><br><span class="line">/sbin/iptables -A INPUT -s 180.168.36.198 -j ACCEPT</span><br><span class="line">/sbin/iptables -A INPUT -s 180.168.34.218 -j ACCEPT</span><br><span class="line">/sbin/iptables -A INPUT -s 222.73.202.251 -j ACCEPT</span><br><span class="line">#控制端口</span><br><span class="line">/sbin/iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line">/sbin/iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line">#拒绝其它</span><br><span class="line">/sbin/iptables -A INPUT -j DROP</span><br><span class="line">/sbin/iptables -A FORWARD -j DROP</span><br><span class="line">#开放出口</span><br><span class="line">/sbin/iptables -A OUTPUT -j ACCEPT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chmod 755 /root/start_iptables.sh</span><br><span class="line">crontab -e</span><br><span class="line">0 0 * * * /root/start_iptables.sh</span><br></pre></td></tr></table></figure>
<h3><span id="我的iptables脚本">我的iptables脚本</span><a href="#我的iptables脚本" class="header-anchor"> </a></h3>
<blockquote>
<p>附上我目前在用的服务器iptables脚本 <a href="http://ipt.sh" target="_blank" rel="noopener">ipt.sh</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/sbin/iptables -F</span><br><span class="line">/sbin/iptables -X</span><br><span class="line">/sbin/iptables -F -t mangle</span><br><span class="line">/sbin/iptables -t mangle -X</span><br><span class="line">/sbin/iptables -F -t nat</span><br><span class="line">/sbin/iptables -t nat -X</span><br><span class="line"></span><br><span class="line">/sbin/iptables -P INPUT DROP</span><br><span class="line">/sbin/iptables -P OUTPUT ACCEPT</span><br><span class="line">/sbin/iptables -P FORWARD DROP</span><br><span class="line"></span><br><span class="line">#/sbin/iptables -A INPUT -p icmp --icmp-type 8 -s 0/0 -j DROP</span><br><span class="line">/sbin/iptables -I INPUT -p icmp --icmp-type echo-request -m limit --limit 6/min --limit-burst 4 -j ACCEPT</span><br><span class="line">/sbin/iptables -A INPUT -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP</span><br><span class="line">/sbin/iptables -A INPUT -p tcp --tcp-flags ALL ALL -j DROP</span><br><span class="line">/sbin/iptables -A INPUT -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP</span><br><span class="line">/sbin/iptables -A INPUT -p tcp --tcp-flags ALL NONE -j DROP</span><br><span class="line">/sbin/iptables -A INPUT -p tcp --tcp-flags SYN,RST SYN,RST -j DROP</span><br><span class="line">/sbin/iptables -A INPUT -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP</span><br><span class="line"></span><br><span class="line">/sbin/iptables -A INPUT -p tcp --dport 22 -j ACCEPT</span><br><span class="line">/sbin/iptables -A INPUT -p tcp --dport 80 -j ACCEPT</span><br><span class="line">/sbin/iptables -A INPUT -p tcp --dport 3333 -j ACCEPT</span><br><span class="line">#/sbin/iptables -A INPUT -p tcp --dport 443 -j ACCEPT</span><br><span class="line">#/sbin/iptables -A INPUT -p tcp --dport 4000 -j ACCEPT</span><br><span class="line">#/sbin/iptables -A INPUT -p tcp --dport 8080 -j ACCEPT</span><br><span class="line">#/sbin/iptables -A INPUT -p tcp --dport 3306 -j ACCEPT</span><br><span class="line">#/sbin/iptables -A INPUT -p icmp -j ACCEPT</span><br><span class="line">/sbin/iptables -A INPUT -d 127.0.0.1 -j ACCEPT</span><br><span class="line">/sbin/iptables -A INPUT -i lo -p all -j ACCEPT</span><br><span class="line">/sbin/iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">#/sbin/iptables -A INPUT -p udp --sport 53 -j ACCEPT</span><br><span class="line"></span><br><span class="line">/sbin/iptables -A OUTPUT -p tcp --sport 31337 -j DROP</span><br><span class="line">/sbin/iptables -A OUTPUT -p tcp --dport 31337 -j DROP</span><br><span class="line"></span><br><span class="line">/sbin/iptables -A INPUT -m state --state INVALID -j DROP</span><br><span class="line">/sbin/iptables -A OUTPUT -m state --state INVALID -j DROP</span><br><span class="line">/sbin/iptables -A FORWARD -m state --state INVALID -j DROP</span><br></pre></td></tr></table></figure>
<h3><span id="扩展阅读">扩展阅读</span><a href="#扩展阅读" class="header-anchor"> </a></h3>
<p>Linux 防火墙和 iptables - <a href="http://liaoph.com/iptables/" target="_blank" rel="noopener">http://liaoph.com/iptables/</a></p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>security</tag>
        <tag>ssh</tag>
        <tag>密码</tag>
      </tags>
  </entry>
  <entry>
    <title>Complex Network Clustering by Multiobjective Discrete Particle Swarm Optimization Based on Decomposition</title>
    <url>/2016/10/29/MODPSO/</url>
    <content><![CDATA[<h2><span id="简介">简介</span><a href="#简介" class="header-anchor"> </a></h2>
<h3><span id="复杂网络聚类">复杂网络聚类</span><a href="#复杂网络聚类" class="header-anchor"> </a></h3>
<p>各种各样的网络如合作者网络、万维网、神经网络，都可以被建模成复杂网络。网络聚类的任务就是将复杂网络划分成不同<strong>部分</strong>，这些<strong>部分</strong>我们把它称作<strong>社区</strong>。在非符号网络中，同一个社区内的节点比较稠密且互相紧密连接，在不同社区间的节点则连接较少。对于符号网络而言，无论是社区内部还是社区之间他们的连接都非常紧密。网络聚类有助于我们发现网络的组织结构和其功能。近些年来，大量的网络聚类方法被提出。</p>
<a id="more"></a>
<p>网络聚类可以被建模成优化问题，这里问题大部分都属于NP难问题。正因为这个原因，进化算法常用来解决这个问题，比如说<a href="http://link.springer.com/chapter/10.1007%2F978-3-540-87700-4_107" target="_blank" rel="noopener">GA-net</a>，<a href="http://europepmc.org/abstract/med/22181467" target="_blank" rel="noopener">Meme-net</a>。在某些应用中，我们同时考虑一些相互矛盾的因素，因此把它当成多目标优化问题，比如说<a href="http://ieeexplore.ieee.org/document/6045331/?arnumber=6045331" target="_blank" rel="noopener">MOGA-net</a>，<a href="http://dl.acm.org/citation.cfm?id=2088775" target="_blank" rel="noopener">MOCD</a>，<a href="http://www.sciencedirect.com/science/article/pii/S0378437112002579" target="_blank" rel="noopener">MOEA/D-net</a>。</p>
<h3><span id="多目标进化算法及粒子群算法">多目标进化算法及粒子群算法</span><a href="#多目标进化算法及粒子群算法" class="header-anchor"> </a></h3>
<p>多目标进化算法(MOEAs)的目标是从多目标优化问题中的到一组帕累托最优解集(Pareto optimal solutions)，目前MOEAs可以大致分为三类，第一类是基于帕累托占优(Pareto dominance)比较著名的算法有NSGA-Ⅱ，SPEA2，PAES,AMOSA,第二类是基于绩效指标，第三类是基于分解，这些多目标优化的分解算法(MOP)转化为一系列单目标的子问题或者一些简单的多目标子问题，我们采用群体搜索的方法来解决这些子问题。<br>
粒子群优化算法(PSO),最初是解决单目标优化方法的，详细介绍可参考我之前的文章<a href="http://tianle.me/2016/05/29/pso%20algorithm/">【计算智能】目标优化智能算法之粒子群算法</a>。</p>
<h3><span id="本文的贡献">本文的贡献</span><a href="#本文的贡献" class="header-anchor"> </a></h3>
<ol>
<li>根据复杂网络聚类问题，和传统的粒子群算法框架，我们重新定义了粒子的位置及速度更新策略。同时我们还重新定义了他们的运算操作，还介绍了特定问题的粒子群的初始化方法以及它们的扰动策略。</li>
<li>第一次将多目标优化问题的离散粒子群方法(MODPSO)应用到复杂网络聚类问题中。</li>
<li>提出了新的目标函数，通过大量的实验证实了该方法用于符号网络及非符号网络的有效性。</li>
</ol>
<h2><span id="问题描述及动机">问题描述及动机</span><a href="#问题描述及动机" class="header-anchor"> </a></h2>
<h3><span id="网络社区定义">网络社区定义</span><a href="#网络社区定义" class="header-anchor"> </a></h3>
<p>一个网络中同时具有积极连接和消极连接被称为 <strong>符号网络(signed network)</strong> ， <strong>非符号网络(unsigned network)</strong> 可以看成一个特殊的符号网络，它们只有积极连接。<br>
定义一个非符号网络G=(V,E)，其中V表示节点，E表示边。特别的${k_i}$表示节点i的度，${A_{ij} = 1}$表示节点i和j直接连接，反之${A_{ij} = 0}$。给定$S \subset G$，其中节点i属于其中，$k_i^{in} = \sum\nolimits_{i,j \in S} {{A_{ij}}} $,$k_i^{out} = \sum\nolimits_{i,j \notin S} {{A_{ij}}} $使得${A_{ij}}$为内在的或者外在的节点的度，如果S为强感知(strong sense)，则有$$\forall i \in S,{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} k_i^{in} > k_i^{out}$$，如果S为弱感知(weak sense)，则$$\sum\limits_{i \in S} {k_i^{in}}  > \sum\limits_{i \in S} {k_i^{out}} $$<br>
对于符号网络，G=(V,PE,NE)，PE和NE分别为积极连接和消极连接。令A为权重邻接矩阵， ${A_{ij} = 1}$,if ${e_{ij}} \in PE$；${A_{ij} = -1}$,if ${e_{ij}} \in NE$；${A_{ij} = 0}$,if$\nexists {e_{ij}}$。给定$S \subset G$，其中节点i属于其中${(k_i^ + )^{in}} = \sum\nolimits_{j \in S,{e_{ij}} \in PE} {\left| {{A_{ij}}} \right|} $和${(k_i^ - )^{in}} = \sum\nolimits_{j \in S,{e_{ij}} \in NE} {\left| {{A_{ij}}} \right|} $分别为积极和消极的内在节点i的度数，特别的S为强感知如果满足</p>
$$\forall i \in S,{\kern 1pt} {\kern 1pt} {(k_i^ + )^{in}} > {\kern 1pt} {(k_i^ - )^{in}}$$  
<p>另外<br>
<img src="//img.tianle.me/image/20161029/block1.jpg" alt></p>
$$\left\{ \begin{array}{l}\sum\nolimits_{i \in S} {{{(k_i^ + )}^{in}}}  > \sum\nolimits_{i \in S} {{{(k_i^ + )}^{out}}} \\\sum\nolimits_{i \in S} {{{(k_i^ - )}^{out}}}  > \sum\nolimits_{i \in S} {{{(k_i^ - )}^{in}}} \end{array} \right.$$  
<p>由此可以看出，在强感知的情况下，在社区中一个节点拥有比消极连接更多的积极连接。在弱感知的情况下，在一个社区中积极连接非常稠密，同时在不同的社区直接它们的消极连接也非常稠密。</p>
<h3><span id="网络聚类问题">网络聚类问题</span><a href="#网络聚类问题" class="header-anchor"> </a></h3>
<p>网络聚类问题可以被描述为一个优化问题，Girvan 和 Newman 提出了模块度函数（Q函数）$$Q = \frac{1}{{2m}}\sum\limits_{i,j} {({A_{ij}} - {k_i}{k_j}/2m)\delta (i,j)} $$其中m表示边数，${A_{ij}}$表示网络的邻接矩阵中的元素，${k_i}$表示节点i的度数，$\delta (i,j) = 1$表示节点i和节点j属于同一个社区，否则其为0。<br>
Q函数适用于非符号网络，对于符号网络G´omez提出了SQ函数</p>
$$SQ = \frac{1}{{2{\omega ^ + } + 2{\omega ^ - }}}\sum\limits_{i,j} {({\omega _{ij}} - (\frac{{\omega _i^ + \omega _j^ + }}{{2{\omega ^ + }}} - \frac{{\omega _i^ - \omega _j^ - }}{{2{\omega ^ - }}}))\delta (i,j)} $$  
<p>其中${\omega _{ij}}$为邻接矩阵的权重，$\omega _i^ + (\omega _i^ - )$表示所有的积极（消极）权重之和。<br>
但是Fortunato 和 Barthlemy指出模块度函数的局限性，而且符号网络的模型也同样存在。</p>
<p>……</p>
<p>在先前的工作中，对于非符号网络，我们将其看成一个多目标优化问题，其包括两个目标函数NRA和RC让他们达到最小，同时解决了模块度函数的限制。给定一个非符号网络G=(V,E)，|V|=n 节点数，|E|=m边数，A为邻接矩阵。令k为划分社区的个数,Ω={c1,c2,c3,…,ck}，${V_1},{V_2} \in \Omega $，我们定义$L({V_1},{V_2}) = \sum\nolimits_{i \in {V_1},j \in {V_2}} {{A_{ij}}}$<br>
,$L({V_1},\overline {{V_2}} ) = \sum\nolimits_{i \in {V_1},j \in \overline {{V_2}} } {{A_{ij}}}$，其中$\overline   = \Omega  - {V_2}$，优化问题可以被定义为$$\min  = \left\{ \begin{array}{l}NRA =  - \sum\nolimits_{i = 1}^k {\frac{{L({V_i},{V_i})}}{{\left| {{V_i}} \right|}}} \\RC = \sum\nolimits_{i = 1}^k {\frac{{L({V_i},\overline {{V_i}} )}}{{\left| {{V_i}} \right|}}} \end{array} \right.$$<br>
在本篇文章中，我们将NRA替换成了kernel k-means(KKM)，对于非符号网络聚类问题可以描述为$$\min  = \left\{ \begin{array}{l}KKM = 2(n - k) - \sum\nolimits_{i = 1}^k {\frac{{L({V_i},{V_i})}}{{\left| {{V_i}} \right|}}} \\RC = \sum\nolimits_{i = 1}^k {\frac{{L({V_i},\overline {{V_i}} )}}{{\left| {{V_i}} \right|}}} \end{array} \right.$$<br>
对于符号网络聚类问题，有一些区别，我们对KKM和RC做了一些简单的修改</p>
$$\min  = \left\{ \begin{array}{l}SRA =  - \sum\nolimits_{i = 1}^k {\frac{{{L^ + }({V_i},{V_i}) - {L^ - }({V_i},{V_i})}}{{\left| {{V_i}} \right|}}} \\RC = \sum\nolimits_{i = 1}^k {\frac{{{L^ + }({V_i},\overline {{V_i}} ) - {L^ - }({V_i},\overline {{V_i}} )}}{{\left| {{V_i}} \right|}}} \end{array} \right.$$  
<p>其中${L^ + }({V_i},{V_j}) = \sum\nolimits_{i \in {V_i},j \in Vj} {{A_{ij}}} $,${A_{ij}} > 0$</p>
${L^ - }({V_i},{V_j}) = \sum\nolimits_{i \in {V_i},j \in Vj} {\left| {{A_{ij}}} \right|} $,${A_{ij}} < 0$  
<h3><span id="我们的动机">我们的动机</span><a href="#我们的动机" class="header-anchor"> </a></h3>
<p>……</p>
<h2><span id="算法框架">算法框架</span><a href="#算法框架" class="header-anchor"> </a></h2>
<h3><span id="粒子状态定义">粒子状态定义</span><a href="#粒子状态定义" class="header-anchor"> </a></h3>
<p>为了更好的解决复杂网络聚类问题，在本文中，我们重新定义了PSO算法在离散中的情况。</p>
<ol>
<li>
<p>位置<br>
对某个粒子i，${X_i} = \{ {x_1},{x_2}, \cdots ,{x_n}\} $。粒子位置的每一个维度是从1到n的随机数，例：${x_i} \in [1,n]$，其中n为网络中所有节点的个数，如果${x_i} = {x_j}$那么我们认为节点i和j属于同一个集合<br>
<img src="//img.tianle.me/image/20161029/g1.jpg" alt></p>
</li>
<li>
<p>速度</p>
</li>
</ol>
${V_i} = \{ {v_1},{v_2}, \cdots ,{v_n}\}$，其中${v_i}$是二进制编码，如果${v_i}=1$那么对应的元素${x_i}$将会改变位置，否则不动  
<h3><span id="粒子状态更新">粒子状态更新</span><a href="#粒子状态更新" class="header-anchor"> </a></h3>
<p>在我们提出的DPSO框架中，速度决定了粒子移动的方向与距离。在速度更新之后，粒子将会使用该速度来更新自己的位置。在该问题中，无论是速度还是位置都是整形向量，传统的粒子更新策略将不再适用。因此我们重新定义了适合网络聚类问题的更新策略。首先我们重新定义粒子的速度更新策略<br>
$${V_i} = sig(\omega {V_i} + {c_1}{r_1}({X_i} \oplus Pbes{t_i}) + {c_2}{r_2}({X_i} \oplus Gbest))$$式（10）</p>
<p>其中，ω为惯性权重，c1、c2是非负的常数，称为学习因子，r1、r1是分布于[0,1]的随机数。<br>
$\oplus$为异或操作，Y=sig(X)，其中Y=(y1 ,y2 , … , yn), X=(x1 ,x2 , … , xn)被定义为：</p>
$$\left\{ \begin{array}{l}{y_i} = 1{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} if{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} rand(0,1) < sigmoid({x_i})\\{y_i} = 0{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} if{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} rand(0,1) \ge sigmoid({x_i})\end{array} \right.$$
<p>其中sigmoid函数为：</p>
$$sigmoid(x) = \frac{1}{{1 + {e^{ - x}}}}$$
<p>在该算法中，ω随机产生[0,1]，c1和c2设置为经典值1.494<br>
基于刚刚新定义的粒子速度更新策略，我们重新定义粒子的位置更新策略<br>
$${x_i}^t = {x_i}^t \otimes {v_i}^t$$ 式（13）</p>
<p>$\otimes$在粒子状态更新中是一个关键操作。它直接影响了粒子的飞行方向，一个良好的$\otimes$操作可以引导粒子飞向好的位置，避开差的状态。<br>
给定一个位置${X_1} = \{ {x_{11}},{x_{12}},...,{x_{1k}}\} $和速度$V = \{ {v_1},{v_2},...,{v_n}\}$，位置$\otimes$速度得到一个新的状态，例：${X_1} \otimes V = {X_2}$,${X_2} = \{ {x_{21}},{x_{22}},...,{x_{2n}}\} $，其中${X_2}$被定义为：</p>
$$\left\{ \begin{array}{l}{x_{2i}} = {x_{1i}}{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} if{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {v_i} = 0\\{x_{2i}} = Nbes{t_i}{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} if{\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {\kern 1pt} {v_i} = 1\end{array} \right.$$  
<p>其中$Nbes{t_i}$是一个整数，假设节点i的邻居为$N = { {n_1},{n_2}, \cdots ,{n_k}}$，$Nbes{t_i}$可由以下公式得出<br>
$$Nbes{t_i} = \arg {\kern 1pt} {\kern 1pt} {\kern 1pt} \mathop {\max }\limits_r \sum\limits_{j \in N} {\varphi ({x_{1j}},r)}$$<br>
其中如果i = j，则$\varphi (i,j) = 1$，否则为0，函数$\arg {\max _r}f(x)$返回当f(x)取得最大值时的r。可以看出$Nbes{t_i}$为节点i的邻居节点集合的主要标签。这可以在现实生活中很好的理解，因为对于一个人而言，他更愿意加入他朋友最多的社区中。<br>
在图二中，$X_i$和$Nbes{t_i}$是粒子i的当前位置和个体极值。Gbest是粒子群的群体最优。$V_1$，$V_2$，$V_3$，$V_4$，$V_5$，是中间变量。$V_6$和$X_j$，由式（10）和式（13）计算得到。<br>
<img src="//img.tianle.me/image/20161029/g2.jpg" alt><br>
根据上述介绍，我们可以看出，我们提出的DPSO框架具有以下几个特性</p>
<ol>
<li>粒子的位置和速度更新策略非常简单</li>
<li>新定义的操作非常容易实现，能够减少计算复杂度</li>
<li>DPSO框架不需要事先了解网络结构，能够自动进行决策</li>
</ol>
<h3><span id="粒子初始化">粒子初始化</span><a href="#粒子初始化" class="header-anchor"> </a></h3>
<p>一个优秀的初始化方法能够减少搜索空间来减少算法达到最优解的时间同时还可以保证解的多样性。传统的随机生成初始化的方法会导致大量的冗余。在本篇文中，我们采用了先前工作中提出的 <a href="http://ieeexplore.ieee.org/document/6252971/?arnumber=6252971" target="_blank" rel="noopener">lable propagation-based initialization方法</a><br>
假定节点i的邻居节点集为$\Omega (i) = ({x_1},{x_2}, \cdots ,{x_k})$，用l(i)来表示节点i属于的社区标记，首先我们将各个节点分别设置为各不相同的标记，如：l(i)=i，接下来每一个节点的社区标记依赖它的邻居节点，我们让它们的节点标记通过网络进行传播。我们假设网络中的每个节点选择加入其邻居的最大数量所属的社区。</p>
$$l(i) = \arg {\kern 1pt} {\max _r}\sum\nolimits_{j \in \Omega (i)} {\delta (l(j),r)} $$  
<p>其中如果i = j，则$\delta (i,j) = 1$，否则为0。我们迭代地执行这个过程，其中在每个步骤，每个节点基于其邻居的标签来更新其标签。 当传播迭代达到五个，并且如果我们将所有的团体标签形成为染色体，则所创建的候选个体具有高聚类精度，此外，我们可以获得相当多样的种群 。<br>
算法的伪代码如下：<br>
<img src="//img.tianle.me/image/20161029/oa2.jpg" alt></p>
<h3><span id="领袖选择">领袖选择</span><a href="#领袖选择" class="header-anchor"> </a></h3>
<p>在本文中采用随机的策略来选择gbest，因为它既能够带来种群的多样性，又能够减少时间复杂度。对于一个粒子，有ns个相应的邻居（基于聚合权重系数向量之间的欧几里德距离定义）;然后我们从邻居中随机选择一个粒子作为领袖。</p>
<h3><span id="算法框架">算法框架</span><a href="#算法框架" class="header-anchor"> </a></h3>
<p>在所提出的算法中，所采用的分解方法是广泛使用的契比雪夫Tchebycheff方法。</p>
$${g^{te}}(x|\omega ,{z^*}) = \mathop {\max }\limits_{1 \le i \le k} {\kern 1pt} {\omega _i}\left| {{f_i}(x) - z_i^*} \right|$$  
<p>$$subject{\kern 1pt} {\kern 1pt} to{\kern 1pt} {\kern 1pt} x \in \Omega $$<br>
其中${z^*} = (z_1^*,z_2^*,z_3^*, \cdots ,z_k^*)$为参考点，$z_i^* = \{ \min {\kern 1pt} {f_i}(x)|x \in \Omega \} $,i=1,…,k<br>
<img src="//img.tianle.me/image/20161029/a01.jpg" alt>
这个算法框架在上图中给出，其中第3.8步，通过使用帕累托占优的概念来更新pbest，即，如果新生成的解支配pbest解，则用新解来更新它; 如果pbest支配新产生的解，pbest保持其原始状态; 如果它们是相互非支配的，那么我们使用聚合方法来确定是否更新pbest。下面我们给出其算法2<br>
<img src="//img.tianle.me/image/20161029/a2.jpg" alt></p>
<h3><span id="震荡操作turbulence-operator">震荡操作(Turbulence Operator)</span><a href="#震荡操作turbulence-operator" class="header-anchor"> </a></h3>
<p>为了保持多样性并帮助MOPSO逃离局部最优，许多现有的MOPSO采用震荡算子。 对于网络聚类问题，在我们的算法中，采用的震荡算子称为基于邻域的突变（NBM）。 该过程可以描述如下。首先，我们生成在0和1之间的伪随机数; 对于每个染色体中的每个基因，如果随机数小于突变概率pm，则将NBM过程应用于基因，即，将其标签标识符分配给其所有邻居。算法3<br>
<img src="//img.tianle.me/image/20161029/a3.jpg" alt></p>
<h3><span id="复杂性分析">复杂性分析</span><a href="#复杂性分析" class="header-anchor"> </a></h3>
<p>……</p>
<h2><span id="实验分析">实验分析</span><a href="#实验分析" class="header-anchor"> </a></h2>
<h3><span id="比较算法">比较算法</span><a href="#比较算法" class="header-anchor"> </a></h3>
<p>MODPS, MOPSO-r1, MOPSO-r2, GA-net, Meme-net, MOGA-net, MOCD, MODA/D-net, GN, CNM, Informap</p>
<h3><span id="实验设置">实验设置</span><a href="#实验设置" class="header-anchor"> </a></h3>
<p>对于已知网络的真实情况，我们采用归一化互信息（NMI）指数来估计真实聚类结果与检测到的聚类结果之间的相似性。 给定网络的两个分区A和B，令C是混淆矩阵，其元素$C_{ij}$是分区A中的社区i和分区B中的社区j共同共享的节点的数目。</p>
$$NMI = \frac{{ - 2\sum\nolimits_{i = 1}^{{C_A}} {\sum\nolimits_{j = 1}^{{C_B}} {{C_{ij}}\log ({C_{ij}}N/{C_{i.}}{C_{.j}})} } }}{{\sum\nolimits_{i = 1}^{{C_A}} {{C_{i.}}\log ({C_{i.}}/N) + \sum\nolimits_{j = 1}^{{C_B}} {{C_{.j}}\log ({C_{.j}}/N)} } }}$$  
<p>其中${C_A}({C_B})$是分区A(B)中的聚类数目。${C_{i.}}({C_{.j}})$是C中第i行（j列）的元素个数之和，N是网络中节点数，如果A=B则，NMI(A,B)=1,如果A,B完全不同则NMI(A,B)=0</p>
<blockquote>
<p><a href="//img.tianle.me/image/20161029/%E7%A4%BE%E5%8C%BA%E8%81%9A%E7%B1%BBMODPSO.pdf">PPT下载</a></p>
</blockquote>
]]></content>
      <categories>
        <category>研究</category>
      </categories>
      <tags>
        <tag>计算智能</tag>
        <tag>网络</tag>
        <tag>PSO</tag>
        <tag>粒子群</tag>
        <tag>聚类</tag>
        <tag>多目标优化</tag>
      </tags>
  </entry>
  <entry>
    <title>加速npm</title>
    <url>/2016/10/23/speed-up-npm/</url>
    <content><![CDATA[<p>前一段时间由于hexo出了莫名其妙的问题一直无法解决，所以打算重新安装。但是由于GFW的原因，npm的下载速度简直无法忍受，之前买的VPN也不知道什么原因被屏蔽了。在忍无可忍之时，在网上百度到了npm的国内淘宝镜像。</p>
<a id="more"></a>
<h2><span id="taonpm">taonpm</span><a href="#taonpm" class="header-anchor"> </a></h2>
<p>淘宝npm项目地址<a href="http://npm.taobao.org/" title="taonpm" target="_blank" rel="noopener">TAONPM</a></p>
<blockquote>
<p>这是一个完整 <a href="http://npmjs.org" target="_blank" rel="noopener">npmjs.org</a> 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</p>
</blockquote>
<h2><span id="使用说明">使用说明</span><a href="#使用说明" class="header-anchor"> </a></h2>
<p>使用定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<p>安装完毕之后，我们就可以直接使用cnpm来替代原来的npm来进行安装啦~(≧▽≦)/~</p>
<blockquote>
<p>从 <a href="http://registry.npm.taobao.org" target="_blank" rel="noopener">registry.npm.taobao.org</a> 安装所有模块. 当安装的时候发现安装的模块还没有同步过来, 淘宝 NPM 会自动在后台进行同步, 并且会让你从官方 NPM <a href="http://registry.npmjs.org" target="_blank" rel="noopener">registry.npmjs.org</a> 进行安装. 下次你再安装这个模块的时候, 就会直接从 淘宝 NPM 安装了.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cnpm install [name]</span><br></pre></td></tr></table></figure>
<h2><span id="ok-搞定">OK 搞定！</span><a href="#ok-搞定" class="header-anchor"> </a></h2>
<p>还不赶紧试试！</p>
]]></content>
      <categories>
        <category>应用开发</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Big Network Analytics Based on Nonconvex Optimization</title>
    <url>/2016/10/20/Big-Network-Analytics-Based-on-Nonconvex-Optimization/</url>
    <content><![CDATA[<p>这篇文章介绍 <a href="http://link.springer.com/chapter/10.1007%2F978-3-319-30265-2_15" target="_blank" rel="noopener">M. Gong, Q. Cai, L. Ma, and L. Jiao, “Big Network Analytics Based on Nonconvex Optimization,” 2016, pp. 345–373.</a> 论文中的思想。由于刚开始学习，如有错误还请大家多多指正！也希望能和大家多多交流！</p>
<a id="more"></a>
<p>大数据问题可以被看做是一个网络问题。大部分的网络问题可以被建模成非凸优化问题，因此可以采用最优化的方式来解决，其中进化计算是一个有效的解决办法。在本篇文章中，我们着重介绍采用基于非凸优化方法的进化计算来解决社区检测问题。基于单目标和多目标在社区检测的优化问题我们接下来都会进行一个详细分析。一些基于经验且有效的网络分析优化方法也会进行介绍。</p>
<h3><span id="网络问题-特性-符号">网络问题、特性、符号</span><a href="#网络问题-特性-符号" class="header-anchor"> </a></h3>
<p>近些年来，我们发现大数据是一个非常热门的话题。图一表示了网络与网络数据挖掘对网络分析的重要性。网络分析不仅仅能够找出隐藏在网络中的信息还能发现网络中某些重要的属性来控制网络的发展。在图二中，我们列举了12个网络分析中的关键问题。
<img src="//img.tianle.me/image/20161023/1.jpg" alt>
图一
<img src="//img.tianle.me/image/20161023/2.jpg" alt>
图二</p>
<h4><span id="著名的网络属性">著名的网络属性</span><a href="#著名的网络属性" class="header-anchor"> </a></h4>
<p>由于网络的结构常常会影响其功能，因此在分析复杂网络的结构特性中做了大量研究工作。有很多值得注意的网络，如：小世界网络（small-world property）、无标度网络（scale-free network）、群落结构（community structure property）等。<br>
图三展示了一些典型的网络结构。<br>
<img src="//img.tianle.me/image/20161023/3.jpg" alt>
图三: (a) An example of a scale-free network. (b) An example of a small-world network.© An example of a network with two communities.</p>
<p><strong>无标度网络</strong>在于其度分布没有一个特定的平均值指标，即大多数节点的度在此附近。在研究这个网络的度分布时，Barabási等人发现其遵守幂律分布（也称为帕累托分布），也就是说，随机抽取一个节点，它的度d是自然数k的概率：<br>
$P(k) \sim {k^{ - \gamma }}$
也就是说 d=k 的概率正比于 k的某个幂次（一般是负的，记为 $ {-\gamma }$ ）。因此k越大，d=k 的概率就越低。然而这个概率随 k增大而下降的“速度”是比较缓慢的：在一般的随机网络中，下降的速度是指数性的，而在无尺度网络中只是以多项式类的速度下降。<br>
在现实中许多大规模的无尺度网络中，度分布的 $ {\displaystyle \gamma } $值介于2与3之间。在对数坐标系中，度分布将会是一条斜率介于-2至-3之间的直线。<br>
<strong>小世界网络</strong>是一种它们间大部分的点都互不相邻，但是大部分的点通过其他少数的点就可以将他们联系在一起。
网络中的<strong>社区结构</strong>指的是，一个网络可以被划分为多个不同大小的群落，一个网络中具有相似属性的节点大都来源于同一个较大的群落，而不同的群落则来源较少。</p>
<h4><span id="图的符号表示">图的符号表示</span><a href="#图的符号表示" class="header-anchor"> </a></h4>
<p>一般来说图用G={V,E}来进行表示，其中V表示网络中的点，E表示边（点之间的相互关系）。图G可以表示为一个${A_{n \times n}}$的邻接矩阵，其中${a_{ij}}$可表示为<br>
<img src="//img.tianle.me/image/20161023/s2.jpg" alt>
其中<code>L&lt;i,j&gt;</code>表示节点i,j间的相互连接，${\omega _{ij}}$表示<code>L&lt;i,j&gt;</code>的权重。<br>
如果他们有积极关系或者是消极关系，那么他们用分别用PE、和NE来表示<br>
<img src="//img.tianle.me/image/20161023/s3.jpg" alt></p>
<h3><span id="介绍非凸优化问题和计算计算">介绍非凸优化问题和计算计算</span><a href="#介绍非凸优化问题和计算计算" class="header-anchor"> </a></h3>
<h4><span id="什么是优化问题">什么是优化问题</span><a href="#什么是优化问题" class="header-anchor"> </a></h4>
<p>优化问题是一个非常活跃的讨论话题，在数学上可以简单的表示为：<br>
<img src="//img.tianle.me/image/20161023/s4.jpg" alt>式（4）
x被称为决策向量，d是需要优化的参数个数，φ是在决策空间中的可行域，${g_i}(x)$是约束条件。<br>
如果φ是凸集，<code>f(x)</code>可被称为凸函数，其中$\forall {x_1},{x_2} \in \phi ,\forall \alpha  \in [0,1]$<br>
<img src="//img.tianle.me/image/20161023/s5.jpg" alt><br>
特别的，如果f(x)为严格凸函数，则<br>
<img src="//img.tianle.me/image/20161023/s6.jpg" alt><br>
如果f(x)和${g_i}(x)$都是凸函数，那么我们可称为式（4）为凸优化问题。如果是严格凸优化问题，那么其只有一个最小值，且为全局最小值。但如果是非凸的，那么必然存在很多个局部或全局最小值。事实上，许多现实问题都是非凸优化问题。<br>
同时，许多优化问题可以看做是多目标优化，他们超过一个目标函数f(x)需要优化，在数学上，多目标优化问题可以被描述为：<br>
<img src="//img.tianle.me/image/20161023/s7.jpg" alt>
在这个多目标优化问题中，各个目标常常会出现冲突，比如一个目标的改进会导致另一个目标变差。因此得到一个能够使各个目标都达到最优的解是不存在的。在多目标优化中，我们常常做了一个妥协，我们把这类解称为帕累托最优（Pareto optimal solutions)，下面有几个定义：<br>
<strong>定义1 帕累托最优(Pareto Optimality)</strong><br>
<strong>定义2 帕累托占有(Pareto Dominance)</strong><br>
<strong>定义3 帕累托最优集合(Pareto Optimal Set)</strong><br>
<strong>定义4 帕累托前沿(Pareto Front)</strong><br>
<img src="//img.tianle.me/image/20161023/f4.jpg" alt><br>
Figure 4: Graphical illustration of Pareto optimal solution and Pareto front.</p>
<h4><span id="如何解决优化问题">如何解决优化问题</span><a href="#如何解决优化问题" class="header-anchor"> </a></h4>
]]></content>
      <categories>
        <category>研究</category>
      </categories>
      <tags>
        <tag>计算智能</tag>
        <tag>目标优化</tag>
        <tag>算法</tag>
        <tag>network</tag>
        <tag>社区发现</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】深入理解 Spring 事务原理</title>
    <url>/2016/10/09/spring-transaction/</url>
    <content><![CDATA[<h3><span id="一-事务的基本原理">一、事务的基本原理</span><a href="#一-事务的基本原理" class="header-anchor"> </a></h3>
<p>Spring事务的本质其实就是数据库对事务的支持，没有数据库的事务支持，spring是无法提供事务功能的。对于纯JDBC操作数据库，想要用到事务，可以按照以下步骤进行：</p>
<a id="more"></a>
<ol>
<li>获取连接 Connection con = DriverManager.getConnection()</li>
<li>开启事务con.setAutoCommit(true/false);</li>
<li>执行CRUD</li>
<li>提交事务/回滚事务 con.commit() / con.rollback();</li>
<li>关闭连接 conn.close();</li>
</ol>
<p>使用Spring的事务管理功能后，我们可以不再写步骤 2 和 4 的代码，而是由Spirng 自动完成。那么Spring是如何在我们书写的 CRUD 之前和之后开启事务和关闭事务的呢？解决这个问题，也就可以从整体上理解Spring的事务管理实现原理了。下面简单地介绍下，注解方式为例子</p>
<blockquote>
<p>配置文件开启注解驱动，在相关的类和方法上通过注解@Transactional标识。spring 在启动的时候会去解析生成相关的bean，这时候会查看拥有相关注解的类和方法，并且为这些类和方法生成代理，并根据@Transaction的相关参数进行相关配置注入，这样就在代理中为我们把相关的事务处理掉了（开启正常提交事务，异常回滚事务）。真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</p>
</blockquote>
<h3><span id="二-spring-事务的传播属性">二、Spring 事务的传播属性</span><a href="#二-spring-事务的传播属性" class="header-anchor"> </a></h3>
<p>所谓spring事务的传播属性，就是定义在存在多个事务同时存在的时候，spring应该如何处理这些事务的行为。这些属性在TransactionDefinition中定义，具体常量的解释见下表：</p>
<table>
<thead>
<tr>
<th>常量名称</th>
<th>常量解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>PROPAGATION_REQUIRED</td>
<td>支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择，也是 Spring 默认的事务的传播。</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW</td>
<td>新建事务，如果当前存在事务，把当前事务挂起。新建的事务将和被挂起的事务没有任何关系，是两个独立的事务，外层事务失败回滚之后，不能回滚内层事务执行的结果，内层事务失败抛出异常，外层事务捕获，也可以不处理回滚操作</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>支持当前事务，如果当前没有事务，就抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>以非事务方式执行，如果当前存在事务，则抛出异常。</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。</td>
</tr>
</tbody>
</table>
<h3><span id="三-数据库隔离级别">三、数据库隔离级别</span><a href="#三-数据库隔离级别" class="header-anchor"> </a></h3>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>隔离级别的值</th>
<th>导致的问题</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read-Uncommitted</td>
<td>0</td>
<td>导致脏读</td>
</tr>
<tr>
<td>Read-Committed</td>
<td>1</td>
<td>避免脏读，允许不可重复读和幻读</td>
</tr>
<tr>
<td>Repeatable-Read</td>
<td>2</td>
<td>避免脏读，不可重复读，允许幻读</td>
</tr>
<tr>
<td>Serializable</td>
<td>3</td>
<td>串行化读，事务只能一个一个执行，避免了脏读、不可重复读、幻读。执行效率慢，使用时慎重</td>
</tr>
</tbody>
</table>
<p><strong>脏读：</strong> 一事务对数据进行了增删改，但未提交，另一事务可以读取到未提交的数据。如果第一个事务这时候回滚了，那么第二个事务就读到了脏数据。</p>
<p><strong>不可重复读：</strong> 一个事务中发生了两次读操作，第一次读操作和第二次操作之间，另外一个事务对数据进行了修改，这时候两次读取的数据是不一致的。</p>
<p><strong>幻读：</strong> 第一个事务对一定范围的数据进行批量修改，第二个事务在这个范围增加一条数据，这时候第一个事务就会丢失对新增数据的修改。</p>
<h4><span id="总结">总结：</span><a href="#总结" class="header-anchor"> </a></h4>
<p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。<br>
大多数的数据库默认隔离级别为 Read Commited，比如 SqlServer、Oracle<br>
少数数据库默认隔离级别为：Repeatable Read 比如： MySQL InnoDB</p>
<h3><span id="四-spring中的隔离级别">四、Spring中的隔离级别</span><a href="#四-spring中的隔离级别" class="header-anchor"> </a></h3>
<table>
<thead>
<tr>
<th>常量</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>ISOLATION_DEFAULT</td>
<td>这是个 PlatfromTransactionManager 默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与 JDBC 的隔离级别相对应。</td>
</tr>
<tr>
<td>ISOLATION_READ_UNCOMMITTED</td>
<td>这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。</td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td>保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。</td>
</tr>
<tr>
<td>ISOLATION_REPEATABLE_READ</td>
<td>这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。</td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td>这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。</td>
</tr>
</tbody>
</table>
<h3><span id="五-事务的嵌套">五、事务的嵌套</span><a href="#五-事务的嵌套" class="header-anchor"> </a></h3>
<p>通过上面的理论知识的铺垫，我们大致知道了数据库事务和spring事务的一些属性和特点，接下来我们通过分析一些嵌套事务的场景，来深入理解spring事务传播的机制。<br>
假设外层事务<code>Service A</code>的<code>Method A()</code>调用 内层<code>Service B</code>的<code>Method B()</code><br>
<strong>PROPAGATION_REQUIRED(spring 默认)</strong><br>
如果<code>ServiceB.methodB()</code>的事务级别定义为<code>PROPAGATION_REQUIRED</code>，那么执行 <code>ServiceA.methodA()</code> 的时候spring已经起了事务，这时调用<code>ServiceB.methodB()</code>，<code>ServiceB.methodB()</code> 看到自己已经运行在 <code>ServiceA.methodA()</code> 的事务内部，就不再起新的事务。<br>
假如 <code>ServiceB.methodB()</code> 运行的时候发现自己没有在事务中，他就会为自己分配一个事务。<br>
这样，在 <code>ServiceA.methodA()</code> 或者在<code>ServiceB.methodB()</code> 内的任何地方出现异常，事务都会被回滚。<br>
<strong>PROPAGATION_REQUIRES_NEW</strong><br>
比如我们设计 <code>ServiceA.methodA()</code> 的事务级别为<code>PROPAGATION_REQUIRED</code>，<code>ServiceB.methodB()</code> 的事务级别为 <code>PROPAGATION_REQUIRES_NEW</code>。
那么当执行到 <code>ServiceB.methodB()</code> 的时候，<code>ServiceA.methodA()</code> 所在的事务就会挂起，<code>ServiceB.methodB()</code> 会起一个新的事务，等待 <code>ServiceB.methodB()</code> 的事务完成以后，它才继续执行。<br>
他与 <code>PROPAGATION_REQUIRED</code> 的事务区别在于事务的回滚程度了。因为 <code>ServiceB.methodB()</code> 是新起一个事务，那么就是存在两个不同的事务。如果 <code>ServiceB.methodB()</code> 已经提交，那么 <code>ServiceA.methodA()</code> 失败回滚，<code>ServiceB.methodB()</code>是不会回滚的。如果 <code>ServiceB.methodB()</code> 失败回滚，如果他抛出的异常被 <code>ServiceA.methodA()</code> 捕获，<code>ServiceA.methodA()</code> 事务仍然可能提交(主要看<code>B</code>抛出的异常是不是<code>A</code>会回滚的异常)。<br>
<strong>PROPAGATION_SUPPORTS</strong><br>
假设<code>ServiceB.methodB()</code> 的事务级别为 <code>PROPAGATION_SUPPORTS</code>，那么当执行到<code>ServiceB.methodB()</code>时，如果发现<code>ServiceA.methodA()</code>已经开启了一个事务，则加入当前的事务，如果发现<code>ServiceA.methodA()</code>没有开启事务，则自己也不开启事务。这种时候，内部方法的事务性完全依赖于最外层的事务。<br>
<strong>PROPAGATION_NESTED</strong><br>
现在的情况就变得比较复杂了, <code>ServiceB.methodB()</code> 的事务属性被配置为 <code>PROPAGATION_NESTED</code>, 此时两者之间又将如何协作呢? <code>ServiceB#methodB</code> 如果 rollback, 那么内部事务(即 <code>ServiceB#methodB</code>) 将回滚到它执行前的 SavePoint 而外部事务(即 <code>ServiceA#methodA</code>) 可以有以下两种处理方式:<br>
<strong>a、捕获异常，执行异常分支逻辑</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            ServiceB.methodB(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SomeException) &#123; </span><br><span class="line">            <span class="comment">// 执行其他业务, 如 ServiceC.methodC(); </span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这种方式也是嵌套事务最有价值的地方, 它起到了分支执行的效果, 如果 <code>ServiceB.methodB</code> 失败, 那么执行 <code>ServiceC.methodC()</code>, 而 <code>ServiceB.methodB</code> 已经回滚到它执行之前的 SavePoint, 所以不会产生脏数据(相当于此方法从未执行过), 这种特性可以用在某些特殊的业务中, 而 <code>PROPAGATION_REQUIRED</code> 和 <code>PROPAGATION_REQUIRES_NEW</code> 都没有办法做到这一点。<br>
<strong>b、 外部事务回滚/提交</strong><br>
代码不做任何修改, 那么如果内部事务(<code>ServiceB#methodB</code>) rollback, 那么首先 <code>ServiceB.methodB</code> 回滚到它执行之前的 SavePoint(在任何情况下都会如此), 外部事务(即 <code>ServiceA#methodA</code>) 将根据具体的配置决定自己是 commit 还是 rollback<br>
另外三种事务传播属性基本用不到，在此不做分析。</p>
<h3><span id="六-总结">六、总结</span><a href="#六-总结" class="header-anchor"> </a></h3>
<p>对于项目中需要使用到事务的地方，我建议开发者还是使用spring的TransactionCallback接口来实现事务，不要盲目使用spring事务注解，如果一定要使用注解，那么一定要对spring事务的传播机制和隔离级别有个详细的了解，否则很可能发生意想不到的效果。</p>
<p>转载来源：</p>
<blockquote>
<p>本文链接：<a href="http://www.codeceo.com/article/spring-transactions.html" target="_blank" rel="noopener">http://www.codeceo.com/article/spring-transactions.html</a>
本文作者：码农网 – 吴极心</p>
</blockquote>
]]></content>
      <categories>
        <category>应用开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>transaction</tag>
      </tags>
  </entry>
  <entry>
    <title>What are the differences between NP, NP-Complete and NP-Hard?</title>
    <url>/2016/09/17/What-are-the-differences-between-NP-NP-Complete-and-NP-Hard/</url>
    <content><![CDATA[<p><strong>question：</strong> I assume that you are looking for intuitive definitions, since the technical definitions require quite some time to understand. First of all, let’s remember a preliminary needed concept to understand those definitions.</p>
<a id="more"></a>
<ul>
<li><strong>Decision problem</strong>: A problem with a <strong>yes</strong> or <strong>no</strong> answer.</li>
</ul>
<hr>
<p>Now, let us define those complexity classes.</p>
<h2><span id="p">P</span><a href="#p" class="header-anchor"> </a></h2>
<p><em>P is a complexity class that represents the set of all decision problems that can be solved in polynomial time.</em> That is, given an instance of the problem, the answer yes or no can be decided in polynomial time.</p>
<h3><span id="example">Example</span><a href="#example" class="header-anchor"> </a></h3>
<p>Given a graph connected <code>G</code>, can its vertices be coloured using two colours so that no edge is monochromatic?</p>
<p>Algorithm: start with an arbitrary vertex, color it red and all of its neighbours blue and continue. Stop when you run out of vertices or you are forced to make an edge have both of its endpoints be the same color.</p>
<hr>
<h2><span id="np">NP</span><a href="#np" class="header-anchor"> </a></h2>
<p><em>NP is a complexity class that represents the set of all decision problems for which the instances where the answer is “yes” have proofs that can be verified in polynomial time.</em></p>
<p>This means that if someone gives us an instance of the problem and a certificate (sometimes called a witness) to the answer being yes, we can check that it is correct in polynomial time.</p>
<h3><span id="example">Example</span><a href="#example" class="header-anchor"> </a></h3>
<p><em>Integer factorisation</em> is in NP. This is the problem that given integers <code>n</code> and <code>m</code>, is there an integer <code>f</code> with <code>1 &lt; f &lt; m</code>, such that <code>f</code> divides <code>n</code> (<code>f</code> is a small factor of <code>n</code>)?</p>
<p>This is a decision problem because the answers are yes or no. If someone hands us an instance of the problem (so they hand us integers <code>n</code> and <code>m</code>) and an integer <code>f</code> with <code>1 &lt; f &lt; m</code>, and claim that <code>f</code> is a factor of <code>n</code> (the certificate), we can check the answer in polynomial time by performing the division <code>n / f</code>.</p>
<hr>
<h2><span id="np-complete">NP-Complete</span><a href="#np-complete" class="header-anchor"> </a></h2>
<p><em>NP-Complete is a complexity class which represents the set of all problems <code>X</code> in NP for which it is possible to reduce any other NP problem <code>Y</code> to <code>X</code> in polynomial time.</em></p>
<p>Intuitively this means that we can solve <code>Y</code> quickly if we know how to solve <code>X</code> quickly. Precisely, <code>Y</code> is reducible to <code>X</code>, if there is a polynomial time algorithm <code>f</code> to transform instances <code>y</code> of <code>Y</code> to instances <code>x = f(y)</code> of <code>X</code> in polynomial time, with the property that the answer to <code>y</code> is yes, if and only if the answer to <code>f(y)</code> is yes.</p>
<h3><span id="example">Example</span><a href="#example" class="header-anchor"> </a></h3>
<p><code>3-SAT</code>. This is the problem wherein we are given a conjunction (ANDs) of 3-clause disjunctions (ORs), statements of the form</p>
<blockquote></blockquote>
<p>(x_v11 OR x_v21 OR x_v31) AND
(x_v12 OR x_v22 OR x_v32) AND
…                       AND
(x_v1n OR x_v2n OR x_v3n)</p>
<p>where each <code>x_vij</code> is a boolean variable or the negation of a variable from a finite predefined list <code>(x_1, x_2, ... x_n)</code>.</p>
<p>It can be shown that <em>every NP problem can be reduced to 3-SAT</em>. The proof of this is technical and requires use of the technical definition of NP <em>(based on non-deterministic Turing machines)</em>. This is known as Cook’s theorem.</p>
<p>What makes NP-complete problems important is that if a deterministic polynomial time algorithm can be found to solve one of them, every NP problem is solvable in polynomial time (one problem to rule them all).</p>
<hr>
<h2><span id="np-hard">NP-hard</span><a href="#np-hard" class="header-anchor"> </a></h2>
<p><em>Intuitively, these are the problems that are at least as hard as the NP-complete problems. Note that NP-hard problems do not have to be in NP, and they do not have to be decision problems.</em></p>
<p>The precise definition here is that a problem <code>X</code> is NP-hard, if there is an NP-complete problem <code>Y</code>, such that <code>Y</code> is reducible to <code>X</code> in polynomial time.</p>
<p>But since any NP-complete problem can be reduced to any other NP-complete problem in polynomial time, all NP-complete problems can be reduced to any NP-hard problem in polynomial time. Then, if there is a solution to one NP-hard problem in polynomial time, there is a solution to all NP problems in polynomial time.</p>
<h3><span id="example">Example</span><a href="#example" class="header-anchor"> </a></h3>
<p>The halting problem is an NP-hard problem. This is the problem that given a program <code>P</code> and input <code>I</code>, will it halt? This is a decision problem but it is not in NP. It is clear that any NP-complete problem can be reduced to this one. As another example, any NP-complete problem is NP-hard.</p>
<p>My favorite NP-complete problem is the <a href="http://web.mat.bham.ac.uk/R.W.Kaye/minesw/ordmsw.htm" target="_blank" rel="noopener">Minesweeper problem</a>.</p>
<hr>
<h2><span id="p-np">P = NP</span><a href="#p-np" class="header-anchor"> </a></h2>
<p>This one is the most famous problem in computer science, and one of the most important outstanding questions in the mathematical sciences. In fact, the <a href="http://www.claymath.org/millennium/P_vs_NP/" target="_blank" rel="noopener">Clay Institute</a> is offering one million dollars for a solution to the problem (Stephen Cook’s <a href="http://www.claymath.org/sites/default/files/pvsnp.pdf" target="_blank" rel="noopener">writeup</a> on the Clay website is quite good).</p>
<p>It’s clear that P is a subset of NP. The open question is whether or not NP problems have deterministic polynomial time solutions. It is largely believed that they do not. Here is an outstanding recent article on the latest (and the importance) of the P = NP problem: <a href="http://cacm.acm.org/magazines/2009/9/38904-the-status-of-the-p-versus-np-problem/fulltext" target="_blank" rel="noopener">The Status of the P versus NP problem.</a></p>
<p>The best book on the subject is <a href="http://rads.stackoverflow.com/amzn/click/0716710455" target="_blank" rel="noopener">Computers and Intractability</a> by Garey and Johnson.</p>
<p><a href="http://stackoverflow.com/questions/1857244/what-are-the-differences-between-np-np-complete-and-np-hard" title="What are the differences between NP, NP-Complete and NP-Hard?" target="_blank" rel="noopener">来源</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《数学之美》读书笔记</title>
    <url>/2016/09/05/BeautyOfMathematics1/</url>
    <content><![CDATA[<ol>
<li>一个正确的数学模型应当在形式上是简单的(托勒密的模型显然太复杂。)</li>
<li>一个正确的模型在它开始的时候可能还不如一个精雕细琢过的错误的模型来的准确，但是，如果我们认定大方向是对的，就应该坚持下去(日心说一开始并没有地心说准确。)</li>
<li>大量准确的数据对研发很重要。</li>
<li>正确的模型也可能受噪音干扰，而显得不准确；这是不应该用一种凑合的修正方法加以弥补，而是要找到噪音的根源，这也许能通往重大的发现。</li>
</ol>
]]></content>
      <categories>
        <category>摘抄</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】十大Intellij IDEA快捷键</title>
    <url>/2016/08/24/Intellij-IDEA-Shortcut-Keys/</url>
    <content><![CDATA[<p>Intellij IDEA中有很多快捷键让人爱不释手，stackoverflow上也有一些有趣的讨论。每个人都有自己的最爱，想排出个理想的榜单还真是困难。以前也整理过Intellij的快捷键，这次就按照我日常开发时的使用频率，简单分类列一下我最喜欢的<strong>十大快捷-神-键</strong>吧。</p>
<a id="more"></a>
<h2><span id="1智能提示">1.智能提示</span><a href="#1智能提示" class="header-anchor"> </a></h2>
<p>Intellij首当其冲的当然就是Intelligence智能！基本的代码提示用<strong>Ctrl+Space</strong>，还有更智能地按类型信息提示<strong>Ctrl+Shift+Space</strong>，但因为Intellij总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键(除非提示框消失了)。用<strong>F2/ Shift+F2</strong>移动到有错误的代码，<strong>Alt+Enter</strong>快速修复(即Eclipse中的Quick Fix功能)。当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲<strong>Ctrl+Shift+Enter</strong>就能自动补全末尾的字符。而且不只是括号，例如敲完if/for时也可以自动补上{}花括号。<br>
最后要说一点，Intellij能够智能感知spring、hibernate等主流框架的配置文件和类，以静制动，在看似“静态”的外表下，智能地扫描理解你的项目是如何构造和配置的。</p>
<h2><span id="2重构">2.重构</span><a href="#2重构" class="header-anchor"> </a></h2>
<p>Intellij重构是另一完爆Eclipse的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。尤其看过《重构-改善既有代码设计》之后，有了Intellij的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使Intellij下的TDD开发非常顺畅。<br>
切入正题，先说一个无敌的重构功能大汇总快捷键<strong>Ctrl+Shift+Alt+T</strong>，叫做Refactor This。按法有点复杂，但也符合Intellij的风格，很多快捷键都要双手完成，而不像Eclipse不少最有用的快捷键可以潇洒地单手完成(不知道算不算Eclipse的一大优点)，但各位用过Emacs的话就会觉得也没什么了(非Emacs黑)。此外，还有些最常用的重构技巧，因为太常用了，若每次都在Refactor This菜单里选的话效率有些低。比如<strong>Shift+F6</strong>直接就是改名，<strong>Ctrl+Alt+V</strong>则是提取变量。</p>
<h2><span id="3代码生成">3.代码生成</span><a href="#3代码生成" class="header-anchor"> </a></h2>
<p>这一点类似Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。常用的有<strong>fori/sout/psvm+Tab</strong>即可生成循环、System.out、main方法等boilerplate样板代码，用<strong>Ctrl+J</strong>可以查看所有模板。后面“辅助”一节中将会讲到<strong>Alt+Insert</strong>，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等。这两个技巧实在太常用了，几乎每天都要生成一堆main、System.out和getter/setter。<br>
另外，Intellij IDEA 13中加入了后缀自动补全功能(Postfix Completion)，比模板生成更加灵活和强大。例如要输入for(User user : users)只需输入<strong>user.for+Tab</strong>。再比如，要输入Date birthday = user.getBirthday();只需输入<strong>user.getBirthday().var+Tab</strong>即可。</p>
<h2><span id="4编辑">4.编辑</span><a href="#4编辑" class="header-anchor"> </a></h2>
<p>编辑中不得不说的一大神键就是能够自动按语法选中代码的<strong>Ctrl+W</strong>以及反向的<strong>Ctrl+Shift+W</strong>了。此外，<strong>Ctrl+Left/Right</strong>移动光标到前/后单词，<strong>Ctrl+[/]<strong>移动到前/后代码块，这些类Vim风格的光标移动也是一大亮点。以上Ctrl+Left/Right/[]加上Shift的话就能选中跳跃范围内的代码。<strong>Alt+Forward/Backward</strong>移动到前/后方法。还有些非常普通的像</strong>Ctrl+Y</strong>删除行、<strong>Ctrl+D</strong>复制行、<strong>Ctrl+&lt;/&gt;<strong>折叠代码就不多说了。<br>
关于光标移动再多扩展一点，除了Intellij本身已提供的功能外，我们还可以安装ideaVim或者emacsIDEAs享受到Vim的快速移动和Emacs的AceJump功能(超爽！)。另外，Intellij的书签功能也是不错的，用</strong>Ctrl+Shift+Num</strong>定义1-10书签(再次按这组快捷键则是删除书签)，然后通过<strong>Ctrl+Num</strong>跳转。这避免了多次使用前/下一编辑位置<strong>Ctrl+Left/Right</strong>来回跳转的麻烦，而且此快捷键默认与Windows热键冲突(默认多了Alt，与Windows改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。</p>
<h2><span id="5查找打开">5.查找打开</span><a href="#5查找打开" class="header-anchor"> </a></h2>
<p>类似Eclipse，Intellij的Ctrl+N/Ctrl+Shift+N可以打开类或资源，但Intellij更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了Eclipse中还有输入*的麻烦。最新版本的IDEA还加入了Search Everywhere功能，只需按<strong>Shift+Shift</strong>即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。<br>
类的继承关系则可用<strong>Ctrl+H</strong>打开类层次窗口，在继承层次上跳转则用<strong>Ctrl+B/Ctrl+Alt+B</strong>分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用<strong>Ctrl+F12</strong>。<br>
要找类或方法的使用也很简单，<strong>Alt+F7</strong>。要查找文本的出现位置就用<strong>Ctrl+F/Ctrl+Shift+F</strong>在当前窗口或全工程中查找，再配合<strong>F3/Shift+F3</strong>前后移动到下一匹配处。<br>
Intellij更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij就会自动为你过滤。</p>
<h2><span id="6其他辅助">6.其他辅助</span><a href="#6其他辅助" class="header-anchor"> </a></h2>
<p>以上这些神键配上一些辅助快捷键，即可让你的双手90%以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有：</p>
<ul>
<li>命令：<strong>Ctrl+Shift+A</strong>可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。</li>
<li>新建：<strong>Alt+Insert</strong>可以新建类、方法等任何东西。</li>
<li>格式化代码：格式化import列表<strong>Ctrl+Alt+O</strong>，格式化代码<strong>Ctrl+Alt+L</strong>。</li>
<li>切换窗口：<strong>Alt+Num</strong>，常用的有1-项目结构，3-搜索结果，4/5-运行调试。<strong>Ctrl+Tab</strong>切换标签页，<strong>Ctrl+E/Ctrl+Shift+E</strong>打开最近打开过的或编辑过的文件。</li>
<li>单元测试：<strong>Ctrl+Alt+T</strong>创建单元测试用例。</li>
<li>运行：<strong>Alt+Shift+F10</strong>运行程序，<strong>Shift+F9</strong>启动调试，<strong>Ctrl+F2</strong>停止。</li>
<li>调试：<strong>F7/F8/F9</strong>分别对应Step into，Step over，Continue。</li>
</ul>
<p>此外还有些我自定义的，例如水平分屏Ctrl+|等，和一些神奇的小功能Ctrl+Shift+V粘贴很早以前拷贝过的，Alt+Shift+Insert进入到列模式进行按列选中。</p>
<h2><span id="7最终榜单">7.最终榜单</span><a href="#7最终榜单" class="header-anchor"> </a></h2>
<p>这榜单阵容太豪华了，后几名都是如此有用，毫不示弱。</p>
<ul>
<li>Top #10切来切去：Ctrl+Tab</li>
<li>Top #9选你所想：Ctrl+W</li>
<li>Top #8代码生成：Template/Postfix +Tab</li>
<li>Top #7发号施令：Ctrl+Shift+A</li>
<li>Top #6无处藏身：Shift+Shift</li>
<li>Top #5自动完成：Ctrl+Shift+Enter</li>
<li>Top #4创造万物：Alt+Insert</li>
</ul>
<p>太难割舍，前三名并列吧！</p>
<ul>
<li>Top #1智能补全：Ctrl+Shift+Space</li>
<li>Top #1自我修复：Alt+Enter</li>
<li>Top #1重构一切：Ctrl+Shift+Alt+T</li>
</ul>
<p>【转自】<a href="http://blog.csdn.net/dc_726/article/details/42784275" title="十大Intellij IDEA快捷键" target="_blank" rel="noopener">十大Intellij IDEA快捷键</a></p>
]]></content>
      <categories>
        <category>应用开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis的xml中&lt; &gt;的写法</title>
    <url>/2016/08/23/mybatis-comparison-operators-in-xml/</url>
    <content><![CDATA[<p><strong>非法的 XML 字符必须被替换为实体引用（entity reference）</strong>
假如您在 XML 文档中放置了一个类似 “&lt;” 字符，那么这个文档会产生一个错误，这是因为解析器会把它解释为新元素的开始。因此你不能这样写：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt;</span><br></pre></td></tr></table></figure>
<p>由于Mybatis的sql是写在配置文件里面,但解析xml时出现 &gt;= 或 &lt;= 时会认为 &lt; 是一个标签的开始,导致sql报错。</p>
<a id="more"></a>
<p>解决方案有两种</p>
<h3><span id="1-加上cdata">1、加上CDATA</span><a href="#1-加上cdata" class="header-anchor"> </a></h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">isNotEmpty</span> <span class="attr">property</span>=<span class="string">"logNameEnd"</span> <span class="attr">prepend</span>=<span class="string">"AND"</span>&gt;</span></span><br><span class="line">&lt;![CDATA[ u.log_name &gt;= #logNameStart# AND u.log_name &lt;= #logNameEnd# ]]&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">isNotEmpty</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>意思就是在有 <strong>&gt;=</strong>（包括其他比较符&lt; &gt;） 的该行需要加入**<!--[CDATA[ ]]-->**</p>
<h3><span id="2-使用转义符号">2、使用转义符号</span><a href="#2-使用转义符号" class="header-anchor"> </a></h3>
<p>在 XML 中有 5 个预定义的实体引用：</p>
<table>
<thead>
<tr>
<th style="text-align:left">实体引用</th>
<th style="text-align:left">符号</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>&amp;lt;</code></td>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">小于</td>
</tr>
<tr>
<td style="text-align:left"><code>&amp;gt;</code></td>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">大于</td>
</tr>
<tr>
<td style="text-align:left"><code>&amp;amp;</code></td>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">和号</td>
</tr>
<tr>
<td style="text-align:left"><code>&amp;apos;</code></td>
<td style="text-align:left">’</td>
<td style="text-align:left">省略号</td>
</tr>
<tr>
<td style="text-align:left"><code>&amp;quot;</code></td>
<td style="text-align:left">&quot;</td>
<td style="text-align:left">引号</td>
</tr>
</tbody>
</table>
<p>在书写时，将符号转为第一列的实体引用即可。</p>
]]></content>
      <categories>
        <category>应用开发</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>杭州一月游</title>
    <url>/2016/08/22/ThinkInHangzhou/</url>
    <content><![CDATA[<h3><span id="写在前面">写在前面</span><a href="#写在前面" class="header-anchor"> </a></h3>
<p>本科四年有好多好多事想和大家分享，但一直没有时间写，一拖再拖。今天是本科毕业后暑期实习结束后的第一天，那么我将从我的杭州暑期实习开始讲起。</p>
<a id="more"></a>
<h3><span id="短期实习">短期实习</span><a href="#短期实习" class="header-anchor"> </a></h3>
<h4><span id="准备出发">准备出发</span><a href="#准备出发" class="header-anchor"> </a></h4>
<p>实习是我一直想要做的，一是在学校太久，希望去外面看看，了解一些新鲜的行业动态。二是与同学聚聚，聊聊人生。。。</p>
<p><img src="//img.tianle.me/image/20160822/3.jpg" alt="宝石山看西湖"></p>
<p>7月11回到家，由于时间比较晚，各互联网的大公司针对学生的暑期实习招聘都已经结束，在家修整一天后就开始疯狂的在智联招聘上投递简历，只要是看到与Java相关，且符合我能力水平的都投了一遍。两天之内总计发出的简历估计有80份左右，接下来的几天就陆续接到几十个面试邀请。由于8月底还要去学校读研，因此在面试邀请时，直接坦白地表示我只能实习一到两个月，结果可想而知，大部分的公司都拒绝了，最后只剩下3家。确定好面试公司及时间后，周四便飞奔杭州，周五正式开始面试。</p>
<p><img src="//img.tianle.me/image/20160822/1.jpg" alt="初到杭州运河"></p>
<h4><span id="面试">面试</span><a href="#面试" class="header-anchor"> </a></h4>
<p>面试进展还是比较顺利，主要就问了之前做过的项目，还有一些Java、SSM框架的基础知识，比如Java中的HashMap，Spring MVC的请求，Controller中的返回值等等。<br>
　　面试结束当晚就通知明天正式上班了，看来公司还是非常缺人的。</p>
<h4><span id="谈薪水">谈薪水</span><a href="#谈薪水" class="header-anchor"> </a></h4>
<p>有句话说的好:<em>知己知彼百战不殆</em>。初次面试时，当老板谈到薪水期望时，考虑到自己时间比较短，担心对方不接受，答的比较含糊，只要够吃住就行。面试当晚上接到第二天上班通知，到公司实际体验了一番，了解公司目前做的项目之后，心想公司应该非常缺人，而且面试时表现应该不错，同时对自己的技术实力也比较自信，在接下来正式谈报酬时，底气就比较足了。结果也出乎我的意料，我提的要求几乎全部满足，公司同意为我提供住宿。</p>
<h4><span id="业务">业务</span><a href="#业务" class="header-anchor"> </a></h4>
<p>在来实习之前，之前实验室的大师兄能哥给我提了三点：1、了解公司业务、工作流程；2、多向公司里的大牛学习；3、把该有的薪水拿到。<br>
　　我们公司做的是微商，运营模式也是常见的代理模式，不同级别的代理商拿货价格不同，而且每一级代理只与他的直接上级相关。这个巧妙的代理模式可以通过管理少数的一级代理商从而掌握巨大的流量。</p>
<blockquote>
<p>代理模式是目前流水量最高的模式，也是化妆品尤其是面膜品类的主要模式，目前这个模式。当然，这也是被外界诟病最多的模式，很多人认为朋友圈营销就是找代理，然后就会又被扣上传销的帽子。实际上，朋友圈代理模式只是线下代理模式的一个延伸。
<a href="http://www.webzmt.com/weishang/1708.html" title="微商不得不知的五大朋友圈运营模式" target="_blank" rel="noopener">微商不得不知的五大朋友圈运营模式</a></p>
</blockquote>
<p>而要想注册成为代理商，需要事先缴纳一笔“入门费”，不同代理级别的“入门费”以及销售任务、拿货价格等都不尽相同。审核通过后就成为正式代理。通过不同的推荐关系，代理链，上级代理商，团队管理等不同角色就可以从这些代理中获得不少收入。那么这些代理关系需要如何管理，收益、返利如何计算等等就需要一个信息化的系统去统一维护。信息系统最主要的功能的就是减少人工计算量。<br>
　　关于微商的运营模式，这里就不一一叙说了。有兴趣的同学可以自行百度了解。</p>
<h4><span id="项目开发">项目开发</span><a href="#项目开发" class="header-anchor"> </a></h4>
<p>项目的结构也很常见，和我在学校参与的项目一致，后台技术就是用的SSM三大框架。对我来说技术上没有遇到什么问题，最主要的是了解项目的业务流程。由于是个小公司流程不是特别规范，但这里毕竟还有大神，感悟还是挺多。下面就分条介绍吧</p>
<ul>
<li>
<p><strong>分析业务，确定需求</strong>
通过几次项目，以及这次实习体验，给我的体会是需求分析非常重要。做好需求分析可以大大减少后续步骤的工作量。如何做好需求分析就需要有充分的调研，对业务深入的理解。有时候客户提出的要求并不是真正的需求，需要我们进行深层次地挖掘，分析客户真正想要的东西，看看客户是不是真的有这方面的要求，不要等到已经开发完成的时候，才发现效果不是客户需要的。<br>
这个情况我在实习的时候就遇到过。测试人员提出一个优化点，认为用户需要添加某个功能，同时反馈给我们组老大，老大想了一会儿，觉得这个需求是合理的，当然我们开发也觉得很有必要，然后马上开工写代码了。结果过了一天，公司开会的时候，我们刚提出这么一个优化点，就立刻被其他部门否决了，因为我们业务与其他公司不一样，不需要这个功能，如果加上去，可能会带来一系列的麻烦。最后的结果就是，我们又迫不得已删除已经修改的代码，重新开始。</p>
</li>
<li>
<p><strong>规范文档管理</strong>
由于项目刚起步，流程还不是特别规范，有关需求的文档都是直接往工作的微信群中一扔，大家自行下载查看。就不提版本无法维护的问题，时间久了，有时候连文档都找不到。</p>
</li>
<li>
<p><strong>项目全景图、脑图、流程图</strong>
如果项目中有这几个图或者其中一个，可以让新入职的员工快速地熟悉业务流程。有了总体框架后，再进行模块细分。在对模块细分的时候，需要考虑有相互影响，有涉及到的相关模块。</p>
</li>
<li>
<p><strong>先思考，再动代码</strong>
拿到需求后，万万不可以一来就着急着写代码，改代码。而是首先分析需求的业务逻辑，看看是否合理，评估难度，与现有系统有没有冲突，预计多久能够完成，涉及到哪些模块，要改动或者新写多少代码。</p>
</li>
<li>
<p><strong>不怕麻烦，写好代码</strong></p>
</li>
</ul>
<ol>
<li>不属于这个类（实体）的属性，该拆分的就拆分，不能因为偷懒把这些不改有的属性混杂在一起。不然到后面业务需求有变化的时候，在去做拆分就会变得非常麻烦，改动会非常的大。</li>
<li>一个方法只做一件事，如果一个方法里面执行了好多事，不拆开的话一定要写好注释。</li>
<li>方法名、变量名要取的有意义，让人一看就明白，不然可能连自己也不知道写了什么东西。</li>
<li>文件、方法该放在什么位置就放在什么位置，不要东一个西一个。比如Controller层里面拼拼结构，做个页面跳转等简单操作就可以了，不要把一堆增删改查的操作也放在里面。</li>
<li>有些东西是不能偷懒的，要对自己写的代码负责，对自己负责，也方便他人。说不定别人看到你的烂代码在心里偷偷骂你呢。</li>
</ol>
<h4><span id="学习">学习</span><a href="#学习" class="header-anchor"> </a></h4>
<p>坐我对面的是一个非常热情的小伙子，但是他有一个致命的缺点就是做事不太积极，要是别人不给他任务，他就没有事情做，而在他旁边的那位哥们做事更加积极，把他要做的活都做了。因此他每天上班过来只是看看新闻，玩玩手机，偶尔有任务的时候做一下，可能公司觉得它没做什么任务，给他安排了一个客服的活，打打电话，了解客户对产品的使用反馈。但只做了两天，后来不知道什么原因又没有继续下去了。直到某天一天中午，他被公司炒鱿鱼，事发突然，还记的那天上午上班前我还和他在愉快地讨论DOTA2的TI杯呢。在我们为他感到惋惜的同时也让我明白了一个道理：<strong>不积极，不干事，不学习 就被淘汰。</strong>　　　　　<em>——记8月13中午，测试员工被辞事件</em><br>
　　公司虽小，但也总有几个大神。和他们交流的时候就深刻感受到自己学到的知识实在是太少了，在这个知识爆炸的阶段，唯有不断学习才可以不被这个社会淘汰。趁着现在年轻，找准自己感兴趣的方向，赶紧学新知识。<br>
　　阿里来的大神是我在公司里最佩服的一个人，他思维敏捷，考虑问题周到，做事也是一丝不苟，对布置给他的任务都是全心全意的完成，对加班加点也是毫无怨言。同时待人和善，当我们遇到问题向他请教时，总是不耐其烦地为我们讲解。我刚进公司，他对我的代码提出了许多非常宝贵的建议，也指出了很多不足之处。在此表示感谢！</p>
<h4><span id="休息">休息</span><a href="#休息" class="header-anchor"> </a></h4>
<p>做IT这行，差不多每天从早上九点上到晚上九点，虽说正常下班时间是下午6点，但是到了下班时间，大家都没有一点反应，仍是埋头苦干。那么大的工作强度，如果时间久了，身体肯定扛不住。所以上班之余还是多休息，出去逛逛比较好。</p>
<h3><span id="写在最后">写在最后</span><a href="#写在最后" class="header-anchor"> </a></h3>
<blockquote>
<p>“江南忆，最忆是杭州，山寺月中寻桂子，郡亭枕上看潮头，何日更重游。”</p>
</blockquote>
<p>在杭州，还念周末与朋友游西湖，想念夜晚与妹子逛运河，正是他们让我爱上这座城市。
<img src="//img.tianle.me/image/20160822/2.jpg" alt="西湖莲花"></p>
<p><img src="//img.tianle.me/image/20160822/7.jpg" alt="逛运河"></p>
<p><img src="//img.tianle.me/image/20160822/4.jpg" alt="八卦田凤凰山"></p>
<p><img src="//img.tianle.me/image/20160822/5.jpg" alt="虎跑"></p>
<p><img src="//img.tianle.me/image/20160822/6.jpg" alt="宝石山夜看西湖"></p>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 中 LaTeX不显示</title>
    <url>/2016/05/30/Hexo-%E4%B8%AD-LaTeX%E4%B8%8D%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>昨天写博客的时候需要编写数学公式。Hexo本身没有提供，解决的方案有将公式转为图片添加、调用第三方接口直接生成、还有就是安装Hexo-math插件，如果你采用的next主题，也可以使用主题提供的<a href="http://theme-next.iissnan.com/third-party-services.html#mathjax" target="_blank" rel="noopener">解决方案</a>
hexo-math插件的安装说明请查看<a href="https://github.com/akfish/hexo-math" target="_blank" rel="noopener">hexo-math</a></p>
<a id="more"></a>
<h3><span id="latex公式不显示">LaTeX公式不显示</span><a href="#latex公式不显示" class="header-anchor"> </a></h3>
<p>在书写完LaTeX公式完之后，在网页中一直无法正确显示。刚开始以为是LaTeX公式书写错误、或者hexo-math插件未安装正确，但经过反复排查后，LaTeX语法和插件安装都没有问题。错误如下所示：</p>
<blockquote>
<p>我要书写如下公式：$X_{id}^{k + 1} = X_{id}^k + {V_{k + 1{\kern 1pt} {\kern 1pt} {\kern 1pt} id}}$
但是按照LaTeX语法书写完毕后，hexo貌似并不能帮你转换公式，显示如下：
$X_{id}^{k + 1} = X_{id}^k + {V_{k + 1{\kern 1pt} {\kern 1pt} {\kern 1pt} id}}$</p>
</blockquote>
<p>原因是 在 Markdown 中, _  _ 表示的是中间部分的倾斜, 所以我就将这个公式改成了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$X\_&#123;id&#125;^&#123;k + 1&#125; = X\_&#123;id&#125;^k + &#123;V\_&#123;k + 1&#123;\kern 1pt&#125; &#123;\kern 1pt&#125; &#123;\kern 1pt&#125; id&#125;&#125;$</span><br></pre></td></tr></table></figure>
<p>在每个下划线 _ 之前添加转义符号 ’ \ ',这样Markdown就不会将你的 _误认为斜体了。
修改完成后，公式即正确显示。</p>
<p>另外有一点想向大家求助：hexo目前貌似不能使用Markdown来书写流程图，只能往里面添加图片。若有您有较好的解决方案，欢迎在下方留言。非常感谢！
参考<a href="http://draveness.me/hexozhong-latexde-shi-yong/" target="_blank" rel="noopener">Hexo 中 LaTeX的使用</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算智能】目标优化智能算法之粒子群算法</title>
    <url>/2016/05/29/pso%20algorithm/</url>
    <content><![CDATA[<p>粒子群优化(Particle Swarm Optimization, PSO)，又称微粒算法，是计算智能领域，除了蚁群算法、鱼群算法之外的一种群体智能的优化算法。</p>
<a id="more"></a>
<h3><span id="历史背景">历史背景</span><a href="#历史背景" class="header-anchor"> </a></h3>
<p>该算法最早是由J. Kennedy和R. C. Eberhart等于1995年开发的一种演化计算技术。PSO算法源于对鸟类捕食行为的研究，鸟类捕食时，找到食物最简单有效的策略就是搜寻当前距离食物最近的鸟的周围区域。PSO算法是从这种生物种群行为特征中得到启发并用于求解优化问题的，算法中每个粒子都代表问题的一个潜在解，每个粒子对应一个由适应度函数决定的适应度值。粒子的速度决定了粒子的移动方向和距离，速度随自身及其他粒子的移动经验进行动态调整，从而实现个体在可解空间中的寻优。通过加入近邻的速度匹配、并考虑多维搜索和根据距离的加速、形成了PSO的最初版本。之后引入了惯性权重w来更好的控制开发(exploitation)和探索(exploration)，形成了标准版本。为了提高粒子群算的性能和实用性，中山大学、（英国）格拉斯哥大学等又开发了自适应(Adaptive PSO)版本和离散(discrete)版本。</p>
<h3><span id="常见应用">常见应用</span><a href="#常见应用" class="header-anchor"> </a></h3>
<p>在本文的开篇已经提到，粒子群算法是属于智能算法中的目标优化算法，因此，只要与优化问题相关都可以采用粒子群算法。而问题又可以分为连续和离散的，因此粒子群算法也就有连续版本和离散版本。标准粒子群算法是连续的，若要求解的问题是离散的，那么我们就需要根据问题的实际情况，对标准粒子群算法进行修改，以适应离散的情况。<br>
可以参考这篇粒子群算法的综述<a href="http://blog.sciencenet.cn/home.php?mod=attachment&amp;id=12083" target="_blank" rel="noopener">《粒子群优化算法综述》戴朝华</a></p>
<blockquote>
<p>典型理论问题包括：组合优化、约束优化、多目标优化、动态系统优化等。实际工业应用有：电力系统、滤波器设计、自动控制、数据聚类、模式识别与图像处理、化工、机械、通信、机器人、经济、生物信息、医学、任务分配、TSP等等。</p>
</blockquote>
<h3><span id="主要思想">主要思想</span><a href="#主要思想" class="header-anchor"> </a></h3>
<p>PSO算法首先在可行解空间中初始化一群粒子，每个粒子都代表极值优化问题的一个潜在最优解，用位置、速度和适应度值三项指标表示该粒子特征，适应度值由适应度函数计算得到，其值的好坏表示粒子的优劣。粒子在解空间中运动，通过跟踪个体极值pBest和群体极值gBest更新个体位置。个体极值pBest是指个体所经历位置中计算得到的适应度值最优位置，群体极值gBest是指种群中的所有粒子搜索到的适应度最优位置。粒子每更新一次位置，就计算一次适应度值，并且通过比较新粒子的适应度值和个体极值、群体极值的适应度值更新个体极值pBest和群体极值gBest位置。<br>
由于粒子群算法是源于鸟类的捕食行为，那么我们可以想象这么一个场景,以便对粒子群算法有个形象的了解:<br>
<strong>在一片广阔的土地上（解空间），有一群鸟（粒子）在觅食，而远程有一片玉米地（目标函数），每一只鸟在飞行（搜索）的过程中，它都记下它吃过最好吃的位置（个体极值），同时它又和其他伙伴交流哪里有好吃的（群体极值），根据这些条件判断，它判断下一时刻应该飞往哪里（循环迭代）。</strong></p>
<h3><span id="算法步骤">算法步骤</span><a href="#算法步骤" class="header-anchor"> </a></h3>
<p><img src="/img/20160529/PSO.gif" alt="流程图"></p>
<ol>
<li>粒子和速度初始化<br>
如果为了简单起见，可以采用随机的方式进行初始化。但是为了加快算法效率，可以根据问题实际来进行初始化操作。<br>
假设在一个D维的搜索空间中，由n个粒子组成的种群 $X=({X_2},{X_2},{X_3},\cdots,{X_n})$ 其中第i个粒子表示为一个D为的空间向量 ${X_i}={({x_{i1}},{x_{i2}},\cdots,{x_{id}})^T}$ 代表第i个粒子在D维搜索空间中的位置，亦代表问题的一个潜在解。</li>
<li>粒子适应度计算<br>
根据目标函数即可计算出每个粒子位置X<sub>i</sub>对应的适应度值。第i个粒子的速度为 ${V_i} = {({V_{i1}},{V_{i2}}, \cdots ,{V_{id}})^T}$ 其个体极值为 ${P_i} = {({P_{i1}},{P_{i2}}, \cdots ,{P_{id}})^T}$ 种群的群体极值为 ${P_g} = {({P_{g1}},{P_{g2}}, \cdots ,{P_{gd}})^T}$</li>
<li>速度更新和位置更新<br>
在每次迭代过程中，粒子通过个体极值和群体极值更新自身的速度和位置，即
$$V_{id}^{k + 1} = \omega V_{id}^k + {c_1}{r_1}(P_{id}^k - X_{id}^k) + {c_2}{r_2}(P_{gd}^k - X_{id}^k)$$
$$X_{id}^{k + 1} = X_{id}^k + {V_{k + 1{\kern 1pt} {\kern 1pt} {\kern 1pt} id}}$$
其中，ω为惯性权重；d=1,2,…,D;  i=1,2,…,n;  k为当前迭代次数；V<sub>id</sub>为粒子的速度；c<sub>1</sub>和c<sub>2</sub>是非负的常数，称为加速度因子；r<sub>1</sub>和r<sub>2</sub>是分布于[0,1]区间的随机数。为防止粒子的盲目搜索，一遍建议将其位置和速度限制在一定的区间[X<sub>min</sub>,X<sub>max</sub>]、[V<sub>min</sub>,V<sub>max</sub>]</li>
</ol>
<h3><span id="参数设定">参数设定</span><a href="#参数设定" class="header-anchor"> </a></h3>
<ol>
<li>速度更新参数c<sub>1</sub>和c<sub>2</sub>
一般设置为1.49445</li>
<li>惯性权重<br>
惯性权重表示为粒子本身的飞行速度。顾名思义ω实际反映了粒子过去的运动状态对当前行为的影响，就像是我们物理中提到的惯性。如果ω &lt;&lt; 1，从前的运动状态很少能影响当前的行为，粒子的速度会很快的改变；相反，ω较大，虽然会有很大的搜索空间，但是粒子很难改变其运动方向，很难向较优位置收敛，由于算法速度的因素，在实际运用中很少这样设置。也就是说，较高的ω设置促进全局搜索，较低的ω设置促进快速的局部搜索。<br>
Shi.Y提出了线性递减惯性权重（linear decreasing inertia weight,LDIW），并分析指出一个较大的惯性权值有利于全局搜索，而一个较小的惯性权值则更利于局部搜索。为了更好地平衡算法的全局搜索与局部搜索能力。<br>
$$\omega (k) = {\omega _{end}} + ({\omega _{start}} - {\omega _{end}})({T_{\max }} - k)/{T_{\max }}$$
其中，ω<sub>start</sub>为初始惯性权重，ω<sub>end</sub>为迭代到最大次数时的惯性权重；k为当前迭代次数；T<sub>max</sub>为最大迭代次数。一般来说，惯性权值ω<sub>start</sub>=0.9，ω<sub>end</sub>=0.4时算法性能最好。这样，随着迭代的进行，惯性权重有0.9线性递减至0.4，迭代初期较大的惯性权重使算法保持了较强的全局搜索能力，而迭代后期较小的惯性权重有利于算法进行更精确的局部搜索。</li>
</ol>
<h3><span id="matlab参考代码">MATLAB参考代码</span><a href="#matlab参考代码" class="header-anchor"> </a></h3>
<p>来源《MATLAB智能算法30个案例分析》第十三章，粒子群算法的寻优算法<br>
主函数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 清空环境</span></span><br><span class="line">clc</span><br><span class="line">clear</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 参数初始化</span></span><br><span class="line"><span class="comment">%粒子群算法中的两个参数</span></span><br><span class="line">c1 = <span class="number">1.49445</span>;</span><br><span class="line">c2 = <span class="number">1.49445</span>;</span><br><span class="line"></span><br><span class="line">maxgen=<span class="number">300</span>;    <span class="comment">%进化次数  </span></span><br><span class="line">sizepop=<span class="number">20</span>;   <span class="comment">%种群规模</span></span><br><span class="line">Vmax=<span class="number">0.5</span>;</span><br><span class="line">Vmin=<span class="number">-0.5</span>;</span><br><span class="line">popmax=<span class="number">2</span>;</span><br><span class="line">popmin=<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="number">100</span></span><br><span class="line">    <span class="comment">%% 产生初始粒子和速度</span></span><br><span class="line">    k</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:sizepop</span><br><span class="line">        <span class="comment">%随机产生一个种群</span></span><br><span class="line">        pop(<span class="built_in">i</span>,:)=<span class="number">2</span>*rands(<span class="number">1</span>,<span class="number">2</span>);    <span class="comment">%初始种群</span></span><br><span class="line">        V(<span class="built_in">i</span>,:)=<span class="number">0.5</span>*rands(<span class="number">1</span>,<span class="number">2</span>);  <span class="comment">%初始化速度</span></span><br><span class="line">        <span class="comment">%计算适应度</span></span><br><span class="line">        fitness(<span class="built_in">i</span>)=fun(pop(<span class="built_in">i</span>,:));   <span class="comment">%染色体的适应度</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%% 个体极值和群体极值</span></span><br><span class="line">    [bestfitness bestindex]=<span class="built_in">max</span>(fitness);</span><br><span class="line">    zbest=pop(bestindex,:);   <span class="comment">%全局最佳</span></span><br><span class="line">    gbest=pop;    <span class="comment">%个体最佳</span></span><br><span class="line">    fitnessgbest=fitness;   <span class="comment">%个体最佳适应度值</span></span><br><span class="line">    fitnesszbest=bestfitness;   <span class="comment">%全局最佳适应度值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">%% 迭代寻优</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:maxgen</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:sizepop</span><br><span class="line">        </span><br><span class="line">            <span class="comment">%速度更新</span></span><br><span class="line">            V(<span class="built_in">j</span>,:) = V(<span class="built_in">j</span>,:) + c1*<span class="built_in">rand</span>*(gbest(<span class="built_in">j</span>,:) - pop(<span class="built_in">j</span>,:)) + c2*<span class="built_in">rand</span>*(zbest - pop(<span class="built_in">j</span>,:));</span><br><span class="line">            V(<span class="built_in">j</span>,<span class="built_in">find</span>(V(<span class="built_in">j</span>,:)&gt;Vmax))=Vmax;</span><br><span class="line">            V(<span class="built_in">j</span>,<span class="built_in">find</span>(V(<span class="built_in">j</span>,:)&lt;Vmin))=Vmin;</span><br><span class="line"></span><br><span class="line">            <span class="comment">%种群更新</span></span><br><span class="line">            pop(<span class="built_in">j</span>,:)=pop(<span class="built_in">j</span>,:)+V(<span class="built_in">j</span>,:);</span><br><span class="line">            pop(<span class="built_in">j</span>,<span class="built_in">find</span>(pop(<span class="built_in">j</span>,:)&gt;popmax))=popmax;</span><br><span class="line">            pop(<span class="built_in">j</span>,<span class="built_in">find</span>(pop(<span class="built_in">j</span>,:)&lt;popmin))=popmin;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">%适应度值</span></span><br><span class="line">            fitness(<span class="built_in">j</span>)=fun(pop(<span class="built_in">j</span>,:)); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:sizepop</span><br><span class="line"></span><br><span class="line">            <span class="comment">%个体最优更新</span></span><br><span class="line">            <span class="keyword">if</span> fitness(<span class="built_in">j</span>) &gt; fitnessgbest(<span class="built_in">j</span>)</span><br><span class="line">                gbest(<span class="built_in">j</span>,:) = pop(<span class="built_in">j</span>,:);</span><br><span class="line">                fitnessgbest(<span class="built_in">j</span>) = fitness(<span class="built_in">j</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">%群体最优更新</span></span><br><span class="line">            <span class="keyword">if</span> fitness(<span class="built_in">j</span>) &gt; fitnesszbest</span><br><span class="line">                zbest = pop(<span class="built_in">j</span>,:);</span><br><span class="line">                fitnesszbest = fitness(<span class="built_in">j</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">        yy(<span class="built_in">i</span>)=fitnesszbest;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    s(k,:)=yy;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%% 结果分析</span></span><br><span class="line"><span class="keyword">for</span> m=<span class="number">1</span>:<span class="number">300</span></span><br><span class="line">    s(<span class="number">101</span>,m)=sum( s(:,m) )/<span class="number">100</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">plot</span>(s(<span class="number">101</span>,:),<span class="string">'k'</span>)</span><br><span class="line">title(<span class="string">'最优个体适应度'</span>,<span class="string">'fontsize'</span>,<span class="number">12</span>);</span><br><span class="line">xlabel(<span class="string">'进化代数'</span>,<span class="string">'fontsize'</span>,<span class="number">12</span>);ylabel(<span class="string">'适应度'</span>,<span class="string">'fontsize'</span>,<span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<p>适应度函数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">fun</span><span class="params">(x)</span></span></span><br><span class="line"><span class="comment">%函数用于计算粒子适应度值</span></span><br><span class="line"><span class="comment">%x           input           输入粒子 </span></span><br><span class="line"><span class="comment">%y           output          粒子适应度值 </span></span><br><span class="line">y=<span class="built_in">sin</span>(<span class="built_in">sqrt</span>(x(<span class="number">1</span>).^<span class="number">2</span>+x(<span class="number">2</span>).^<span class="number">2</span>))./<span class="built_in">sqrt</span>(x(<span class="number">1</span>).^<span class="number">2</span>+x(<span class="number">2</span>).^<span class="number">2</span>)+<span class="built_in">exp</span>((<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x(<span class="number">1</span>))+<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*x(<span class="number">2</span>)))/<span class="number">2</span>)<span class="number">-2.71289</span>;</span><br></pre></td></tr></table></figure>
<h3><span id="参考资料">参考资料</span><a href="#参考资料" class="header-anchor"> </a></h3>
<p>《MATLAB智能算法30个案例分析》<br>
<a href="https://zh.wikipedia.org/wiki/%E7%B2%92%E5%AD%90%E7%BE%A4%E4%BC%98%E5%8C%96#cite_note-zhan10OLPSO-6" target="_blank" rel="noopener">粒子群优化维基百科</a><br>
<a href="http://www.cnblogs.com/maybe2030/p/5043356.html" target="_blank" rel="noopener">[Algorithm] 群体智能优化算法之粒子群优化算法</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>计算智能</tag>
        <tag>目标优化</tag>
        <tag>算法</tag>
        <tag>PSO</tag>
        <tag>粒子群</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode ListNode helper</title>
    <url>/2016/05/25/LeetCode-ListNode-helper/</url>
    <content><![CDATA[<p>为了更加高效地调试LeetCode中关于ListNode的题目，编写了快速初始化ListNode的通用静态方法，重写ListNode的toString方法。</p>
<a id="more"></a>
<p>不多说了，直接上代码</p>
<h3><span id="listnode-类">ListNode 类</span><a href="#listnode-类" class="header-anchor"> </a></h3>
<p>重写了toString方法，方便调试时能够直接输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">""</span>;</span><br><span class="line">        ListNode current = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">while</span> ( current != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            s = s + <span class="string">" "</span> + current.val;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="listnodeutil-类">ListNodeUtil 类</span><a href="#listnodeutil-类" class="header-anchor"> </a></h3>
<p>编写ListNode初始化方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNodeUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">initList</span> <span class="params">(<span class="keyword">int</span>...vals)</span></span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val : vals)&#123;</span><br><span class="line">            current.next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode l = initList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.println(l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我的<a href="https://github.com/zhangtianle/LeetCode/tree/master/src/util" target="_blank" rel="noopener">github LeetCode 刷题记录</a></p>
<p>编写上述代码的思路来源于<a href="https://github.com/fatezy/arithmetic/tree/master/arithmetic/leetCode/util" target="_blank" rel="noopener">fatezy’s github</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode Java解题常用类方法(持续更新中......)</title>
    <url>/2016/05/11/LeetCode-Java%E8%A7%A3%E9%A2%98%E5%B8%B8%E7%94%A8%E7%B1%BB%E6%96%B9%E6%B3%95-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/</url>
    <content><![CDATA[<p>开刷LeetCode，把一些Java中常用类的方法，归纳整理，方便今后查阅。不断更新中。。。。。。</p>
<a id="more"></a>
<h2><span id="字符串">字符串</span><a href="#字符串" class="header-anchor"> </a></h2>
<h3><span id="string转int-long等">String转int、long等</span><a href="#string转int-long等" class="header-anchor"> </a></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String sInt = <span class="string">"123"</span>;</span><br><span class="line">	<span class="keyword">int</span> s = Integer.parseInt(sInt);</span><br><span class="line">	<span class="keyword">long</span> ls = Long.parseLong(sInt);</span><br><span class="line">    System.out.println(s + <span class="string">" "</span> + ls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="stringbuffer">StringBuffer</span><a href="#stringbuffer" class="header-anchor"> </a></h3>
<blockquote>
<p>StringBuffer类和String一样，也用来代表字符串，只是由于StringBuffer的内部实现方式和String不同，所以StringBuffer在进行字符串处理时，不生成新的对象，在内存使用上要优于String类。
所以在实际使用时，如果经常需要对一个字符串进行修改，例如插入、删除等操作，使用StringBuffer要更加适合一些。
在StringBuffer类中存在很多和String类一样的方法，这些方法在功能上和String类中的功能是完全一样的。
但是有一个最显著的区别在于，对于StringBuffer对象的每次修改都会改变对象自身，这点是和String类最大的区别。
另外由于StringBuffer是线程安全的，关于线程的概念后续有专门的章节进行介绍，所以在多线程程序中也可以很方便的进行使用，但是程序的执行效率相对来说就要稍微慢一些。</p>
</blockquote>
<p>1.String 转 StringBuffer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>
<p>2.append方法<br>
将内容追加到StringBuffer末尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br><span class="line">s.append(<span class="string">"efg"</span>);</span><br><span class="line">System.out.println(s.toString());</span><br></pre></td></tr></table></figure>
<p>3.delete*方法
deleteCharAt(int index)
该方法的作用是删除指定位置的字符，然后将剩余的内容形成新的字符串。第一位为0
s.delete(int start,int end)
该方法的作用是删除指定区间以内的所有字符，包含start，不包含end索引值的区间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer s = <span class="keyword">new</span> StringBuffer(<span class="string">"abc"</span>);</span><br><span class="line">s.append(<span class="string">"efg"</span>);</span><br><span class="line">s.deleteCharAt(<span class="number">2</span>);</span><br><span class="line">s.delete(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">System.out.println(s.toString());</span><br></pre></td></tr></table></figure>
<p>4.insert方法
StringBuffer insert(int offset, String str)
该方法的作用是在StringBuffer对象中插入内容，然后形成新的字符串。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"TestString"</span>);</span><br><span class="line">sb.insert(<span class="number">4</span>,<span class="string">"hello"</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure>
<p>5.reverse方法
StringBuffer reverse()
该方法的作用是将StringBuffer对象中的内容反转，然后形成新的字符串。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"TestString"</span>);</span><br><span class="line">sb.reverse();</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure>
<p>经过反转以后，对象sb中的内容将变为”gnirtStseT”。
6、setCharAt方法
setCharAt(int index, char ch)
该方法的作用是修改对象中索引值为index位置的字符为新的字符ch。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer(<span class="string">"bc"</span>);</span><br><span class="line">sb.setCharAt(<span class="number">1</span>,<span class="string">'D'</span>);</span><br></pre></td></tr></table></figure>
<p>则对象sb的值将变成”aDc”。</p>
<h2><span id="数组">数组</span><a href="#数组" class="header-anchor"> </a></h2>
<h3><span id="排序">排序</span><a href="#排序" class="header-anchor"> </a></h3>
<p>Array.Sort() 快排</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arrayToSort = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">48</span>, <span class="number">5</span>, <span class="number">89</span>, <span class="number">80</span>, <span class="number">81</span>, <span class="number">23</span>, <span class="number">45</span>, <span class="number">16</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    System.out.println(<span class="string">"排序前"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayToSort.length; i++)</span><br><span class="line">        System.out.println(arrayToSort[i]);</span><br><span class="line">    <span class="comment">// 调用数组的静态排序方法sort</span></span><br><span class="line">    Arrays.sort(arrayToSort);</span><br><span class="line">    System.out.println(<span class="string">"排序后"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayToSort.length; i++)</span><br><span class="line">        System.out.println(arrayToSort[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="数组与list转换">数组与list转换</span><a href="#数组与list转换" class="header-anchor"> </a></h3>
<h4><span id="数组转list">数组转list</span><a href="#数组转list" class="header-anchor"> </a></h4>
<blockquote>
<p>调用<code>Arrays.asList()</code>方法：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strings = str.split(<span class="string">" "</span>);</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(strings);</span><br></pre></td></tr></table></figure>
<h4><span id="list转数组">list转数组</span><a href="#list转数组" class="header-anchor"> </a></h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"1"</span>);</span><br><span class="line">list.add(<span class="string">"2"</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> size =  list.size();</span><br><span class="line">String[] arr = (String[])list.toArray(<span class="keyword">new</span> String[size]);</span><br></pre></td></tr></table></figure>
<h2><span id="数字">数字</span><a href="#数字" class="header-anchor"> </a></h2>
<h3><span id="比大小">比大小</span><a href="#比大小" class="header-anchor"> </a></h3>
<p>Math.max(int a, int b);
Math.max(float a, float b);
Math.min(int a, int b);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMain</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(Math.max(a,b));</span><br><span class="line">        System.out.println(Math.min(a,b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="hash">Hash</span><a href="#hash" class="header-anchor"> </a></h2>
<h3><span id="hashmap-put返回值">hashMap put返回值</span><a href="#hashmap-put返回值" class="header-anchor"> </a></h3>
<p>在做leetcode 中 205. Isomorphic Strings这道题时，看到 discuss 中，有用到 map.put(key, value)的返回值，后查看了一下源码。其返回值为之前存进去key对应的value。</p>
<blockquote>
<p>jdk源码注释
@return the previous value associated with <tt>key</tt>, or<tt>null</tt> if there was no mapping for<tt>key</tt>. (A <tt>null</tt> return can also indicate that the map previously associated <tt>null</tt> with <tt>key</tt>,if the implementation supports <tt>null</tt> values.)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;Character,Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    System.out.println(m.put(<span class="string">'a'</span>,<span class="number">2</span>));</span><br><span class="line">    System.out.println(m.put(<span class="string">'b'</span>,<span class="number">3</span>));</span><br><span class="line">    System.out.println(m.put(<span class="string">'a'</span>,<span class="number">1</span>));</span><br><span class="line">    System.out.println(m.put(<span class="string">'a'</span>,<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：null null 2 1</p>
<h2><span id="一些已经写好的数据结构">一些已经写好的数据结构</span><a href="#一些已经写好的数据结构" class="header-anchor"> </a></h2>
<p>最小堆 <code>PriorityQueue</code><br>
双端队列 <code>Deque deque = new LinkedList();</code></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub大礼包领取方式</title>
    <url>/2016/04/29/GitHub%E5%A4%A7%E7%A4%BC%E5%8C%85%E9%A2%86%E5%8F%96%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>GitHub是一个利用Git进行版本控制、专门用于存放软件代码与内容的共享虚拟主机服务。如今它推出了一款针对学生的优惠（<a href="https://education.github.com/pack" target="_blank" rel="noopener">GitHub学生大礼包</a>），里面包含了众多服务，其中比较吸引人的有<a href="https://cloud.digitalocean.com/" target="_blank" rel="noopener">DigitalOcean</a>虚拟主机（50刀优惠券，使用最便宜的套餐可以使用一年），<a href="https://nc.me/" target="_blank" rel="noopener">namecheap</a>（.me顶级域名一年，SSL证书一年），另外还有GitHub私有仓库、AWS、Microsoft Azure cloud services等，但是部分在领取礼包的时候需要绑定信用卡，没有信用卡的同学就暂时无法享受优惠了。下面开始正题，如何领取学生大礼包。</p>
<a id="more"></a>
<h2><span id="学生认证">学生认证</span><a href="#学生认证" class="header-anchor"> </a></h2>
<p>到<a href="https://github.com/settings/emails" target="_blank" rel="noopener">GitHub个人设置</a>中添加学生edu邮箱。如图<br>
<img src="/img/20160429/1.png" alt="添加邮箱"><br>
添加完毕后进入填写的校园邮箱打开GitHub发送的验证邮件进行验证，通过后进入下一步</p>
<h2><span id="填写申请">填写申请</span><a href="#填写申请" class="header-anchor"> </a></h2>
<p><a href="https://education.github.com/pack" target="_blank" rel="noopener">GitHub学生大礼包申请地址</a>，点击黄色大书包的<strong>Get your pack</strong><br>
<img src="/img/20160429/2.jpg" alt="申请"></p>
<h2><span id="填写详细资料">填写详细资料</span><a href="#填写详细资料" class="header-anchor"> </a></h2>
<p>在Verify academic status中选择刚验证通过的edu邮箱<br>
<img src="/img/20160429/3.jpg" alt="填写邮箱"></p>
<h2><span id="确认并等待结果">确认并等待结果</span><a href="#确认并等待结果" class="header-anchor"> </a></h2>
<p>填写完毕后，点击提交。此时页面中会显示审核进度，<a href="https://education.github.com/discount_requests/new" target="_blank" rel="noopener">审核进度查询</a>
<img src="/img/20160429/4.jpg" alt="进度查询">
进度中显示Approved时，就可以回到一开始的黄色大书包界面，点击<strong>Get your pack</strong>获得各项优惠，其中GitHub自动会升级成可建5个私有仓库的等级。同时GitHub也会发送邮件提示已经升级成功。</p>
<blockquote>
<p>Hey xxx, we have some awesome news</p>
<p>We’ve upgraded you to a Micro plan, which will be free for the next two years. After that, you’ll get an email saying that your coupon is expiring. You can reapply for another coupon if you still have academic status. We don’t have any collaboration limits, so any group projects you may encounter can be hosted via your account.</p>
<p>If you need help getting started with Git and GitHub, check out:</p>
<p><a href="https://help.github.com/articles/good-resources-for-learning-git-and-github" target="_blank" rel="noopener">https://help.github.com/articles/good-resources-for-learning-git-and-github</a></p>
<p>We’ve also given you access to the Student Developer Pack, available at:</p>
<p><a href="https://education.github.com/pack" target="_blank" rel="noopener">https://education.github.com/pack</a></p>
<p>If you have any questions, contact us:</p>
<p><a href="https://education.github.com/contact" target="_blank" rel="noopener">https://education.github.com/contact</a></p>
<p>Spread the word: we love giving educational discounts to students, teachers, administrators, and researchers! Please send them to:</p>
<p><a href="https://education.github.com" target="_blank" rel="noopener">https://education.github.com</a><br>
Have an Octotastic day!<br>
– The GitHub Education Team</p>
</blockquote>
<h2><span id="edu邮箱被秒拒解决办法">edu邮箱被秒拒解决办法</span><a href="#edu邮箱被秒拒解决办法" class="header-anchor"> </a></h2>
<p>目前网上很多同学反馈使用edu邮箱会被系统秒拒，同时我也遇到这种情况。此时，我们在申请的时候，在<strong>Verify academic status</strong>中选择我没有edu邮箱，然后上传自己的学生证照片即可，GitHub应该会进行人工审核。我第一次使用edu邮箱被秒拒后，上传了学生证照片，第二天上午就收到GitHub审核通过的消息。</p>
<p><strong>最后，祝大家好运！</strong></p>
]]></content>
      <categories>
        <category>应用开发</category>
      </categories>
  </entry>
  <entry>
    <title>学生会主席团竞选演讲稿</title>
    <url>/2016/04/22/%E5%AD%A6%E7%94%9F%E4%BC%9A%E4%B8%BB%E5%B8%AD%E5%9B%A2%E7%AB%9E%E9%80%89%E6%BC%94%E8%AE%B2%E7%A8%BF/</url>
    <content><![CDATA[<p>这篇演讲稿是大三竞选学院团总支学生会主席团时所用，由于当时修改直接在稿纸上进行，但未同时更新电子档，部分内容有所缺失，主要少了讲述承担校运会火炬组任务部分。</p>
<a id="more"></a>
<hr>
<p>Hello! SCIE!<br>
尊敬的领导、老师，亲爱的同学们：<br>
　　大家下午好！<br>
　　很荣幸能在这里参加通信主席团换届选举大会。我是12级6班的张天乐，现任学生会美宣部副部长一职。<br>
　　回望过去两年，通信骄傲，年度总结表彰大会，校运会……我们每一个通信人共同见证了通信的成长。在这个团体中，我们一起奋斗，一起努力。<br>
　　在这两年中，我获得校优秀青年志愿者，优秀宣传委员，同时还连续两年获得校优秀共青团干部。在担任学生干部的同时，我还多次带领团队参加各类科技竞赛，获全国大学生数学竞赛、合泰杯单片机竞赛等近二十余奖项。让我逐渐养成了良好的团队协作能力，组织领导能力。但这些都不是个事儿，成绩已经代表过去，未来的路还很漫长，在今后我将更加努力，使自己的能力进一步提高。<br>
　　在本学期的校运会开幕式上，我们全体通信人为重邮带来一份极致的视觉体验。各个板块都有同学们的辛勤付出。当然，我们不会忘记可爱的老师们，陪着大家一起训练，耐心指导，在这里，我想对为校运会付出的老师同学们说句谢谢，通信有你们更完美。<br>
通信精神：<br>
　　我们想要传承的，是一个团结的团总支学生会，心灵贴着心灵，就是月亮阳光，身躯靠紧身躯，就是座座山峰。<br>
　　我们想要传承的，是一个高效的团总支学生会，拥有众多精英骨干。十多个部门有条不紊的工作，保证按时出色的完成每一项任务。<br>
　　我们想要传承的，是一个务实的团总支学生会，“大人不华，君子务实”，求真务实，是团总支学生会人的根本要求，也是做好一切工作的根本保证。<br>
　　我们想要传承的，是一个创新的团总支学生会，创新是一个民族进步的灵魂，是我们学院发展的不竭动力。通信同心，敢闯敢拼，齐心协力，信创辉煌！<br>
　　那正是我们所期望的，是我们共有的愿景。这也是我一直认真工作的信念。<br>
　　在快节奏的今天，我致力于打造一个高效、信息化的团总支学生会。从大一上学期开始，我有幸加入实验室，参与近十余项项目开发。积累了程序开发，团队协作等经验。并且，我将所学到的知识运用到团总支学生会的工作中去，得到同事乃至老师的一致好评。同时，我美宣部率先使用网盘管理制度，拥有微软word文档协同编辑平台，百度开发者平台。同时注重自媒体宣传，拥有新浪微博，腾讯微信等。这些平台大大提高了部门的工作效率。我们部门特色的PS平面设计，都已经达到或者超过了广告公司的作品，在校运会的海报中，全部选用了我们部门干事设计的作品，当然这和我们干事的努力学习和工作是分不开的。<br>
　　在之前的工作中，我们和大家的沟通不是十分通畅，有些消息也不能准确的传达，以致于很多同学对我们团总支学生会有误解，都认为在压榨学生团体。在此，我向大家致以歉意。但是我们在不断的改革与创新，力求进步。今天若能得到大家的支持，进入主席团，我会更加进一步加强团总支学生会的信息化建设，打造更加高效，透明，愉悦的工作平台。联络、整合实验室最新科研成果，并“本地化”加以改进创新，统一高效管理团总支学生会事务，统一规划目前比较零散的学院自媒体宣传平台，及时加强老师和同学们的信息沟通，保证消息准确到达。革命的道路总是布满荆棘的，请给我时间与平台，我会用切实的行动把团总支学生会建立成为学院领导、老师与学生之间心灵的桥梁，成为师生的纽带，成为真正的为同学服务，同学们真正爱它的团体。<br>
　　今天，你们的投票换来的将会是积极的行动，这一切都是公开、公平的。你们选择我，我将始终坚持“欲戴王冠，必承其重”的信念，与学院领导、老师、团总支学生会的各位成员，以及各位同学进行全面的接触与合作，携手创建更加美好的通信学院！我是张天乐，谢谢大家对我的支持！谢谢！</p>
<blockquote>
<p>该演讲稿得到众多朋友的帮助，特别是自律权益部副部长小倩同学，在此表示非常感谢！</p>
</blockquote>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>学生会</tag>
      </tags>
  </entry>
  <entry>
    <title>Java异常处理</title>
    <url>/2016/04/16/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3><span id="异常介绍">异常介绍</span><a href="#异常介绍" class="header-anchor"> </a></h3>
<p>异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。
比如说，你的代码少了一个分号，那么运行出来结果是提示是错误java.lang.Error；如果你用System.out.println(11/0)，那么你是因为你用0做了除数，会抛出java.lang.ArithmeticException的异常。</p>
<a id="more"></a>
<p><em>异常发生的原因有很多，通常包含以下几大类：</em></p>
<ul>
<li>用户输入了非法数据。</li>
<li>要打开的文件不存在。</li>
<li>网络通信时连接中断，或者JVM内存溢出。</li>
</ul>
<p>这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。</p>
<p><em>要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：</em></p>
<ul>
<li><strong>检查性异常：</strong> 最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li>
<li><strong>运行时异常：</strong> 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>
<li><strong>错误：</strong> 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li>
</ul>
<hr>
<h4><span id="异常分类">异常分类</span><a href="#异常分类" class="header-anchor"> </a></h4>
<ol>
<li>
<p>非运行时异常(Checked Exception)
Java中凡是继承自Exception但不是继承自RuntimeException的类都是非运行时异常。</p>
</li>
<li>
<p>运行时异常（Runtime Exception/Unchecked Exception）
RuntimeException类直接继承自Exception类，称为运行时异常。Java中所有的运行时异常都直接或间接的继承自RuntimeException。</p>
</li>
</ol>
<p>Java中所有的异常类都直接或间接的继承自Exception。</p>
<h3><span id="声明自定义异常">声明自定义异常</span><a href="#声明自定义异常" class="header-anchor"> </a></h3>
<p>使用自定义异常有什么好处呢？为何要定义新异常类型？创建自定义异常是为了表示应用程序的一些错误类型，为代码可能发生的一个或多个问题提供新含义。可以显示代码多个位置之间的错误的相似性，也可区分代码运行时可能出现的相似问题的一个或多个错误，或给出应用程序中一组错误的特定含义。</p>
<p>例如，考虑任何类型的服务器。服务器的基本作用是处理与客户机的通信。若使用标准Java API(如java.io和java.net包中的类)来编写服务器，则可使编写的代码在多个位置抛IOException。 在设置服务器、等待客户机连接和获取通信流时，可抛出IOExceptions；在通信期间及试图断开连接时，也可抛出IOExceptions。简言之，服务器的各个部分都可能引发IOException。</p>
<p>对服务器而言，这些IOException意义不尽相同。虽然由同一异常类型表示，但与各个异常相关的业务含义存在差异，报告和恢复操作亦有不同。可以将一个异常集与服务器配置和启动问题关联，将另一个异常集与客户机通信的实际行动关联，将第三个异常集与服务器关闭任务关联。使用自定义异常，可采用对应用程序有意义的方式来灵活地表示错误。</p>
<p>在Java中你可以自定义异常。编写自己的异常类时需要记住下面的几点。</p>
<ul>
<li>所有异常都必须是Throwable的子类。</li>
<li>如果希望写一个检查性异常类，则需要继承Exception类。</li>
<li>如果你想写一个运行时异常类，那么需要继承RuntimeException 类。</li>
</ul>
<p>Java自定义异常的使用要经历如下四个步骤：</p>
<ol>
<li>定义一个类继承Throwable或其子类。</li>
<li>添加构造方法(当然也可以不用添加，使用默认构造方法)。</li>
<li>在某个方法类抛出该异常。</li>
<li>捕捉该异常。</li>
</ol>
<p><em>可以像下面这样定义自己的异常类：</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 自定义异常 继承Exception类 **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> MyException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"该值不能为0......."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println( i / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.display(<span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>应用开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>一位父亲的心声</title>
    <url>/2016/02/04/%E4%B8%80%E4%BD%8D%E7%88%B6%E4%BA%B2%E7%9A%84%E5%BF%83%E5%A3%B0/</url>
    <content><![CDATA[<blockquote>
<p>在家庭中，一般为人父母者，也很喜欢责备小孩。在责备之前，请读一篇有名的文章——《一位父亲的心声》。</p>
</blockquote>
<a id="more"></a>  
<p>听着，孩子，我有一些话想要对你说。此时你睡得正熟，一只小手掌压在脸颊下，你的额头微湿，蜷曲的金发贴在上面。我偷偷溜进你的房间，因为刚才在书房看报的时候，内心不断地受到斥责，终于带着愧疚的心情来到你的床前。<br>
　　我的面前浮现了许多事，孩子。我常常对你发脾气。早上你穿好衣服准备上学，胡乱用毛巾在脸上碰一下，我责备你；你没有把鞋子擦干净，我责备你要；看到你把东西乱扔，我更生气地对你吼叫。<br>
　　早餐的时候也一样，我常骂你打翻东西、吃饭不细嚼慢咽、把两肘放在桌上、奶油涂得太厚等等。等到你离 开餐桌去玩，我也准备出门，你转过身，挥着小手喊：“再见，爸爸！”我仍皱着眉头回答：“肩膀挺正！”<br>
　　到了傍晚，情况还是一样。我走在路上，偷偷观察你，看见你跪在地上玩玻璃弹珠，脚上的长袜都磨破了。我不顾你的颜面，当着别的孩子的面叫你回家。并对你吼道，长袜子是很贵的，你要穿就得爱惜一点！想想看，孩子，这话居然出自为人之父的口里！<br>
　　记得吗？就是刚才，我在书房里看报，你怯生生的走过来，眼里带着惊惶的神色，站在门口踌躇不前。我从报端上望过去，不耐烦地叫道：“你要做什么？”<br>
　　你不说一句话，只是快步跑过来，双手搂住我的脖子亲吻。你小手臂的力量显示出一份爱，那是上帝种在你心田里的，任何漠视都不能使它凋萎。你吻过我就走了，吧嗒吧嗒地跑上楼。<br>
　　孩子，就是那时候，报纸从我手中滑落，我突然觉得害怕。我怎么养成了一个坏习惯呀！挑错、呵斥的习惯—这就是我对待一个小男孩的方法！孩子，不是我不爱你，只是我对你期望过高，不自觉地用自己年龄的标准去衡量你了。<br>
　　其实，你的本性里有许多真善美。你小小的心灵就像刚从山头升起的阳光一样无限，这一点可以从你天真自然、不顾一切跑过来亲吻、道晚安的动作看出来。孩子，今晚其余的一切都不重要了，我在黑暗中跪到你床边，深觉愧疚！<br>
　　这是一种无力的赎罪。我知道你未必懂得我所说的一切。但是，从明天起，我会认真地做一个真正的父亲！要和你结为好朋友，你痛苦的时候同你一起痛苦，欢乐的时候同你一起欢笑。我会每天告诉自己：“他只不过是个男孩—一个小男孩！”<br>
　　我实在不该把你当成大人，孩子，像我现在看到的你，疲倦地蜷缩在床上，完全还是婴孩的模样。记得昨天你还躺在妈妈怀里，头靠在妈妈肩上，我要求的实在太多太多了。</p>
<blockquote>
<p>让我们尽量去了解别人，而不要用责骂的方式吧！让我们尽量设身处地地去想—他们为什么要这样做。这比起批评责怪还要有益、有趣得多，而且还让人心生同情、忍耐和仁慈。</p>
</blockquote>
]]></content>
      <categories>
        <category>摘抄</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>spring,mybatis事务管理配置与@Transactional注解使用</title>
    <url>/2016/01/17/spring-mybatis%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE%E4%B8%8E-Transactional%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>【转】 <a href="http://openwares.net/java/spring_mybatis_transaction.html" target="_blank" rel="noopener">来自： spring,mybatis事务管理配置与@Transactional注解使用</a></p>
<h2><span id="概述">概述</span><a href="#概述" class="header-anchor"> </a></h2>
<p>事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<a id="more"></a>
<p>Spring Framework对事务管理提供了一致的抽象，其特点如下：</p>
<ul>
<li>为不同的事务API提供一致的编程模型，比如JTA(Java Transaction API), JDBC, Hibernate, JPA(Java Persistence API和JDO(Java Data Objects)</li>
<li>支持声明式事务管理，特别是基于注解的声明式事务管理，简单易用</li>
<li>提供比其他事务API如JTA更简单的编程式事务管理API</li>
<li>与spring数据访问抽象的完美集成</li>
</ul>
<h2><span id="事务管理方式">事务管理方式</span><a href="#事务管理方式" class="header-anchor"> </a></h2>
<p>spring支持编程式事务管理和声明式事务管理两种方式。</p>
<p>编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。</p>
<p>声明式事务管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中。</p>
<p>显然声明式事务管理要优于编程式事务管理，这正是spring倡导的非侵入式的开发方式。声明式事务管理使业务代码不受污染，一个普通的POJO对象，只要加上注解就可以获得完全的事务支持。和编程式事务相比，声明式事务唯一不足地方是，后者的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。但是即便有这样的需求，也存在很多变通的方法，比如，可以将需要进行事务管理的代码块独立为方法等等。</p>
<p>声明式事务管理也有两种常用的方式，一种是基于tx和aop名字空间的xml配置文件，另一种就是基于@Transactional注解。显然基于注解的方式更简单易用，更清爽。</p>
<h2><span id="自动提交autocommit与连接关闭时的是否自动提交">自动提交(AutoCommit)与连接关闭时的是否自动提交</span><a href="#自动提交autocommit与连接关闭时的是否自动提交" class="header-anchor"> </a></h2>
<p><em>自动提交</em></p>
<p>默认情况下，数据库处于自动提交模式。每一条语句处于一个单独的事务中，在这条语句执行完毕时，如果执行成功则隐式的提交事务，如果
执行失败则隐式的回滚事务。</p>
<p>对于正常的事务管理，是一组相关的操作处于一个事务之中，因此必须关闭数据库的自动提交模式。不过，这个我们不用担心，spring会将底层连接的自动提交特性设置为false。
org/springframework/jdbc/datasource/DataSourceTransactionManager.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// switch to manual commit if necessary. this is very expensive in some jdbc drivers,</span></span><br><span class="line"><span class="comment">// so we don't want to do it unnecessarily (for example if we've explicitly</span></span><br><span class="line"><span class="comment">// configured the connection pool to set it already).</span></span><br><span class="line"><span class="keyword">if</span> (con.getautocommit()) &#123;</span><br><span class="line">    txobject.setmustrestoreautocommit(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isdebugenabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"switching jdbc connection ["</span> + con + <span class="string">"] to manual commit"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    con.setautocommit(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有些数据连接池提供了关闭事务自动提交的设置，最好在设置连接池时就将其关闭。但C3P0没有提供这一特性，只能依靠spring来设置。
因为JDBC规范规定，当连接对象建立时应该处于自动提交模式，这是跨DBMS的缺省值，如果需要,必须显式的关闭自动提交。C3P0遵守这一规范，让客户代码来显式的设置需要的提交模式。</p>
<p><em>连接关闭时的是否自动提交</em></p>
<p>当一个连接关闭时，如果有未提交的事务应该如何处理？JDBC规范没有提及，C3P0默认的策略是回滚任何未提交的事务。这是一个正确的策略，但JDBC驱动提供商之间对此问题并没有达成一致。
C3P0的autoCommitOnClose属性默认是false,没有十分必要不要动它。或者可以显式的设置此属性为false，这样会更明确。</p>
<h2><span id="基于注解的声明式事务管理配置">基于注解的声明式事务管理配置</span><a href="#基于注解的声明式事务管理配置" class="header-anchor"> </a></h2>
<p>spring-servlet.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- transaction support--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- PlatformTransactionMnager --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- enable transaction annotation support --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"txManager"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>还要在spring-servlet.xml中添加tx名字空间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:tx="http://www.springframework.org/schema/tx"</span><br><span class="line">xmlns:aop="http://www.springframework.org/schema/aop"</span><br><span class="line">xsi:schemaLocation="</span><br><span class="line">...</span><br><span class="line">http://www.springframework.org/schema/tx</span><br><span class="line">http://www.springframework.org/schema/tx/spring-tx.xsd</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>MyBatis自动参与到spring事务管理中，无需额外配置，只要org.mybatis.spring.SqlSessionFactoryBean引用的数据源与DataSourceTransactionManager引用的数据源一致即可，否则事务管理会不起作用。</p>
<p>另外需要下载依赖包aopalliance.jar放置到WEB-INF/lib目录下。否则spring初始化时会报异常
java.lang.NoClassDefFoundError: org/aopalliance/intercept/MethodInterceptor</p>
<h2><span id="spring事务特性">spring事务特性</span><a href="#spring事务特性" class="header-anchor"> </a></h2>
<p>spring所有的事务管理策略类都继承自org.springframework.transaction.PlatformTransactionManager接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中TransactionDefinition接口定义以下特性：</p>
<p><em>事务隔离级别</em></p>
<p>隔离级别是指若干个并发的事务之间的隔离程度。TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p>
<ul>
<li>
<p>TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。</p>
</li>
<li>
<p>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。</p>
</li>
<li>
<p>TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。</p>
</li>
<li>
<p>TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。</p>
</li>
<li>
<p>TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。
<em>事务传播行为</em></p>
</li>
<li>
<p>所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在TransactionDefinition定义中包括了如下几个表示传播行为的常量：</p>
</li>
<li>
<p>TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。</p>
</li>
<li>
<p>TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</p>
</li>
<li>
<p>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</p>
</li>
<li>
<p>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p>
</li>
<li>
<p>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</p>
</li>
<li>
<p>TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</p>
</li>
<li>
<p>TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。
<em>事务超时</em></p>
</li>
</ul>
<p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。</p>
<p>默认设置为底层事务系统的超时值，如果底层数据库事务系统没有设置超时值，那么就是none，没有超时限制。</p>
<p><em>事务只读属性</em></p>
<p>只读事务用于客户代码只读但不修改数据的情形，只读事务用于特定情景下的优化，比如使用Hibernate的时候。
默认为读写事务。</p>
<h2><span id="spring事务回滚规则">spring事务回滚规则</span><a href="#spring事务回滚规则" class="header-anchor"> </a></h2>
<p>指示spring事务管理器回滚一个事务的推荐方法是在当前事务的上下文内抛出异常。spring事务管理器会捕捉任何未处理的异常，然后依据规则决定是否回滚抛出异常的事务。</p>
<p>默认配置下，spring只有在抛出的异常为运行时unchecked异常时才回滚该事务，也就是抛出的异常为RuntimeException的子类(Errors也会导致事务回滚)，而抛出checked异常则不会导致事务回滚。
可以明确的配置在抛出那些异常时回滚事务，包括checked异常。也可以明确定义那些异常抛出时不回滚事务。</p>
<p>还可以编程性的通过setRollbackOnly()方法来指示一个事务必须回滚，在调用完setRollbackOnly()后你所能执行的唯一操作就是回滚。</p>
<h2><span id="transactional注解">@Transactional注解</span><a href="#transactional注解" class="header-anchor"> </a></h2>
<p><em>@Transactional属性</em></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td>String</td>
<td>可选的限定描述符，指定使用的事务管理器</td>
</tr>
<tr>
<td>propagation</td>
<td>enum: Propagation</td>
<td>可选的事务传播行为设置</td>
</tr>
<tr>
<td>isolation</td>
<td>enum: Isolation</td>
<td>可选的事务隔离级别设置</td>
</tr>
<tr>
<td>readOnly</td>
<td>boolean</td>
<td>读写或只读事务，默认读写</td>
</tr>
<tr>
<td>timeout</td>
<td>int (in seconds granularity)</td>
<td>事务超时时间设置</td>
</tr>
<tr>
<td>rollbackFor</td>
<td>Class对象数组，必须继承自Throwable</td>
<td>导致事务回滚的异常类数组</td>
</tr>
<tr>
<td>rollbackForClassName</td>
<td>类名数组，必须继承自Throwable</td>
<td>导致事务回滚的异常类名字数组</td>
</tr>
<tr>
<td>noRollbackFor</td>
<td>Class对象数组，必须继承自Throwable</td>
<td>不会导致事务回滚的异常类数组</td>
</tr>
<tr>
<td>noRollbackForClassName</td>
<td>类名数组，必须继承自Throwable</td>
<td>不会导致事务回滚的异常类名字数组</td>
</tr>
</tbody>
</table>
<p>用法</p>
<p>@Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</p>
<p>虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。</p>
<p>默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(readOnly = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFooService</span> <span class="keyword">implements</span> <span class="title">FooService</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Foo <span class="title">getFoo</span><span class="params">(String fooName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// these settings have precedence for this method</span></span><br><span class="line">  <span class="comment">//方法上注解属性会覆盖类注解上的相同属性</span></span><br><span class="line">  <span class="meta">@Transactional</span>(readOnly = <span class="keyword">false</span>, propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFoo</span><span class="params">(Foo foo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考
<a href="http://docs.spring.io/spring/docs/3.2.4.RELEASE/spring-framework-reference/html/transaction.html" target="_blank" rel="noopener">Transaction Management</a></p>
]]></content>
      <categories>
        <category>应用开发</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring websocket开发</title>
    <url>/2015/12/17/spring-websocket%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2><span id="零-总体介绍">零、总体介绍</span><a href="#零-总体介绍" class="header-anchor"> </a></h2>
<h3><span id="项目背景">项目背景</span><a href="#项目背景" class="header-anchor"> </a></h3>
<p>该项目是学校通信软件开发实训课程的一门作业，要求完成一个聊天系统，但要求有至少一个亮点，无论是功能上的还是技术上的。
我们小组比较擅长Java Web开发，因此决定在技术上做一个亮点，使用WebSocket</p>
<a id="more"></a>
<h3><span id="文档说明">文档说明</span><a href="#文档说明" class="header-anchor"> </a></h3>
<p>该文档按照如下顺序进行介绍</p>
<ol>
<li>技术背景
介绍该项目要用到的一些背景知识</li>
<li>项目目录结构
该项目使用myeclipse的Java EE项目，大体上可分为前台与后台</li>
<li>项目框架搭建
介绍前台用到的技术，以及后台框架的搭建</li>
<li>项目成果展示</li>
<li>代码分享</li>
</ol>
<h2><span id="一-技术背景">一、技术背景</span><a href="#一-技术背景" class="header-anchor"> </a></h2>
<h3><span id="1websocket">1.WebSocket</span><a href="#1websocket" class="header-anchor"> </a></h3>
<p>WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。WebSocket通讯协议于2011年被IETF定为标准RFC 6455，WebSocketAPI被W3C定为标准。
在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p>
<h3><span id="2spring">2.Spring</span><a href="#2spring" class="header-anchor"> </a></h3>
<p>Spring是一个开源轻量级的框架，使用控制反转（IoC）和面向切面（AOP），它可以让开发变得简单、轻便、快速与更加灵活。</p>
<h3><span id="3spring-websocket">3.Spring WebSocket</span><a href="#3spring-websocket" class="header-anchor"> </a></h3>
<p>Spring从4.0开始加入了spring-websocket这个模块，并能够全面支持WebSocket，它与Java WebSocket API标准（JSR-356）保持一致，同时提供了额外的服务。</p>
<h3><span id="4spring-mvc">4.Spring MVC</span><a href="#4spring-mvc" class="header-anchor"> </a></h3>
<p>Spring MVC是一个model-view-controller（MVC）框架，能很好地将数据、业务与展现进行分离。Spring MVC的设计是围绕DispatcherServlet展开的，DispatcherServlet负责将请求派发到特定的handler。</p>
<h3><span id="5mybatis">5.MyBatis</span><a href="#5mybatis" class="header-anchor"> </a></h3>
<p>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>
<p><strong>在本项目中，我们使用了以上几个框架进行搭建。</strong></p>
<h2><span id="二-目录结构">二、目录结构</span><a href="#二-目录结构" class="header-anchor"> </a></h2>
<ul>
<li>
<p>Com.tx.
Config websocket配置文件
Controller spring mvc 控制层
DAO 数据库连接操作
Handler websocket操作
Model 数据实体
Service 服务器处理
Tool 工具类</p>
</li>
<li>
<p>Webroot
前台代码目录
Js javascript代码
Style css代码
Test 前台测试代码</p>
</li>
<li>
<p>WEN-INF 配置文件夹
Jsp jsp文件夹
Lib 项目所需的外部jar包
As-servlet.xml spring mvc 配置文件
Web.xml web项目配置文件</p>
</li>
</ul>
<p><img src="//img.tianle.me/image/20151217/spring.png" alt="目录结构"></p>
<h2><span id="三-实验步骤">三、实验步骤</span><a href="#三-实验步骤" class="header-anchor"> </a></h2>
<h3><span id="web服务前端">web服务前端</span><a href="#web服务前端" class="header-anchor"> </a></h3>
<h4><span id="1-socket相关代码结构">1、socket相关代码结构</span><a href="#1-socket相关代码结构" class="header-anchor"> </a></h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> Socket(url);<span class="comment">//url必须为ws://开头的相关协议</span></span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//连接初始化代码</span></span><br><span class="line">&#125;;</span><br><span class="line">sokcet.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> text = event.data;</span><br><span class="line">	<span class="comment">//处理接受到的消息</span></span><br><span class="line">&#125;;</span><br><span class="line">socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//连接关闭时触发</span></span><br><span class="line">&#125;;</span><br><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//连接过程中出错时触发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="2本次实验所封装的一些函数的解析">2.本次实验所封装的一些函数的解析</span><a href="#2本次实验所封装的一些函数的解析" class="header-anchor"> </a></h4>
<ol>
<li>消息封装函数，用于生成能直接添加到html的dom节点的文档类型</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">messagePackage</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     message&#123;</span></span><br><span class="line"><span class="comment">     userName : xx,</span></span><br><span class="line"><span class="comment">     timeSign : 22:12:44,</span></span><br><span class="line"><span class="comment">     content : abc</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> element_section = $(<span class="string">"&lt;section&gt;&lt;/section&gt;"</span>);</span><br><span class="line">    <span class="keyword">var</span> element_section_p1 = $(<span class="string">"&lt;p&gt;&lt;/p&gt;"</span>);</span><br><span class="line">    <span class="keyword">var</span> element_section_p1_user = $(<span class="string">"&lt;span&gt;&lt;/span&gt;"</span>);</span><br><span class="line">    <span class="keyword">var</span> element_section_p1_time = $(<span class="string">"&lt;time&gt;&lt;/time&gt;"</span>);</span><br><span class="line">    <span class="keyword">var</span> element_section_p2_content = $(<span class="string">"&lt;p&gt;&lt;/p&gt;"</span>);</span><br><span class="line">    element_section.addClass(<span class="string">"message"</span>);</span><br><span class="line">    element_section_p1.addClass(<span class="string">"header"</span>);</span><br><span class="line">    element_section_p2_content.addClass(<span class="string">"content"</span>);</span><br><span class="line">    element_section_p1_user.text(message.username);</span><br><span class="line">    element_section_p1_time.text(message.timeSign);</span><br><span class="line">    element_section_p2_content.text(message.content);</span><br><span class="line">    element_section_p1.append(element_section_p1_user);</span><br><span class="line">    element_section_p1.append(element_section_p1_time);</span><br><span class="line">    element_section.append(element_section_p1);</span><br><span class="line">    element_section.append(element_section_p2_content);</span><br><span class="line">    <span class="keyword">return</span> element_section;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>消息处理函数，用于处理onmessage中由服务器发送到客户端的消息，并规定了消息类型与相关的处理方式</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">jsonData : &#123;</span></span><br><span class="line"><span class="comment">    type:1(聊天信息)||2(用户列表更新信息),</span></span><br><span class="line"><span class="comment">    username(1,2):xx,</span></span><br><span class="line"><span class="comment">    timeSign(1):xx:xx:xx,</span></span><br><span class="line"><span class="comment">    content(1):xxxxxxxxxxxxx,</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">messageHandle</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> jsonStr = event.data;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(jsonStr);</span><br><span class="line">    <span class="keyword">var</span> $message = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">switch</span>(data.type) &#123;</span><br><span class="line">        <span class="comment">//更新聊天显示框</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span>(data.username == currentUser) <span class="keyword">return</span>;</span><br><span class="line">            $message = messagePackage(&#123;</span><br><span class="line">               username : data.username,</span><br><span class="line">                timeSign : data.timeSign,</span><br><span class="line">                content : data.content</span><br><span class="line">            &#125;);</span><br><span class="line">            $show.append($message);</span><br><span class="line">            <span class="comment">//让滚动条自动滚到底</span></span><br><span class="line">            $show.get(<span class="number">0</span>).scrollTop = $show.get(<span class="number">0</span>).scrollHeight;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//向已经在线的用户发送用户列表更新信息</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">var</span> $userName = $(<span class="string">"&lt;p&gt;&lt;/p&gt;"</span>);</span><br><span class="line">            $userName.text(data.username);</span><br><span class="line">            $(<span class="string">"#usersInfo"</span>).append($userName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//将所有已经在线的用户信息发送给刚加入的用户</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">var</span> usernames = data.usernames;</span><br><span class="line">            <span class="keyword">var</span> $usersInfo = $(<span class="string">"#usersInfo"</span>);</span><br><span class="line">            $usersInfo.empty();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i= <span class="number">0</span>,len=usernames.length;i&lt;len;i++) &#123;</span><br><span class="line">                <span class="keyword">var</span> $userName = $(<span class="string">"&lt;p&gt;&lt;/p&gt;"</span>);</span><br><span class="line">                $userName.text(usernames[i]);</span><br><span class="line">                $usersInfo.append($userName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//删除用户信息</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">var</span> $usersInfo = $(<span class="string">"#usersInfo"</span>);</span><br><span class="line">            $usersInfo.find(<span class="string">":contains("</span>+data.username+<span class="string">")"</span>).remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="spring-amp-spring-mvc配置">Spring &amp; Spring MVC配置</span><a href="#spring-amp-spring-mvc配置" class="header-anchor"> </a></h3>
<h4><span id="1-webxml-配置">1、Web.xml 配置</span><a href="#1-webxml-配置" class="header-anchor"> </a></h4>
<p>配置spring 过滤器 并设置UTF-8编码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置servlet spring mvc拦截器 <a href="http://xn--siqq5jgsada4806c1sap30elfk.do" target="_blank" rel="noopener">设置匹配后缀名为.do</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">display-name</span>&gt;</span>as<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>as<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>as<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4><span id="2as-servletxml-配置spring-mvc">2.as-servlet.xml 配置Spring MVC</span><a href="#2as-servletxml-配置spring-mvc" class="header-anchor"> </a></h4>
<p>使用Spring注解的方式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.tx.*"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"handlerMapping"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>返回json模板</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageConverters"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>设置spring mvc视图</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span>	<span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.UrlBasedViewResolver"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"viewClass"</span> <span class="attr">value</span>=<span class="string">"org.springframework.web.servlet.view.JstlView"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4><span id="3编写spring-mvc-controller">3.编写Spring MVC controller</span><a href="#3编写spring-mvc-controller" class="header-anchor"> </a></h4>
<p>controller用于接收和发送前后台的请求与响应
前后台定义用来传送的json字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">聊天消息：</span><br><span class="line">&apos;&#123;&quot;type&quot;:1,&quot;username&quot;:&quot;xxxx&quot;,&quot;timeSign&quot;:&quot;15:21:02&quot;,&quot;content&quot;:&quot;消息内容&quot;&#125;&apos;</span><br><span class="line">用户列表更新消息（已加入）:</span><br><span class="line">&apos;&#123;&quot;type&quot;:2,&quot;username&quot;:&quot;xxxx&quot;&#125;&apos;</span><br><span class="line"></span><br><span class="line">用户列表全部消息（刚加入）：</span><br><span class="line">&apos;&#123;&quot;type&quot;:3,&quot;usernames&quot;:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]&#125;&apos;</span><br><span class="line"></span><br><span class="line">用户列表某用户信息删除 :</span><br><span class="line">&#123;&quot;type&quot;:4,&quot;username&quot;:&quot;xx&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>本例以用户登录、注册为例，其余部分请参考页面最下方提供的源代码
这里使用了Spring MVC注解来进行请求的处理</p>
<blockquote>
<h5><span id="例">例：</span><a href="#例" class="header-anchor"> </a></h5>
<p><strong>@RequestMapping</strong>里面填写的是请求的地址
<strong>return</strong> 根据返回值的不同进行页面跳转等操作，这里返回 <strong>login</strong> 表示跳转到 <strong>login.jsp</strong> 这个页面</p>
</blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;login.do&quot;)</span><br><span class="line">public String gtLogin() &#123;</span><br><span class="line">	return &quot;login&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"register.do"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">gtRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"register"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"login.do"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">gtLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"loginServer.do"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">login</span><span class="params">(@RequestParam(<span class="string">"username"</span>)</span> String username,</span></span><br><span class="line"><span class="function">			@<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span> String password) </span>&#123;</span><br><span class="line"></span><br><span class="line">		ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">		StudentService ss = <span class="keyword">new</span> StudentService();</span><br><span class="line">		<span class="keyword">boolean</span> r = ss.login(username, password);</span><br><span class="line">		<span class="keyword">if</span> (r) &#123;</span><br><span class="line">			 modelAndView.addObject(<span class="string">"name"</span>, username);</span><br><span class="line">			 modelAndView.setViewName(<span class="string">"chat"</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			modelAndView.setViewName(<span class="string">"login"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> modelAndView;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(value = <span class="string">"registerServer.do"</span>, method = RequestMethod.POST)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">gtRegister</span><span class="params">(@RequestParam(<span class="string">"username"</span>)</span> String username,</span></span><br><span class="line"><span class="function">			@<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span> String password) </span>&#123;</span><br><span class="line">		StudentService ss = <span class="keyword">new</span> StudentService();</span><br><span class="line">		ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();  </span><br><span class="line">		<span class="keyword">boolean</span> r = ss.register(username, password);</span><br><span class="line">		<span class="keyword">if</span> (r) &#123;</span><br><span class="line">			 modelAndView.addObject(<span class="string">"name"</span>, username);  </span><br><span class="line">			 modelAndView.setViewName(<span class="string">"chat"</span>);  </span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			modelAndView.setViewName(<span class="string">"login"</span>);  </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> modelAndView;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="mybatis配置">Mybatis配置</span><a href="#mybatis配置" class="header-anchor"> </a></h3>
<blockquote>
<p><strong>有关mybatis的具体使用说明可以参考 <em><a href="http://mybatis.org/mybatis-3/zh/" title="Title" target="_blank" rel="noopener">mybatis文档</a></em></strong></p>
</blockquote>
<h4><span id="1建立与数据库表对应的modelpojo类">1.建立与数据库表对应的model，POJO类</span><a href="#1建立与数据库表对应的modelpojo类" class="header-anchor"> </a></h4>
<p>这里仅以Student.java类来说明:
类名同数据库中的表名一致，变量名同同数据库中的字段名一致，并编写get()和set()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tx.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> password;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.password = password;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="2mybatis-configxml设置">2.mybatis-config.xml设置</span><a href="#2mybatis-configxml设置" class="header-anchor"> </a></h4>
<p>我们使用xml来对mybatis数据库进行配置，里面包括：</p>
<ul>
<li>driver： 数据库驱动程序</li>
<li>url: 数据库连接地址及数据库名</li>
<li>username：数据库连接用户名</li>
<li>password：数据库连接密码</li>
</ul>
<ul>
<li>xml映射文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/chat"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/tx/model/mapping.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4><span id="3mappingxml设置">3.mapping.xml设置</span><a href="#3mappingxml设置" class="header-anchor"> </a></h4>
<p>mybatis的映射表，通过写sql语句来进行查询</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> </span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.tx.model.Mapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通过username获得密码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getpwd"</span> <span class="attr">parameterType</span>=<span class="string">"String"</span> <span class="attr">resultType</span>=<span class="string">"String"</span>&gt;</span></span><br><span class="line">      select stuPassword from student where stuName=#&#123;stuName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"register"</span> <span class="attr">parameterType</span>=<span class="string">"String"</span>&gt;</span></span><br><span class="line">    	insert into student (stuName, stuPassword) values (#&#123;stuName&#125;, #&#123;stuPassword&#125;) </span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3><span id="dao层代码">DAO层代码</span><a href="#dao层代码" class="header-anchor"> </a></h3>
<p>mybatis的映射文件，方法名与xml中的id相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tx.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mapper</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getpwd</span><span class="params">(String stuName)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">register</span><span class="params">(@Param(<span class="string">"stuName"</span>)</span>String stuName, @<span class="title">Param</span><span class="params">(<span class="string">"stuPassword"</span>)</span>String stuPassword)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DAO层，调用Mybatis的Mapper接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tx.DAO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tx.model.Mapper;</span><br><span class="line"><span class="keyword">import</span> com.tx.tools.Helper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDAO</span> </span>&#123;</span><br><span class="line">	SqlSession session = Helper.getSessionFactory().openSession();</span><br><span class="line">	Mapper mapper = session.getMapper(Mapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getpwd</span><span class="params">(String username)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mapper.getpwd(username);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">register</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">		SqlSession session = Helper.getSessionFactory().openSession();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Mapper mapper = session.getMapper(Mapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			result = mapper.register(name, password);</span><br><span class="line">			session.commit();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			session.close();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="service层代码">service层代码</span><a href="#service层代码" class="header-anchor"> </a></h3>
<p>service层调用DAO层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tx.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tx.DAO.StudentDAO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	StudentDAO sdao = <span class="keyword">new</span> StudentDAO();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (password.equals(sdao.getpwd(name))) &#123;</span><br><span class="line">			result = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">register</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(sdao.register(name, password) == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="spring-websocket配置">Spring websocket配置</span><a href="#spring-websocket配置" class="header-anchor"> </a></h3>
<h4><span id="1websocketconfigurer设置">1.WebSocketConfigurer设置</span><a href="#1websocketconfigurer设置" class="header-anchor"> </a></h4>
<p>注册Spring WebSocket服务</p>
<blockquote>
<p>其中registerWebSocketHandlers方法：
registry.addHandler(systemWebSocketHandler(),“xxx”);
xxx填写准备使用的WebSocket服务器请求地址，本项目中以 <a href="http://webSocketServer.do" target="_blank" rel="noopener">webSocketServer.do</a> 为例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tx.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.client.standard.WebSocketContainerFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocket;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tx.handler.SystemWebSocketHandler;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">		 registry.addHandler(systemWebSocketHandler(),<span class="string">"webSocketServer.do"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebSocketHandler <span class="title">systemWebSocketHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SystemWebSocketHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebSocketContainerFactoryBean <span class="title">createWebSocketContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WebSocketContainerFactoryBean container = <span class="keyword">new</span> WebSocketContainerFactoryBean();</span><br><span class="line">        container.setMaxTextMessageBufferSize(<span class="number">8192</span>);</span><br><span class="line">        container.setMaxBinaryMessageBufferSize(<span class="number">8192</span>);</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="2websockethandler设置">2.WebSocketHandler设置</span><a href="#2websockethandler设置" class="header-anchor"> </a></h4>
<p>服务器如何处理WebSocket请求在这里面填写</p>
<blockquote>
<p>成功建立连接
接收到消息处理
处理异常
连接关闭后</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemWebSocketHandler</span> <span class="keyword">implements</span> <span class="title">WebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"ConnectionEstablished"</span>);</span><br><span class="line">        <span class="comment">//TODO</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(WebSocketSession session,</span></span></span><br><span class="line"><span class="function"><span class="params">			WebSocketMessage&lt;?&gt; message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//TODO</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTransportError</span><span class="params">(WebSocketSession session,</span></span></span><br><span class="line"><span class="function"><span class="params">			Throwable exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//TODO</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionClosed</span><span class="params">(WebSocketSession session,</span></span></span><br><span class="line"><span class="function"><span class="params">			CloseStatus closeStatus)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"ConnectionClosed"</span>);</span><br><span class="line">		<span class="comment">//TODO</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsPartialMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="四-运行结果">四、运行结果</span><a href="#四-运行结果" class="header-anchor"> </a></h2>
<h3><span id="用户注册">用户注册</span><a href="#用户注册" class="header-anchor"> </a></h3>
<p>在浏览器中输入 <a href="http://localhost:8080/RealTimeChat/register.do" target="_blank" rel="noopener">http://localhost:8080/RealTimeChat/register.do</a>
<img src="//img.tianle.me/image/20151217/register.png" alt="注册界面">
填写用户名及密码后，点击注册按钮
注册成功后，自动跳转至聊天页面</p>
<h3><span id="聊天界面">聊天界面</span><a href="#聊天界面" class="header-anchor"> </a></h3>
<p><img src="//img.tianle.me/image/20151217/chat1.png" alt="聊天界面1">
顶部为当前登录用户
左上方为聊天室的聊天窗口
右上方为当前聊天室所有的在线用户
下方为用户的输入窗口</p>
<h3><span id="登录界面">登录界面</span><a href="#登录界面" class="header-anchor"> </a></h3>
<p>新用户登录 <a href="http://localhost:8080/RealTimeChat/login.do" target="_blank" rel="noopener">http://localhost:8080/RealTimeChat/login.do</a>
<img src="//img.tianle.me/image/20151217/login1.png" alt="登录界面"></p>
<h3><span id="多人聊天">多人聊天</span><a href="#多人聊天" class="header-anchor"> </a></h3>
<p>新用户加入
<img src="//img.tianle.me/image/20151217/chat2.png" alt="chat2"></p>
<h3><span id="用户退出">用户退出</span><a href="#用户退出" class="header-anchor"> </a></h3>
<p>kyle用户退出
<img src="//img.tianle.me/image/20151217/chat3.png" alt="logout"></p>
<h4><span id="五-项目代码">五、项目代码</span><a href="#五-项目代码" class="header-anchor"> </a></h4>
<p><a href="https://github.com/zhangtianle/WebSocketChat" target="_blank" rel="noopener">github项目地址</a></p>
]]></content>
      <categories>
        <category>应用开发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
        <tag>spring</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2015/12/16/hello-world/</url>
    <content><![CDATA[<p>Hello World！</p>
<a id="more"></a>
]]></content>
      <tags>
        <tag>HelloWord</tag>
      </tags>
  </entry>
</search>
